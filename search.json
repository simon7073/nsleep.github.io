[{"title":"Hexo-Github搭建博客","url":"/20180401/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"\r\n此篇用以记录使用Hexo搭建博客的过程，不时修改加以完善。\r\n\r\n本地搭建\r\n参考 Hexo\r\n官方文档\r\n在安装 Hexo 前需要先下载并安装 node.js，如果需要换国内的镜像源可以用\r\nnpm config set registry https://registry.npm.taobao.org\r\n换成淘宝的镜像源。\r\n\r\n安装 Hexo\r\nhexo-cli （命令行）是 hexo 的最小安装，即\r\nhexo 包含 hexo-cli。\r\n# 全局安装 hexonpm install hexo -g   hexo -v               # 检查hexo是否安装成功\r\n初始化\r\n在一个空文件夹下执行\r\nhexo init             # 初始化npm install           # 安装所需要的组件# 安装其他依赖包（可选）npm install hexo-deployer-gitnpm install hexo-generator-feednpm install hexo-generator-searchdbnpm install hexo-theme-nextnpm install jquerynpm uninstall hexo-generator-indexnpm install hexo-generator-index2npm uninstall hexo-renderer-markednpm install hexo-renderer-pandoc\r\nnpm audit 用以检查安全性。 可以选择安装\r\nnpm-check 来维护 npm 包的依赖关系。\r\n可以选择安装 npm-check-updates 查看可更新包\r\n# 安装 npm-checknpm i npm-check -g # 检查 npm 包的依赖   npm-check -u -g# 检查是否有依赖冲突npm audit# 解决部分依赖冲突npm audit fix --forcenpm install npm-check-updates -g# 查看可更新包ncu# 更新package.jsonncu -unpm install\r\n安装以后，可以使用以下两种方式执行 Hexo： 1. 使用\r\nnpx hexo &lt;command&gt; 。 2. 将 Hexo\r\n所在的目录添加到环境变量，使用 hexo &lt;command&gt; 。\r\n预览\r\nhexo ghexo s\r\nhexo g 是 hexo generate 的简写，表示将\r\nmarkdown 渲染生成静态文件，生成的文件在 ./public/\r\n文件夹下。参数-d表示文件生成后立即上传云端部署网站，参数-f表示差分机制，只会重新生成改动的文件。\r\nhexo s 是 hexo server\r\n的简写，表示开启本地服务，可以跟参数\r\n-p+端口号，指定端口。\r\n写篇文章\r\nhexo new [layout] &quot;Title&quot;\r\n[layout] 表示采用的模板，默认值为 post\r\n，模板文件在 ./scaffolds/ 文件夹下。\r\n文章标题可以不添加双引号，同时生成两个文章需要用空格隔开。\r\n清除缓存\r\n清除缓存文件 (db.json) 和已生成的静态文件\r\n(./public/*)。\r\nhexo cl\r\n写篇草稿\r\n1). 新建草稿\r\n执行以下命令将在./source/_drafts文件夹下创建一篇文章。\r\nhexo new draft &lt;filename&gt;\r\n2). 预览草稿\r\n预览草稿有两种方式\r\n命令更改配置显示草稿的命令需要附带参数--draft，所以可以执行以下命令\r\nhexo server --draft在配置文件中更改 ./_config.ymlrender_drafts: true\r\n3). 发表草稿\r\n把草稿变成文章，或者页面：\r\nhexo publish [layout] &quot;title&quot;\r\n\r\n更多参见Hexo\r\n\r\n上传到 Github\r\n设置本地Git环境，见 \r\n设置远程仓库\r\n\r\n新建仓库，仓库名必须要遵守格式：YOUR_NAME.github.io\r\n修改分支，使其有 main(默认分支) 和\r\ngh-pages 两个分支\r\n3在仓库设置中修改 Github pages 构建分支为\r\ngh-pages ，域名填写 YOUR_NAME.github.io\r\n\r\n关联仓库\r\ngit clone git@github.com:&lt;YOUR_NAME&gt;/&lt;YOUR_NAME&gt;.github.io.git\r\n然后将初始化的 hexo 合并/复制到本地仓库\r\n将原文件上传\r\ngit add .git commit -m &quot;first commit&quot;git push -u origin main\r\n将静态文件上传\r\n安装 git 插件\r\nnpm install hexo-deployer-git\r\n修改 hexo 配置\r\n\r\n注：所有配置项目的:后都需要一个空格\r\n\r\ndeploy: - type: git  repo: &lt;repository url&gt;   # https://github.com/&lt;username&gt;/&lt;project&gt;  # git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git  branch: gh-pages  message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;\r\n推送页面文件(生成的缓存，即public文件夹下的文件)\r\nhexo clhexo d -g             #  生成以及部署\r\n\r\n其他部署配置\r\n\r\n自动化部署\r\nGithub Actions\r\n自动化部署，每次提交原始文件到 main 分支即可更新。\r\n将密钥上传到仓库的环境变量-/settings/secrets/actions/new,命名例如HEXO_DEPLOY_PRIVATE_KEY\r\n创建新的流程-/actions/new main.ymlname: Hexo Blog CIon:  push:    branches: [ main ]  #pull_request:  #  branches: [ main ]  workflow_dispatch:jobs:  build-gh-pages:    runs-on: ubuntu-latest    steps:      - name: Checkout Repository backup branch        uses: actions/checkout@master       - name: Setup Node.js lts         uses: actions/setup-node@master      - name: Setup Hexo Dependencies        env:          HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRIVATE_KEY &#125;&#125;        run: |          mkdir -p ~/.ssh/          echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; | tr -d &#x27;\\r&#x27; &gt; ~/.ssh/id_rsa           chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts          git config --global user.name &#x27;nsleep&#x27;           git config --global user.email &#x27;simoncq@163.com&#x27;          npm install hexo -g          npm install      - name: Deploy Hexo         run: |          hexo clean          hexo generate           hexo deploy\r\n\n博客搭建完成，访问 YOUR_NAME.github.io\r\n\n\r\njs.org\r\njs.org 修改了添加政策，仅接受与\r\nJavaScript 有明确直接关系的 NPM 包、库、工具等项目 类似的服务：\r\njs.cool, is-a.dev, thedev.id, mod.land, runs-on.tech\r\n更多类似的服务查看 free-for.dev -&gt;\r\nDomain。\r\n\r\n修改 Github pages 域名为\r\n&lt;NAME&gt;.js.org，并将&lt;NAME&gt;.js.org写入到新文件source/CNAME。\r\n详细操作见 Github –\r\njs.org\r\nvercel\r\nvercel.com\r\n是一个自动构建的工具，只要将工作空间的文件所在的 repo\r\n内容库链接到 vercel\r\n就可以得到一个静态博客。在设置里可以自定义域名，连接的\r\nGitHub/Gitlib/Bitbucket 存储库，可以触发给定分支的部署。\r\n更有一个分析工具，洞察加载速度，响应能力，可视化的稳定性，只不过这个功能需要付费。\r\nHeroku\r\nHeroku\r\nNetlify\r\nNetlify\r\n其他部署\r\n除了推送到Github，也可以使用其他平台，比如Gitee和Coding。实践出真知，可以多尝试。\r\n对于Gitee和Coding用了一段时间，都有所限制：\r\n-\r\nGitee：速度尚可，但是自定义域名需要付费，即使可以免费使用几个月，我还是弃了\r\n- Coding：速度挺好，但是在我使用的那段时间隔三岔五访问不了\r\n\r\nFast.io\r\nfast.io于2021/01/15 关闭服务\r\n\r\nFast支持网盘 Google Drive\r\n/ OneDrive / Github / Dropbox /\r\nMediaFire /\r\nBOX。如此获取网盘资源外链，图床不是问题。 但也有\r\n（可忽略的） 限制： - 免费创建5个站点 - 单个文件最大500M -\r\n每个月100G流量\r\nFirebase Hosting\r\nFirebase\r\n是一个把后端作为服务的云平台（BaaS） - 国内无法访问。\r\nFTP服务器\r\n\r\n安装插件\r\n\r\n# 使用淘宝镜像CNPM安装插件npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm install hexo-deployer-ftpsync –save\r\n\r\n修改配置\r\n\r\n修改_config.yml文件:\r\ndeploy:- type: ftpsync                 #上传方式，固定ftpsync  host: hfanss.ftp-gz01.com     #ftp地址  user: ****                    #帐号  pass: ****                    #密码  remote: /webroot/             #上传至哪个目录  port: 8010                    #端口\r\n腾讯云COS\r\n\r\n安装插件\r\n\r\nnpm install hexo-deployer-cos --save\r\n\r\n修改配置\r\n\r\n修改_config.yml文件:\r\ndeploy:- type: cos             # 上传方式，固定cos  appId: 12529*****     # cos的appId  secretId: AKI******   # cos的secretId  secretKey: **********\t# cos的secretKey  bucket: *********     # cos的bucket  region: ap-shanghai   # cos的region\r\n其他平台\r\n\r\nBitbucket\r\naerobatic\r\nsurge\r\natlassian\r\nGitLab\r\n\r\n代码托管 - code.aliyun - oschina - 京东代码库 - gitshell - gitea\r\n更新\r\n更新npm npm install -g npm\r\n更新Next主题(hexo &gt;= 5.0) npm install hexo-theme-next@latest\r\n以查看所有可升级的插件 npm outdated\r\n使用npm-check检查更新 npm install -g npm-checknpm-checknpm-check --skip-unusednpm-check -u\r\n\r\nHexo 升级至 5.0\r\n版\r\nHexo\r\n版本升级和 Next 主题升级之坑\r\n将 Hexo 升级到\r\nv4.2.1\r\nHexo 和 Next\r\n主题升级\r\n\r\n其他相关阅读\r\n简书-hexo使用 grunt\r\n实现自动化\r\n需要注意的问题\r\n\r\n安装 hexo-renderer-pandoc 插件需要 pandoc 软件。\r\n在写 .md 文章的时候注意 ---\r\n后要留空行，不然 hexo-renderer-pandoc 会报错。\r\n\r\n","categories":["教程"],"tags":["Hexo","Github"]},{"title":"服务器管理面板","url":"/20180623/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/","content":"免费 Linux 服务器管理面板\r\n\r\n1.宝塔面板\r\n1).下载\r\n\r\nLinux版下载\r\n\r\n$ yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh\r\n\r\n\r\nWindow版下载：\r\nhttp://download.bt.cn/win/update/net/BtSoft-Win.zip\r\n\r\n2).卸载\r\n$ service bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f /etc/init.d/bt &amp;&amp; rm -rf /www/server/panel\r\n\r\n2.AMH面板\r\n国内、半开源、有收费版本、中文\r\n1).下载\r\n$ wget http://amh.sh/amh.sh &amp;&amp; bash amh.sh 2&gt;&amp;1 | tee amh.log\r\n2).卸载\r\nkillall php-fpmamh nginx stopamh mysql stoprm /root/amh -rf;rm /home/usrdata /home/wwwroot -rf;rm /usr/local/amh* -rf;rm /usr/local/libiconv* -rf;rm /usr/local/nginx* -rf;rm /usr/local/mysql* -rf;rm /usr/local/php* -rf;rm /etc/init.d/amh-start /etc/amh-iptables /bin/amh -f;\r\n\r\n3.WDCP面板\r\n国内、闭源、免费、中文\r\n1).下载\r\n$ wget http://dl.wdlinux.cn:5180/lanmp_laster.tar.gz$ tar zxvf lanmp_laster.tar.gz$ sh install.sh    (或sh in.sh) (默认会安装wdcp,如果只要web环境,而不想安装wdcp,这里改为 sh lanmp.sh即可) \r\n2).卸载\r\n(注意备份数据,否则后果自负)\r\n$ sh install.sh uninstall    (或sh in.sh uninstall)\r\n4.VestaCP面板\r\n1).下载\r\n$ curl -O http://vestacp.com/pub/vst-install.sh &amp;&amp; bash vst-install.sh\r\n2).卸载\r\na.停止VESTA服务\r\n$ service vesta stop\r\nb.卸载\r\nCentOS:$ yum remove vesta*$ rm -f /etc/yum.repos.d/vesta.repoDebian/Ubuntu:$ apt-get remove vesta*$ rm -f /etc/apt/sources.list.d/vesta.list\r\n\r\n删除数据目录和计划任务\r\n\r\nrm -rf /usr/local/vesta\r\n\r\n5.AppNode面板\r\n1).下载\r\n$ INSTALL_AGENT=1 INSTALL_APPS=sitemgr INIT_SWAPFILE=1 INSTALL_PKGS=&#x27;nginx-stable,php56,mysql56&#x27; bash -c &quot;$(curl -sS http://dl.appnode.com/install.sh)&quot;\r\n2).卸载\r\na.卸载受控端\r\nappnode agent remove\r\nb.卸载控制中心\r\nappnode ccenter remove\r\nc.清除残留数据和配置\r\n如果要彻底清除卸载后的残留数据和配置文件，删除三个目录即可：\r\nrm -rf /opt/appnode/&#123;ccenter,agent,ui&#125;/\r\n 注意：由面板安装的环境软件，不会被自动卸载\r\n\r\n","categories":["未分类"],"tags":["服务器","搭建网站"]},{"title":"VPS爆破防御","url":"/20180505/vps%E7%88%86%E7%A0%B4%E9%98%B2%E5%BE%A1/","content":"一、 检查\r\n1. 查看登录失败的IP\r\n显示错误次数 如果错误次数太大 你的服务器十有八九曾被暴力破解\r\n$ grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more\r\n\r\n\r\n\r\nFailed_login\r\n\r\n2.\r\n列出用户所有的登录时间和登录终端的地址\r\n为了验证是否被入侵，可以先查看现在谁在登录服务器，\r\n$ last | more\r\n显示系统中所有用户最近一次登录信息\r\n$ lastlog\r\n二、 处理\r\n1. 加入到黑名单\r\n把对方IP加入到黑名单\r\n$ sudo vim /etc/hosts.deny$ /etc/hosts.deny\r\n2. 禁止所有IP访问SSH功能\r\n$ echo &quot;sshd:all:deny&quot; &gt;&gt; /etc/hosts.deny\r\n3. 更改端口号\r\n编辑sshd配置，修改默认的端口：\r\nvim /etc/ssh/sshd_config\r\n按【i】，进入编辑模式，找到并注释如下：\r\n# Port 22\r\n按【Esc】退出编辑模式，【Shift】+【:】进入命令模式，【:wq】保存并退出\r\n4. 禁止root ssh登录\r\n修改sshd_conf文件\r\nsudo vim /etc/ssh/sshd_config\r\n注释一行\r\n#PermitRootLogin no\r\n三、 重启ssh\r\nsystemctl restart sshd.service或service sshd restart\r\n\r\n","categories":["未分类"],"tags":["服务器"]},{"title":"VPS登陆次数限制","url":"/20180517/vps%E7%99%BB%E9%99%86%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","content":"前言\r\n继上次爆破防御后，依然有陌生IP骚扰，百无聊赖，续作此篇；\r\n\r\n1. 始终允许IP\r\n假设IP：192.168.18.1 是经常登录的IP，填入\r\n/etc/hosts.allow ，当然 :allow\r\n是可以省略的。当hosts.allow和host.deny相冲突时,\r\n以hosts.allow设置为准\r\n$ echo &quot;sshd:192.168.18.1:allow&quot; &gt;&gt; /etc/hosts.allow\r\n\r\n2. 写脚本\r\n在路径 /usr/local/bin/ 下，创建文件\r\nsecure_ssh.sh ，\r\n错误次数大于个位数，即错误次数大于等于10就将IP列入黑名单(判断见行7)。\r\n$ vim /usr/local/bin/secure_ssh.sh\r\n内容如下：\r\n#! /bin/bashcat /var/log/secure|awk &#x27;/Failed/&#123;print $(NF-3)&#125;&#x27;|sort|uniq -c|awk &#x27;&#123;print $2&quot;=&quot;$1;&#125;&#x27; &gt; /usr/local/bin/black.listfor i in `cat  /usr/local/bin/black.list`do  IP=`echo $i |awk -F= &#x27;&#123;print $1&#125;&#x27;`  NUM=`echo $i |awk -F= &#x27;&#123;print $2&#125;&#x27;`  if [ $&#123;#NUM&#125; -gt 1 ]; then    grep $IP /etc/hosts.deny &gt; /dev/null    if [ $? -gt 0 ];then      echo &quot;sshd:$IP:deny&quot; &gt;&gt; /etc/hosts.deny    fi  fidone\r\n3. 列入计划\r\n将脚本文件每一分钟执行一次 (* /1 * * * * )\r\n$ crontab -e\r\n  /1 * * * *  sh /usr/local/bin/secure_ssh.sh或  * * * * *  sh /usr/local/bin/secure_ssh.sh\r\n4. 后记\r\n1).查看记录列表\r\n$ cat /usr/local/bin/black.list \r\n2).清空记录列表\r\nblack.list文件是根据secure日志文件通过上面脚本文件生成的，且每分钟会覆盖一次\r\n$ echo &quot;&quot; &gt; /var/log/secure $ echo &quot;&quot; &gt; /usr/local/bin/black.list\r\n3).修改hosts.deny文件\r\n手动添加或删除IP记录\r\n$ vim /etc/hosts.deny\r\n","categories":["未分类"],"tags":["服务器"]},{"title":"VPN的简单架设","url":"/20180623/vpn%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%B6%E8%AE%BE/","content":"\r\n提要： 系统：CentOS 6.9\r\n\r\n下载shadowsocks服务端\r\n参考文章：秋水逸冰 -\r\nShadowsocks 一键安装脚本（四合一）\r\n使用root用户登录，运行以下命令：\r\n$ wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh &amp;&amp; chmod +x shadowsocks-all.sh &amp;&amp; ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log\r\n\r\n\r\n安装Win ss客户端\r\n常规版\r\nShadowsocks\r\nShadowsocksR\r\n版\r\n\r\n卸载方法\r\n若已安装多个版本，则卸载时也需多次运行\r\n使用root用户登录，运行以下命令：\r\n./shadowsocks-all.sh uninstall\r\n启动脚本\r\nShadowsocks-Python 版： /etc/init.d/shadowsocks-python start | stop |\r\nrestart | status\r\nShadowsocksR 版： /etc/init.d/shadowsocks-r start | stop | restart |\r\nstatus\r\nShadowsocks-Go 版： /etc/init.d/shadowsocks-go start | stop | restart\r\n| status\r\nShadowsocks-libev 版： /etc/init.d/shadowsocks-libev start | stop |\r\nrestart | status\r\n配置文件\r\nShadowsocks-Python 版： /etc/shadowsocks-python/config.json\r\nShadowsocksR 版： /etc/shadowsocks-r/config.json\r\nShadowsocks-Go 版： /etc/shadowsocks-go/config.json\r\nShadowsocks-libev 版： /etc/shadowsocks-libev/config.json\r\n\r\n安装多用户版55R\r\n安装依赖\r\n#CentOS系统yum install unzip ca-certificates -y #Debian和Ubuntu系统apt-get install unzip ca-certificates -y\r\n安装脚本 wget https://www.moerats.com/usr/down/55r.zip &amp;&amp; unzip 55r.zip &amp;&amp; cd 55R* &amp;&amp; bash install.sh\r\n卸载脚本 cd 55R* &amp;&amp; bash uninstall.sh\r\n其他\r\nSSR脚本wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh\r\n\r\nPS: Free SS\r\nv2ray v2rayN\r\n","categories":["未分类"],"tags":["服务器"]},{"title":"Hexo-Github-备份-1","url":"/20180722/hexo-github-%E5%A4%87%E4%BB%BD-1/","content":"用Hexo在GitHub搭建Blog后想要进行备份，方法之一就是通过创建分支把源码放到GitHub上。\r\n一、 需要备份的文件\r\n\r\n文章 ./source\r\n文件夹，这个就不用说了，这里面包含了你写的文章的 markdown\r\n源码，这个是最重要的。\r\n配置文件 根目录下的几个配置文件，主要是 _config.yml、 package.json、\r\n.gitignore。 \r\n主题文件夹 ./themes/themes_name 这里的 themes_name\r\n指的是你的主题名称， 如果咱对主题进行了一些个性化的配置，\r\n那么这个主题也最好全部备份。\r\n模版 ./scaffolds 文件夹， 这个文件夹里是创建文\r\n章时的模板， 如果没修改过这个文件夹中的东西， 可以不用备份。\r\n密钥 .ssh，\r\n咱认为没必要备份，直接放到GitHub不安全，大不了重新生成嘛。\r\n\r\n二、 创建分支\r\n创建GitHub Pages 时咱创建了两个分支：master 与 hexo\r\n\r\nmaster 分支用来存放生成的静态网页\r\nhexo 分支用来存放网站的原始文件\r\n\r\n$ git add .$ git status$ git commit -m &#x27;...&#x27;$ git push --set-upstream origin hexo\r\n另附： $ git branch -a \t\t# 查看远程分支$ git branch \t\t\t# 查看本地分支$ git checkout master \t# 切换分支\r\n三、 推送到分支\r\n创建GitHub Pages 时创建两个分支：master 与 hexo 设置hexo\r\n为默认分支，修改_config.yml中的deploy参数， 分支应为master； 依次执行\r\n$ git add . $ git commit -m “…”$ git push –set-upstream origin hexo 提交原始文件到Hexo\r\n四、 修改日常！\r\n依次执行 $ git add .$ git commit -m &#x27;...&#x27;$ git push origin hexo \r\n指令将改动推送到GitHub（此时当前分支应为hexo）； 然后执行 $ hexo g -d\r\n会发布网站到master分支上。另外，两个过程顺序调转一般不会有问题。\r\n五、 如何恢复\r\n当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\r\n$ git clone -b hexo git@github.com:YOURNAME/YOURNAME.github.io.git# 在本地新拷贝的YOURNAME.github.io文件夹下通过Git \tbash依次执行下列指令：$ npm install hexo$ npm install$ npm install hexo-deployer-git（记得，不需要hexo init这条指令）。\r\n六、 使用 Github Action\r\n自动化流程\r\n也可以采用另一种方式，一个私有仓库——用来存储原始的文章，另一个公共仓库——用来存储经Hexo编译后的文件。\r\n私有仓库在此处命名为blog，公共仓库命名为&lt;YourName&gt;.github.io。\r\n接下来要做的 1.\r\n第一件事就是把重要的文件（包括配置文件）上传到blog，不需要的文件可以在.gitignore中标注。\r\n2. 然后在Github Action 中添加一个任务\r\nset up a workflow yourself 3.\r\n此时打开了一个文件编辑Edit new file，把以下内容覆盖进去，\r\nname: Hexo Blog CIon:  push:    branches: [ main]  workflow_dispatch:jobs:  build:    runs-on: ubuntu-latest    steps:      - name: Checkout Repository backup branch        uses: actions/checkout@master           - name: Setup Node.js 12.x         uses: actions/setup-node@master         with:          node-version: &quot;12.x&quot;            - name: Setup Hexo Dependencies        env:          HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRIVATE_KEY &#125;&#125;        run: |          mkdir -p ~/.ssh/          echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; | tr -d &#x27;\\r&#x27; &gt; ~/.ssh/id_rsa           chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts          git config --global user.name &#x27;nsleep&#x27;           git config --global user.email &#x27;zizhuyun97@163.com&#x27;          npm install hexo-cli -g          npm install                - name: Deploy Hexo         run: |          hexo clean          hexo generate           hexo deploy 4.\r\n最后开启这个流程就可以啦！！每次把文件提交到blog，github就自动编译并提交到&lt;YourName&gt;.github.io\r\n5. 而且备份的话，直接 clone blog 仓库即可。\r\n七、 参考文档：\r\n[GitHub Pages + Hexo搭建博客](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\r\n[使用hexo，如果换了电脑怎么更新博客？(知乎)](https://www.zhihu.com/question/21193762)\r\nand Other...\r\n","categories":["未分类"],"tags":["Hexo"]},{"title":"Hexo-Github-绑定域名","url":"/20180730/hexo-github-%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/","content":"1. 获取GitHub Pages的IP\r\nPing出Github Pages的IP (解析时没有用到IP地址)\r\n$ ping YOURNAME.github.io\r\n2. 配置域名\r\n在目录 YOURNAME下创建一个名为CNAME的文件，文件的内容是你的二级域名\r\n例如：blog.xxxx.com 。\r\n3. 域名解析\r\n拿二级域名blog.xxxx.com举例，记录类型置为CNAME，主机记录置为\r\nblog.xxxx.com 中的 blog ，记录值置为\r\nYOURNAME.githob.io\r\n修改的时候只要修改两个记录类型为A，主机记录分别为@和www的行就可以了\r\n\r\n","categories":["未分类"],"tags":["Hexo"]},{"title":"C语言之*与&的关系","url":"/20191218/c%E8%AF%AD%E8%A8%80%E4%B9%8B-%E4%B8%8E-%E7%9A%84%E5%85%B3%E7%B3%BB/","content":"首先我们知道：*\r\n是指针运算符;&amp;是地址运算符 如果 a\r\n表示a对应的存储单元中的数据。 那么 &amp;a\r\n表示a对应的存储单元的地址。 *a\r\n表示另一个存储单元中的数据。\r\n\r\n闲言少叙上代码： #include &lt;iostream&gt;using namespace std;int main()&#123;\tint a = 10; \tint* b = &amp;a;\tint** c = &amp;b;\t\tcout&lt;&lt; endl\t&lt;&lt; &quot;  &amp;c       c           &amp;b       b           &amp;a       a &quot; &lt;&lt; endl\t&lt;&lt; &quot; ________ ________    ________ ________    ________ __ &quot; &lt;&lt; endl\t&lt;&lt; &quot;|&quot; &lt;&lt; &amp;c &lt;&lt; &quot;|&quot; &lt;&lt; c &lt;&lt; &quot;|  |&quot; &lt;&lt; &amp;b &lt;&lt; &quot;|&quot; &lt;&lt; b &lt;&lt; &quot;|  |&quot; &lt;&lt; &amp;a &lt;&lt; &quot;|&quot; &lt;&lt; a &lt;&lt; &quot;|&quot; &lt;&lt;endl\t&lt;&lt; &quot;______________________________________________________&quot; &lt;&lt; endl &lt;&lt; endl\t&lt;&lt; endl;\t\tcout&lt;&lt; &quot;a : &quot; &lt;&lt;a &lt;&lt;endl\t&lt;&lt; &quot;b : &quot; &lt;&lt; b &lt;&lt;endl\t&lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt;endl\t&lt;&lt;endl\t&lt;&lt; &quot;a = *&amp;a : &quot; &lt;&lt; *&amp;a &lt;&lt;endl\t&lt;&lt; &quot;b = *&amp;b :&quot; &lt;&lt; *&amp;b &lt;&lt;endl\t&lt;&lt; &quot;c = *&amp;c :&quot; &lt;&lt; *&amp;c &lt;&lt;endl;\t\tcout&lt;&lt;endl\t&lt;&lt; &quot;a = *b : &quot; &lt;&lt; *b &lt;&lt;endl\t&lt;&lt; &quot;b = *c : &quot; &lt;&lt; *c &lt;&lt;endl;\t\tcout&lt;&lt;endl\t&lt;&lt; &quot;a = **c : &quot; &lt;&lt; **c &lt;&lt;endl\t&lt;&lt;endl\t&lt;&lt; &quot;b = &amp;a : &quot; &lt;&lt; &amp;a &lt;&lt;endl\t&lt;&lt; &quot;\\t (b == &amp;a) is &quot; &lt;&lt; (b == &amp;a) &lt;&lt;endl\t&lt;&lt; &quot;c = &amp;b : &quot; &lt;&lt; &amp;b &lt;&lt;endl\t&lt;&lt; &quot;\\t (c == &amp;b) is &quot; &lt;&lt; (c == &amp;b) &lt;&lt;endl;\t\tint* d;\td=&amp;a;\t\tcout&lt;&lt; endl\t&lt;&lt; &quot;______________________________________________________&quot; &lt;&lt; endl\t&lt;&lt; &quot;c != &amp;&amp;a&quot; &lt;&lt;endl &lt;&lt; endl\t&lt;&lt; &quot; _&amp;c_____ _c______    _&amp;b_____ _b______    _&amp;a_____ _a &quot; &lt;&lt; endl\t&lt;&lt; &quot;|&quot; &lt;&lt; &amp;c &lt;&lt; &quot;|&quot; &lt;&lt; c &lt;&lt; &quot;|  |&quot; &lt;&lt; &amp;b &lt;&lt; &quot;|&quot; &lt;&lt; b &lt;&lt; &quot;|  |&quot; &lt;&lt; &amp;a &lt;&lt; &quot;|&quot; &lt;&lt; a &lt;&lt; &quot;|&quot; &lt;&lt;endl\t&lt;&lt; &quot;                      _&amp;d_____ _d______ &quot; &lt;&lt; endl\t&lt;&lt; &quot;                     |&quot;&lt;&lt; &amp;d &lt;&lt; &quot;|&quot; &lt;&lt; d &lt;&lt; &quot;|&quot; &lt;&lt;endl\t&lt;&lt; endl;\t&#125; \r\n 由上图我们可以看出 1. &amp;[变量]\r\n就是取变量的地址 2. *[地址] 就是取该地址下的变量存储的值 3.\r\n&amp;a是a的地址，但不能说明是b或d的值，所以&amp;(&amp;a)不存在[&amp;&amp;\r\n是与逻辑运算符]\r\n\r\n在C语言中的数组本质上其实也是指针，即：*a 等同于 a[]。\r\n\r\n","categories":["编程语言"],"tags":["C语言"]},{"title":"Hexo过滤文章","url":"/20190609/hexo%E8%BF%87%E6%BB%A4%E6%96%87%E7%AB%A0/","content":"转载 hexo-generator-index2\r\n\r\n简介\r\n带过滤功能的Hexo首页生成器插件。在官方的首页生成器基础上添加了过滤指定分类/标签的功能。比如，在首页只显示指定分类下面的文章列表。\r\n除此之外，它还在指定的目录下生成指定类型的文章，比如在web目录下生成Web相关的文章。\r\n安装\r\nhexo-generator-index2可以完全替代官方的hexo-generator-index，所以安装之后，先卸载官方的插件，不然会引起一些冲突。\r\nnpm unnstall hexo-generator-index --savenpm install hexo-generator-index2 --save\r\n选项\r\nindex2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: true # defult is trueindex2_generator:  - layout: &#x27;archive&#x27; # use existing archive layout    path: &#x27;web&#x27; # output to web folder: http://127.0.0.1:4000/web/    per_page: 10    order_by: -date    include:      - category Web # include article which category is Web    exclude:      - tag Hexo # exclude article which tag is Hexo  - layout: &#x27;index&#x27; # use existing index layout    path: &#x27;&#x27; # output to root directory: http://127.0.0.1:4000/    index: true # Set whether index, results is_home() is true or not- **per_page**: 每页显示的帖子. (0 = 禁用分页)- **order_by**: 排序 Posts. (默认情况下按日期降序排序)- **layout**: 设置 layout, 默认为 `index`- **path**: 输出路径, 如果路径是 `&#x27;&#x27;`, 表示输出到根目录 (http://127.0.0.1:4000/ )- **index**: Home index or not, if `true` and the path is `&#x27;&#x27;`, same to offical [hexo-generator-index](https://github.com/hexojs/hexo-generator-index)- **include**: 帖子过滤器包括选项- **exclude**: 帖子过滤器排除选项\r\n除了include和exclude，其它如per_page和order_by都是原有的官方首页生成器选项，不必更改。\r\nInclude/exclude\r\n选项格式为属性 值（注意，属性与值中间有个英文的空格），可选的属性有：\r\n- category: 文章分类 - tag: 文章标签 - path: 文章源路径\r\n填坑\r\n\r\n正如安装时所说，index和index2不能同时存在；\r\n配置时注意include和exclude两个选项，它们的属性最好保留，这样只需要在需要过滤掉的文章里添加\r\ntag: hide\r\n\r\n参考文章：过滤插件-Git\r\n","categories":["未分类"],"tags":["Hexo"]},{"title":"GC算法介绍","url":"/20201203/gc%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/","content":"介绍 GC\r\nGC(Garbage Collection ,\r\n垃圾收集)是将程序运行过程中产生的一些无用的对象占用的空间进行释放，避免\r\nOOM(Out Of Memory , 内存溢出)。\r\n常用的GC算法有引用计数算法、标记-清除算法、复制算法、标记-整理算法\r\n &gt; 在 C/C++\r\n里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。 &gt; 在\r\nJava\r\n中，后台专门有一个专门用于垃圾回收的线程来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，目的在于防止由程序猿引入的人为的内存泄露。\r\n&gt; 在 Python 中垃圾回收的主要算法是引用计数。\r\n早在1960年 Lisp 就使用了 GC。 GC 主要是完成三件事情： -\r\n哪些内存需要回收？ - 什么时候回收？ - 如何回收？\r\nGC算法的评判标准主要是以下4点： 1. 吞吐量：即单位时间内的处理能力。\r\n2. 最大暂停时间：因执行GC而暂停执行程序所需的时间。 3.\r\n堆的使用效率：鱼与熊掌不可兼得，堆使用效率和吞吐量、最大暂停时间是不可能同时满足的。即可用的堆越大，GC运行越快；相反，想要利用有限的堆，GC花费的时间就越长。\r\n4.\r\n访问的局部性：在存储器的层级构造中，我们知道越是高速存取的存储器容量会越小（具体可以参看我写的存储器那篇文章）。由于程序的局部性原理，将经常用到的数据放在堆中较近的位置，可以提高程序的运行效率。\r\n引用计数算法\r\n引用计数法就是给每个对象一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；任何时刻计数器的值为0的对象就是不可能再被使用的。\r\n这个引用计数法时没有被 Java 所使用的，但是 python\r\n有使用到它。而且最原始的引用计数法没有用到 GC Roots。 在Python中 del 语句删除名称，而不是对象。del\r\n命令可能会导致对象被当做垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。\r\n&gt;\r\n有个__del__特殊方法，但是它不会销毁实例，不应该在代码中调用。即将销毁实例时，Python解释器会调用__del__方法，给实例最后的机会，释放外部资源。\r\nimport weakrefs1 = &#123;1,2,3&#125;s2 = s1def bye():    print(&#x27;Gone with the wind...&#x27;)ender = weakref.finalize(s1, bye)ender.alive # Truedel s1ender.alive # Trues2 = &#x27;spam&#x27; # Gone with the wind...ender.alive # False\r\n[巴西]Luciano Ramalho [译]安道 吴珂Fluent Python\r\n优点缺点\r\n可即时回收垃圾：在该方法中，每个对象始终知道自己是否有被引用，当被引用的数值为0时，对象马上可以把自己当作空闲空间链接到空闲链表。\r\n最大暂停时间短。\r\n没有必要沿着指针查找\r\n\r\n计数器值的增减处理非常繁重，影响性能\r\n计算器需要占用很多位。\r\n实现繁琐。\r\n循环引用无法回收\r\n\r\n标记-清除算法\r\n标记-清除算法是现代垃圾回收算法的思想基础。\r\n标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。\r\n当堆中的有效内存空间（available\r\nmemory）被耗尽的时候，GC线程就会被触发并将程序暂停（stop the\r\nworld），然后进行标记和清除。 - 标记：遍历所有的GC Roots，然后将所有GC\r\nRoots可达的对象标记为存活的对象。 -\r\n清除：将遍历堆中所有的对象，将没有标记的对象全部清除掉。\r\n\r\n\r\n标记清除算法\r\n\r\n\r\n为什么非要停止程序的运行呢？\r\n当标记结束而未开始清除时，程序又新创建一个对象，这个对象由于没有被标记，所以会被CG线程清除，从而导致错误。\r\n\r\n优点缺点\r\n算法简单、容易实现\r\n与保守式GC 算法兼容\r\n清除算法不会移动对象，所以非常适合搭配保守式算法\r\n\r\n效率比较低（递归与全堆对象遍历），导致stop the\r\nworld的时间比较长，导致用户体验差\r\n这种方式清理出来的空闲内存是不连续的，会产生内存碎片。需要维护一个空闲列表\r\n\r\n复制算法\r\n复制算法（新生代的GC）是将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。\r\n\r\n复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，这个太要命了。所以复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。\r\n现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。\r\n当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。整个过程如下图所示：\r\n\r\n上图中，绿色箭头的位置代表的是大对象，大对象直接进入老年代。\r\n优点缺点没有标记和清除过程,实现简单,运行高效。\r\n复制过去以后保证空间的连续性,不会发生碎片化。 优秀的吞吐量。\r\n可实现高速分配：复制算法不用使用空闲链表。这是因为分块是连续的内存空间，因此，调用这个分块的大小，只需要这个分块大小不小于所申请的大小，移动指针进行分配即可。\r\n与缓存兼容。此算法的缺点也是很明显的,就是需要两倍的内存空间。\r\n对于G1这种分拆成大量region的GC,复制而不是移动,意味着GC需要维护region之间对象引用关系,不管是内存占用或者时间开销也不小。\r\n堆的使用效率低下 不兼容保守式GC算法\r\n标记-整理算法\r\n\r\n如果在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选中这种算法。\r\n\r\n标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间。\r\n -\r\n标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC\r\nRoots，然后将存活的对象标记。 -\r\n整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。\r\n上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。\r\n优点缺点弥补 标记/清除算法 当中内存区域分散的缺点\r\n消除了复制算法当中内存减半的高额代价。效率也不高。不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。\r\n小总结\r\n效率：复制算法&gt;标记/整理算法&gt;标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。\r\n内存整齐度：复制算法=标记/整理算法&gt;标记/清除算法。\r\n内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。 -\r\n注1：可以看到标记/清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的。\r\n- 注2：时间与空间不可兼得。\r\n分代收集算法：（新生代的GC+老年代的GC）\r\n当前商业虚拟机的GC都是采用的“分代收集算法”，这并不是什么新的思想，只是根据对象的存活周期的不同将内存划分为几块儿。一般是把Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。\r\n-\r\n少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。\r\n-\r\n大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。\r\n注：老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代。\r\n保守式GC与准确式GC\r\n保守式GC\r\n所谓保守式GC就是“不能识别指针和非指针的GC”。\r\n对于寄存器、调用栈、全局变量空间来说，都是不明确的根。例如调用栈中，装着函数内的局部变量和参数值。而局部变量，如C语言中的int、double这样就是非指针，但是也会有像void*这样的指针。\r\n那么保守式GC会怎么检查不明确的根呢？1、是不是被正确对齐的值？（在32位CPU的情况下，为4的倍数）2、是不是指着堆内？3、是不是指向对象的开头？当然，这些只是基本的检查项目。\r\n上面的检查方法会将一些非指针识别成指针。例如一个数值和一个地址，它们两个值相等，这个时候，那个值也可以被识别成指针。\r\n保守式GC的优点是语言处理程序不依赖与GC。缺点为识别指针和非指针需要付出成本、错误识别指针会压迫堆、能够使用的GC算法有限。例如GC复制算法就不能使用，因为其可能会将非指针重写。\r\n### 准确式GC\r\n准确式GC能够正确识别指针和非指针的GC。正确的根的创建方法是依赖于语言处理程序的实现的。我们可以通过打标签、不把寄存器和栈等当作根的方法来实现。\r\n其优点就是完全能够识别指针，能够使用复制算法等需要移动对象的算法。但是在创建准确式GC时，语言处理程序必须对GC进行一些支援，而且创建正确的根就必须付出一定的代价。\r\n其实我们垃圾回收机的实现都不是仅仅用哪一种回收算法，都是将几个结合使用，特别是分代算法，后面我们会详细的介绍。\r\n","categories":["未分类"],"tags":["算法"]},{"title":"何为Metaclass","url":"/20201205/%E4%BD%95%E4%B8%BAmetaclass/","content":"什么是 metaclass ？\r\nmetaclass 意为 元类\r\n超类，可以对子类进行操作，就像装饰器那样可以动态定制和修改被装饰的类，metaclass\r\n可以动态的定制或修改继承它的子类。\r\n\r\nmetaclass 能解决什么问题？\r\n只需要实现一个 metaclass 超类，然后再实现一个子类继承这个\r\nmetaclass，就可以根据不同的配置文件自动拉取不同的类，这极大地提高了效率。\r\n一个实例\r\nIn[15]: class Mymeta(type):   ...:     def __init__(self, name, bases, dic):   ...:         super().__init__(name, bases, dic)   ...:         print(&#x27;===&gt;Mymeta.__init__&#x27;)   ...:         print(self.__name__)   ...:         print(dic)   ...:         print(self.yaml_tag)   ...:    ...:     def __new__(cls, *args, **kwargs):   ...:         print(&#x27;===&gt;Mymeta.__new__&#x27;)   ...:         print(cls.__name__)   ...:         return type.__new__(cls, *args, **kwargs)   ...:    ...:     def __call__(cls, *args, **kwargs):   ...:         print(&#x27;===&gt;Mymeta.__call__&#x27;)   ...:         obj = cls.__new__(cls)   ...:         cls.__init__(cls, *args, **kwargs)   ...:         return obj   ...: In[16]: In[16]: In[16]: class Foo(metaclass=Mymeta):   ...:     yaml_tag = &#x27;!Foo&#x27;   ...:    ...:     def __init__(self, name):   ...:         print(&#x27;Foo.__init__&#x27;)   ...:         self.name = name   ...:    ...:     def __new__(cls, *args, **kwargs):   ...:         print(&#x27;Foo.__new__&#x27;)   ...:         return object.__new__(cls)   ...:     ===&gt;Mymeta.__new__Mymeta===&gt;Mymeta.__init__Foo&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;Foo&#x27;, &#x27;yaml_tag&#x27;: &#x27;!Foo&#x27;, &#x27;__init__&#x27;: &lt;function Foo.__init__ at 0x0000000007EF3828&gt;, &#x27;__new__&#x27;: &lt;function Foo.__new__ at 0x0000000007EF3558&gt;&#125;!FooIn[17]: foo = Foo(&#x27;foo&#x27;)===&gt;Mymeta.__call__Foo.__new__Foo.__init__\r\n从上面的运行结果可以发现在定义 class Foo() 时，会依次调用 MyMeta 的\r\n__new__ 和 __init__ 方法构建 Foo\r\n类，然后在调用 foo = Foo() 创建类的实例对象时，才会调用 MyMeta 的\r\n__call__ 方法来调用 Foo 类的 __new__ 和\r\n__init__ 方法。\r\n把上面的例子运行完之后就会明白很多了，正常情况下我们在父类中是不能对子类的属性进行操作，但是元类可以。换种方式理解：元类、装饰器、类装饰器都可以归为元编程。\r\n底层是如何实现 metaclass 的？\r\n第一，所有的 Python 的用户定义类，都是 type 这个类的实例。\r\n第二，用户自定义类，只不过是 type 类的 __call__ 运算符重载\r\n第三，metaclass 是 type 的子类，通过替换 type 的 __call__\r\n运算符重载机制，“超越变形”正常的类\r\n","categories":["编程语言"],"tags":["Python","metaclass"]},{"title":"Hexo-Search配置","url":"/20190324/hexo-search%E9%85%8D%E7%BD%AE/","content":"官方文档\r\n安装插件\r\n$ npm install hexo-generator-search --save\r\n配置文件\r\n修改在根目录下的_config.yml search:  path: search.xml   field: all   content: true  * path -\r\n文件的路径。默认是 search.xml。如果文件扩展名为 .json,则输出格式为JSON。\r\n* field - 要搜索的搜索范围： * post (Default) - 仅涵盖您博客的所有帖子。\r\n* page - 仅涵盖您博客的所有页面。 * all - 将涵盖您博客的所有帖子和页面。\r\n* content -\r\n是否包含每篇文章的全部内容。如果false，生成的结果仅覆盖没有主体的标题和其他元信息。默认是true。\r\n— # 排除索引 在文章顶部配置里加入 indexing: false\r\n","categories":["未分类"],"tags":["Hexo"]},{"title":"详解Python装饰器","url":"/20201204/%E8%AF%A6%E8%A7%A3python%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。\r\n[巴西]Luciano Ramalho [译]安道 吴珂Fluent Python\r\n\r\n闭包\r\n在了解装饰器之前先讲一下闭包，闭包是一种特殊的函数，这种函数由多个函数的嵌套组成，且称之为外函数和内函数，外函数返回值是内函数的引用，此时就构成了闭包。构建一个闭包有以下几点要求：\r\n1. 多个函数的嵌套 2. 必须返回一个函数对象 3.\r\n返回的那个函数必须引用外部变量 闭包的优点： -\r\n闭包可以保存运行环境，即在闭包内的变量是不能被轻易修改的； -\r\n闭包的好处：提高代码的可复用性。 举个栗子： def out_func(n):    def in_func(num):        return n*num    return in_funcdemo = out_func(3)res = demo(4)print(res)\r\n装饰器\r\n装饰器也是一种闭包，只不过它的参数是被装饰的函数。举个栗子，定义一个装饰器，计算函数的执行时间：\r\nimport time# 定义装饰器def time_calc(func):    def wrapper(*args, **kargs):                start_time = time.time()                f = func(*args,**kargs)                 exec_time = time.time() - start_time        return f        return wrapper       # 使用装饰器@time_calc    def add(a, b):    return a + b    @time_calcdef sub(a, b):        return a - b\r\n上述的装饰器与add = time_calc(add)含义相同。但是这样的装饰器仍有缺陷，执行print(add.__name__)语句会发现输出的并不是add，而是wrapper，是因为这个函数重写了add的名字和注释文档。幸运的是，Python中functools.wraps函数可以解决这个问题。\r\nfrom functools import wrapsdef time_calc(func):    @wraps(func)    def wrapper(*args, **kargs):        start_time = time.time()        f = func(*args,**kargs)        exec_time = time.time() - start_time        print(&#x27;RunTime&#x27;,exec_time)        return f    return wrapper   @time_calc    def add(a, b):    return a + b\r\n而上面的例子除了可以用函数来定义，也可以用类来定义。\r\nfrom functools import wrapsclass time_calc(object):    def __call__(self,func):        @wraps(func)        def wrapper(*args, **kargs):            start_time = time.time()            f = func(*args,**kargs)            exec_time = time.time() - start_time            print(&#x27;RunTime&#x27;,exec_time)            return f        return wrapper     def notify(self):        pass@time_calc()def add(a, b):    return a + b 再来个与它类似的，找不同！ from functools import wrapsclass time_calc(object):    def __init__(self, func):        self._func = func    def __call__(self):        @wraps(self._func)        def wrapper(*args, **kargs):            start_time = time.time()            f = self._func(*args,**kargs)            exec_time = time.time() - start_time            print(&#x27;RunTime&#x27;,exec_time)            return f        return wrapper     def notify(self):        pass@time_calcdef add(a, b):    return a + b\r\n内置装饰器\r\n常见的有三种：@property、@staticmethod、@classmethod\r\n@property\r\n把类内方法当成属性来使用，必须要有返回值，相当于getter；假如没有定义\r\n@func.setter\r\n修饰方法的话，就是只读属性 # 将 property 函数用作装饰器可以很方便的创建只读属性# 下面的代码将 voltage() 方法转化成同名只读属性的 getter 方法。class Parrot(object):    def __init__(self):        self._voltage = 100000     @property    def voltage(self):        &quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;        return self._voltage# property 的 getter,setter 和 deleter 方法同样可以用作装饰器# 下面两个例子是完全相同的class C(object):    def __init__(self):        self._x = None    def getx(self):        return self._x    def setx(self, value):        self._x = value    def delx(self):        del self._x    x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)class C(object):    def __init__(self):        self._x = None    @property    def x(self):        &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;        return self._x    @x.setter    def x(self, value):        self._x = value    @x.deleter    def x(self):        del self._x\r\n@staicmethod\r\n静态方法，不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。\r\n@classmethod\r\n类方法，不需要self参数，但第一个参数需要是表示自身类的cls参数。\r\nclass Demo(object):    text = &quot;三种方法的比较&quot;        def instance_method(self):        print(&quot;调用实例方法&quot;)    @classmethod    def class_method(cls):        print(&quot;调用类方法&quot;)        print(&quot;在类方法中 访问类属性 text: &#123;&#125;&quot;.format(cls.text))        print(&quot;在类方法中 调用实例方法 instance_method: &#123;&#125;&quot;.format(cls().instance_method()))    @staticmethod    def static_method():        print(&quot;调用静态方法&quot;)        print(&quot;在静态方法中 访问类属性 text: &#123;&#125;&quot;.format(Demo.text))        print(&quot;在静态方法中 调用实例方法 instance_method: &#123;&#125;&quot;.format(Demo().instance_method()))if __name__ == &quot;__main__&quot;:    # 实例化对象    d = Demo()        # 对象可以访问 实例方法、类方法、静态方法    # 通过对象访问text属性    print(d.text)        # 通过对象调用实例方法    d.instance_method()        # 通过对象调用类方法    d.class_method()        # 通过对象调用静态方法    d.static_method()        # 类可以访问类方法、静态方法    # 通过类访问text属性    print(Demo.text)        # 通过类调用类方法    Demo.class_method()        # 通过类调用静态方法    Demo.static_method()\r\n区别\r\n在定义静态类方法和类方法时，@staticmethod\r\n装饰的静态方法里面，想要访问类属性或调用实例方法，必须需要把类名写上；\r\n而@classmethod装饰的类方法里面，会传一个cls参数，代表本类，这样就能够避免手写类名的硬编码。\r\n在调用静态方法和类方法时，实际上写法都差不多，一般都是通过\r\n类名.静态方法() 或 类名.类方法()。\r\n也可以用实例化对象去调用静态方法和类方法，但为了和实例方法区分，最好还是用类去调用静态方法和类方法。\r\n使用场景\r\n假如不需要用到与类相关的属性或方法时，就用静态方法@staticmethod；\r\n假如需要用到与类相关的属性或方法，然后又想表明这个方法是整个类通用的，而不是对象特异的，就可以使用类方法@classmethod。\r\n","categories":["编程语言"],"tags":["Python"]},{"title":"音乐API","url":"/20200322/%E9%9F%B3%E4%B9%90api/","content":"一、 网易\r\n1. 何以诚.网易云音乐API分析.CSDN\r\n\r\nQQ音乐\r\n参考资料： + 官方 - QQ音乐 |\r\n移动WEB接入说明\r\n\r\n简书\r\nQQ音乐api的使用\r\nQQ音乐网页接口分析\r\nqq音乐api接口\r\nCSDN\r\n2019最新QQ音乐Api\r\n\r\n二、 酷狗\r\n虾米\r\n百度\r\n一听\r\n咪咕\r\n荔枝\r\n蜻蜓\r\n喜马拉雅\r\n全民K歌\r\n5sing原创\r\n5sing翻唱\r\n","categories":["未分类"]},{"title":"Python路径操作新标准：pathlib 模块","url":"/20201209/python%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C%E6%96%B0%E6%A0%87%E5%87%86%EF%BC%9Apathlib-%E6%A8%A1%E5%9D%97/","content":"pathlib\r\n模块 官方的回答\r\n\r\n获取当前路径\r\nos.getcwd()\r\npathlib.Path.cwd()\r\n获取父目录\r\nos.path.dirname(os.getcwd())\r\nstr(pathlib.Path.cwd().parent)\r\n拼接路径\r\nos.path.join(os.getcwd(), ‘a’, ‘b’)\r\npaths = (‘a’, ‘b’) pathlib.Path.cwd().joinpath(*paths)\r\n","categories":["编程语言"],"tags":["Python","pathlib"]},{"title":"Hexo-添加友链页面","url":"/20200331/hexo-%E6%B7%BB%E5%8A%A0%E5%8F%8B%E9%93%BE%E9%A1%B5%E9%9D%A2/","content":"写在前面\r\n在此使用的是NexT主题，自己创建一个友情链接页面。\r\n\r\n1. 添加友链页面\r\n\r\n添加页面\r\n\r\n在 ./source/ 目录下创建links/index.md，\r\n或执行命令\r\nhexo new page links\r\n可以在文件内写友链声明等内容，将会被放在友链后。\r\n\r\n2. 修改配置\r\n修改主题配置文件\r\n./themes/next/_config.ymlmenu:  home: / || home  ···  links: /links/ || link\r\n修改主题语言配置文件，以zh-Hans.yml为例\r\n./themes/next/language/zh-Hans.ymlmenu:  home: 首页  ···  links: 友链 # 新增该选项表示新增“友链”菜单\r\n3. 添加模板\r\n创建./themes/next/layout/links.swig文件\r\n\r\n\r\n在此贴上我的代码， 【此处折叠】\r\n\r\n\r\n\r\n在./themes/next/layout/page.swig中引入模板，\r\n./themes/next/layout/page.swig······&lt;!-- 友情链接--&gt; &#123;% elif page.type === &#x27;links&#x27; %&#125;\t &#123;% include &#x27;links.swig&#x27; %&#125;&lt;!-- 友情链接--&gt;&#123;% elif page.type === &#x27;schedule&#x27; %&#125;······\r\n4. 添加样式\r\n创建./themes/next/source/css/mystyle.css文件\r\n\r\n\r\n在此贴上我的代码， 【此处折叠】\r\n\r\nmystyle.cssview raw#links {\tmargin-top: 60px;}.links-content {\tmargin-top: 1rem;}.links-content .mdui-panel-item, .links-content .mdui-panel-gapless{\t-webkit-box-shadow: none !important;\tbox-shadow: none !important;}.links-content .mdui-panel-item .note{\tmargin: 0px;}.link-navigation{\tmargin-top: 15px;}.link-navigation::after {\tcontent: &quot; &quot;;\tdisplay: block;\tclear: both;}.card {\twidth: 300px;\theight: 64px;\tfont-size: 1rem;\tpadding: 10px 20px;\tborder-radius: 4px;\ttransition: 0.4s;\tmargin-bottom: 1rem;\tdisplay: block;\t-webkit-box-shadow: 0 3px 1px -2px rgba(0, 0, 0, .2), 0 2px 2px 0 rgba(0, 0, 0, .14), 0 1px 5px 0 rgba(0, 0, 0, .12);\tbox-shadow: 0 3px 1px -2px rgba(0, 0, 0, .2), 0 2px 2px 0 rgba(0, 0, 0, .14), 0 1px 5px 0 rgba(0, 0, 0, .12);\t}.card:nth-child(odd) {\tfloat: left;}.card:nth-child(even) {\tfloat: right;}.card:hover {\ttransform: scale(1.1);\t-webkit-box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);\tbox-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);}.card a {\tborder: none;\tdisplay: inline-flex;}.card .ava {\twidth: 4rem !important;\theight: 4rem !important;\tmargin: 0 !important;\tmargin-right: 1em !important;\tborder-radius: 4px;\tdisplay: inline;}.card .card-header {\tfont-style: italic;\toverflow: hidden;\twidth: 236px;\tpadding-left: 10px;}.card .link {\tfont-style: normal;\tcolor: #2bbc8a;\tfont-weight: bold;\ttext-decoration: none;}.card .link:hover {\tcolor: #d480aa;\ttext-decoration: none;}.card .card-header .info {\tfont-style: normal;\tcolor: #a3a3a3;\tfont-size: 14px;\tmin-width: 0;\ttext-overflow: ellipsis;\toverflow: hidden;\twhite-space: nowrap;}.squareCard {\tmargin: 5px 10px !important;\tpadding: 3px !important;\tborder-radius: 3px;\toverflow: hidden;\tfloat: left;\twidth: 145px;\tposition: relative;\tmin-height: 1px;\t-webkit-box-sizing: border-box;\tbox-sizing: border-box;\tborder-radius: 2px;\t-webkit-box-shadow: 0 3px 1px -2px rgba(0, 0, 0, .2), 0 2px 2px 0 rgba(0, 0, 0, .14), 0 1px 5px 0 rgba(0, 0, 0, .12);\tbox-shadow: 0 3px 1px -2px rgba(0, 0, 0, .2), 0 2px 2px 0 rgba(0, 0, 0, .14), 0 1px 5px 0 rgba(0, 0, 0, .12);\t-webkit-transition: -webkit-box-shadow .25s cubic-bezier(0.4, 0, 0.2, 1);\ttransition: -webkit-box-shadow .25s cubic-bezier(.4, 0, .2, 1);\ttransition: box-shadow .25s cubic-bezier(.4, 0, .2, 1);\ttransition: box-shadow .25s cubic-bezier(.4, 0, .2, 1), -webkit-box-shadow .25s cubic-bezier(.4, 0, .2, 1);\twill-change: box-shadow;\t\ttransition: all .3s;}.squareCard:hover {\t-webkit-box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);\tbox-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);\topacity: .8;}@media (max-width: 600px) {\t.squareCard {\t\tfloat: left;\t}}/*- top: 0;- left: 0;- width: 100%;- height: 100%;- background: rgba(255, 255, 255, 0.5);- -webkit-transition: -webkit-transform 0.5s;- transition: transform 0.5s;- -webkit-transform: scale3d(1.9, 1.4, 1) rotate3d(0, 0, 1, 45deg) translate3d(0, -100%, 0);- transform: scale3d(1.9, 1.4, 1) rotate3d(0, 0, 1, 45deg) translate3d(0, -100%, 0);+ left: -100px;+ bottom: -63px;+ width: 50px;+ height: 277px;+ background: #fff;+ -webkit-transition:  transform 0.5s ease;+ transition: transform 0.5s ease;+ -webkit-transform:  translateX(-50px) rotate(45deg);+ transform: translateX(-50px) rotate(45deg);*/.squareCard::before {\tposition: absolute;\tcontent: &#x27;&#x27;;\tleft: -100px;\tbottom: -63px;\twidth: 50px;\theight: 277px;\tbackground: #fff;\t-webkit-transition:  transform 0.5s ease;\ttransition: transform 0.5s ease;\t-webkit-transform:  translateX(-50px) rotate(45deg);\ttransform: translateX(-50px) rotate(45deg);\tz-index: 99999;}/*- -webkit-transform: scale3d(1.9, 1.4, 1) rotate3d(0, 0, 1, 45deg) translate3d(0, 100%, 0);- transform: scale3d(1.9, 1.4, 1) rotate3d(0, 0, 1, 45deg) translate3d(0, 100%, 0);+ -webkit-transform:  translateX(360px) rotate(45deg);+ transform: translateX(360px) rotate(45deg);*/.squareCard:hover::before {\t-webkit-transform:  translateX(360px) rotate(45deg);\ttransform: translateX(360px) rotate(45deg);}.squareCard a {\tposition: relative;\tdisplay: inline-block;\toverflow: hidden;\tcolor: #ff4081;\ttext-decoration: none;\tvertical-align: top;\toutline: 0;}.squareCard img {\tmargin: 0 !important;\tpadding: 0 !important;\twidth: 10rem;\theight: 8.7rem;\tbackground-color: aliceblue;\tobject-fit: contain;}.squareCard .card-header {\twidth: calc(100%);\tborder-bottom-left-radius: 3px;\tborder-bottom-right-radius: 3px;\toverflow: hidden;\tbackground: rgba(0, 0, 0, .3);\tz-index: 3;\tposition: absolute;\tright: 0;\tbottom: 0;\tmin-height: 48px;\tmax-height: 68px;\tbox-sizing: border-box;\tpadding: 5px;\tcolor: #fff;\t-webkit-box-align: center;\t-webkit-align-items: center;\talign-items: center;}.squareCard .card-header div:first-of-type {\theight: 20px;\ttext-align: left;\toverflow: hidden;\tfont-size: 16px;\tline-height: 16px;\ttext-overflow: ellipsis;\twhite-space: nowrap;\ttransition: all .3s;}.squareCard .card-header .info {\theight: 18px;\tmargin-top: 4px;\toverflow: hidden;\tfont-size: 12px;\tline-height: 18px;\ttext-overflow: ellipsis;\twhite-space: nowrap;\topacity: 1;}\r\n\r\n5. 添加友链\r\n创建./source/_data/links.yml文件，并配置\r\n./source/_data/links.ymldefaultPic: /static/images/default.png # 默认图片shape:  # 可选值 square | circle，默认squaredefaultlinks:- nickname: # 名称  site:     # 网址  avatar:   # 头像  info:     # 简介  friendslinks :- nickname: # 名称  site:     # 网址  avatar:   # 头像  info:     # 简介\r\n","categories":["未分类"],"tags":["Hexo"]},{"title":"SS加速","url":"/20190324/ss%E5%8A%A0%E9%80%9F/","content":"ss加速\r\nbbr 加速下载\r\n参考文章：秋水逸冰 -\r\n一键安装最新内核并开启 BBR 脚本\r\n$ wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh\r\n\r\n锐速ServerSpeeder\r\n$ wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh$ bash serverspeeder.sh\r\nPS: BBR+BBR魔改+Lotsever(锐速)一键脚本\r\nfor Centos/Debian/Ubuntu\r\n","categories":["未分类"],"tags":["服务器"]},{"title":"Hexo-添加音乐播放器","url":"/20200303/hexo-%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"前言\r\n\r\n在此使用的是Aplayer.MoePlayer.GitHub\r\n，在Next(Gemini)主题下设置。 本文是自主创建，也可使用hexo-tag-aplayer插件。\r\n搭配音乐搜索器.maicong.GitHub\r\n使用更佳\r\n\r\n一、 安装\r\n在GitHub下载 Aplayer，然后将dist文件夹复制到themes/next/source文件夹下。\r\n\r\n注：尝试复制到 source文件夹下失败。\r\n\r\n\r\n二、 配置\r\n新建 themes/next/source/dist/music.js\r\n文件，添加内容：\r\nconst ap = new APlayer(&#123;    container: document.getElementById(&#x27;aplayer&#x27;),\t\tfixed: true, \t\t// 吸底模式\tautoplay: true,\t\t// 自动播放\ttheme: &#x27;#b7daff&#x27; ,\t//主题色\tloop: &#x27;all&#x27;, \t\t// 循环播放, 可选值: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27;\torder: &#x27;list&#x27;,\t\t// 循环顺序, 可选值: &#x27;list&#x27;, &#x27;random&#x27;\tvolume: 0.7,\t\t// 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效\tmutex: true,\t\t// 阻止多个播放器同时播放\tlistFolded: false,\t// 是否列表 默认折叠\tlistMaxHeight: 90,\t// 列表最大高度\tlrcType: 1,\taudio: [\t\t&#123;\t\t\tname: &quot;清新的小女孩 (For Ma)&quot;, \t\t//名称\t\t\tartist: &#x27;July Tun&#x27;,\t\t\t// 艺术家 \t\t\turl: &#x27;http://antiserver.kuwo.cn/anti.s?useless=/resource/&amp;format=mp3&amp;rid=MUSIC_72891154&amp;response=res&amp;type=convert_url&amp;&#x27;,\t\t\t\t//链接 \t\t\tcover: &#x27;http://imge.kugou.com/stdmusic/150/20200114/20200114142306429193.jpg&#x27;,\t//封面\t\t\tlrc: &#x27;[00:1.21]清新的小女孩 - ไทย[00:14.88]႐ိုး႐ိုးေလးနဲ႔ လွေနတယ္ မရယ္[00:20.31]清新脱俗的女孩[00:20.31]ဆန္း၂ျပား၂မ၀တ္ပါနဲ႔လားကြယ္[00:28.58]你不需要刻意打扮穿着[00:28.58]ကမ႓ာေက်ာ္တဲ့ မင္းသမီးေတာင္[00:33.54]你的美貌[00:33.54]ေငးေမာေလာက္တယ္ မရဲ႕ အလွေတြရယ္[00:40.37]哪怕国际女星都会仰慕[00:40.37]မိုးျမင့္ထက္က ေငြၾကယ္ကေလးလိုပဲ[00:43.95]你清澈的眼眸[00:43.95]ေတာက္ပလြန္းတဲ့ ဒီမ်က္လံုးေတြနဲ႔[00:47.2]就像银河里的星星[00:47.2]ဖမ္းစားညိႇဳ႕တက္တယ္ ေမ့လို႔မရႏိုင္[00:51.57]你如此迷人，让人难以忘怀[00:51.57]မရဲ႕အၿပံဳးေတြထဲ[00:53.16]你的笑容里[00:53.16]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[00:57.03]有种不同寻常的美[00:57.03]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[01:00.03]一定是你前世修来的[01:00.03]႐ူးခဲ့ရသူ ရင္ထဲလည္း[01:05.38]内心疯狂的想念你[01:05.38]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[01:12.25]每分每秒都在想你[01:12.25]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[01:38.68]你就像校园里的女神一样[01:38.68]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[01:45.07]你是世上最美的女孩[01:45.07]အရမ္းလွတဲ့သူ မ ရယ္[01:49.1]美丽的女孩[01:49.1]ခ်စ္ပါရေစေတာ့ကြယ္[01:55.52]让我爱上你吧[01:55.52]မရဲ႕အခ်စ္နဲ႔ျပည့္စံုၿပီေပါ့ တကယ္[01:63.48]有你的微笑我就心满意足了[01:63.48]ေက်းဇူးျပဳ၍ မမုန္းပါနဲ႔လားကြယ္[01:68.97]只求你不要讨厌我[01:68.97]ဒီကမ႓ာမွာ မတစ္ေယာက္သာ ေတာင္းတမိတယ္[01:75.42]在这世界上，只为你一个人着迷[01:75.42]က်ေနာ့္ရဲ႕ အခ်စ္အိမ္ထဲ[01:82.08]在我的心里[01:82.08]ေမ့လို႔မရတဲ့ အိပ္မက္ထဲမွာပဲ[01:86.63]即使在梦里也忘不了你[01:86.63]စိုးမိုးထားခဲ့ ဒီအၾကည့္ေတြနဲ႔[01:91.75]你看我的样子[01:91.75]႐ူးသြပ္ခဲ့ရတယ္[01:92.52]让我痴迷[01:92.52]မရဲ႕အလွမွာ ႐ုန္းလို႔မထြက္ႏိုင္ခဲ့[01:98.42]沉醉于你的美貌无法自拔[01:98.42]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[02:04.72]有种不同寻常的美[02:04.72]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[02:07.07]一定是你前世修来的[02:07.07]႐ူးခဲ့ရသူ ရင္ထဲလည္း[02:08.95]内心疯狂的想念你[02:08.95]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[02:14.5]每分每秒都在想你[02:14.5]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[02:2.]你就像校园里的女神一样[02:2.]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[02:22.47]你是世上最美的女孩[02:22.47]အရမ္းလွတဲ့သူ မ ရယ္[02:26.42]美丽的女孩[02:26.42]ခ်စ္ပါရေစေတာ့ကြယ္[02:27.35]让我爱上你吧[02:27.35]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[02:53.62]有种不同寻常的美[02:53.62]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[02:59.63]一定是你前世修来的[02:59.63]႐ူးခဲ့ရသူ ရင္ထဲလည္း[02:60.62]内心疯狂的想念你[02:60.62]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[02:66.42]每分每秒都在想你[02:66.42]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[02:69.92]你就像校园里的女神一样[02:69.92]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[02:76.1]你是世上最美的女孩[02:76.1]အရမ္းလွတဲ့သူ မ ရယ္[02:77.75]美丽的女孩[02:77.75]ခ်စ္ပါရေစေတာ့ကြယ္[02:80.02]让我爱上你吧[02:80.02]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[02:85.43]有种不同寻常的美[02:85.43]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[02:88.47]一定是你前世修来的[02:88.47]႐ူးခဲ့ရသူ ရင္ထဲလည္း[03:00.55]内心疯狂的想念你[03:00.55]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[03:25.13]每分每秒都在想你[03:25.13]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[03:40.78]你就像校园里的女神一样[03:40.78]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[03:66.85]你是世上最美的女孩[03:66.85]အရမ္းလွတဲ့သူ မ ရယ္[03:72.58]美丽的女孩[03:72.58]ခ်စ္ပါရေစေတာ့ကြယ္[03:78.85]让我爱上你吧[03:78.85]ေက်းဇူးျပဳ၍ မရက္စက္လိုက္ပါနဲ႔[03:84.72]请不要拒绝我&#x27;,\t\t\t//theme: &#x27;#b7daff&#x27;, \t\t\t//音频时的主题色\t\t&#125;\t]&#125;);\r\n\r\n更多参见Aplayer\r\n官网\r\n\r\n三、 添加到侧边栏\r\n将外链插入到Hexo根路径的侧边栏文件中：\r\nthemes/next/layout/_macro/sidebar.swig ，即侧边栏友情链接\r\ntheme.links 这一项之后。\r\n\r\n后更换到 themes/next/layout/_layout.swig\r\n\r\n&#123;% if theme.links %&#125;\t....省略部分代码&#123;% endif %&#125;&lt;!-- 音乐 插件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt;&lt;!-- 音乐 插件 --&gt;\r\n四、 修改搜索器\r\n有了音乐搜索器\r\n当然要稍稍修改下，使其用起来更便利些。\r\n由于是PHP代码，自然不能在静态博客上使用，所以~~（爱怎么搭怎么搭吧）\r\n\r\n\r\n修改 template.php文件，找到id为 j-main的form\r\n【此处折叠】\r\n\r\n&lt;form id=&quot;j-main&quot; class=&quot;am-form am-u-md-12 am-u-sm-centered music-main&quot;&gt;\t&lt;a type=&quot;button&quot; id=&quot;j-back&quot; class=&quot;am-btn am-btn-success am-btn-lg am-btn-block am-radius am-margin-bottom-lg&quot;&gt;成功 Get &amp;#x221A; 返回继续 &lt;i class=&quot;am-icon-reply am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/a&gt;\t&lt;div class=&quot;am-g am-margin-bottom-sm&quot;&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐ID&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-list-ol am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-songid&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐地址&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-link am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-link&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t\t&lt;span class=&quot;am-input-group-btn&quot;&gt;\t\t\t\t\t&lt;a id=&quot;j-link-btn&quot; class=&quot;am-btn am-btn-default&quot; target=&quot;_blank&quot;&gt;\t\t\t\t\t\t&lt;i class=&quot;am-icon-external-link&quot;&gt;&lt;/i&gt;\t\t\t\t\t&lt;/a&gt;\t\t\t\t&lt;/span&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐链接&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-music am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-src&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t\t&lt;span class=&quot;am-input-group-btn&quot;&gt;\t\t\t\t\t&lt;a id=&quot;j-src-btn&quot; class=&quot;am-btn am-btn-default&quot; target=&quot;_blank&quot;&gt;\t\t\t\t\t\t&lt;i id=&quot;j-src-btn-icon&quot; class=&quot;am-icon-external-link&quot;&gt;&lt;/i&gt;\t\t\t\t\t&lt;/a&gt;\t\t\t\t&lt;/span&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐歌词&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-file-text-o am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-lrc&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t\t&lt;span class=&quot;am-input-group-btn&quot;&gt;\t\t\t\t\t&lt;a id=&quot;j-lrc-btn&quot; class=&quot;am-btn am-btn-default&quot; target=&quot;_blank&quot;&gt;\t\t\t\t\t\t&lt;i id=&quot;j-lrc-btn-icon&quot; class=&quot;am-icon-external-link&quot;&gt;&lt;/i&gt;\t\t\t\t\t&lt;/a&gt;\t\t\t\t&lt;/span&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div class=&quot;am-g&quot;&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐名称&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-tag am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-name&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐作者&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-user am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-author&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐图片&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-tag am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-pic&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;am-u-lg-3&quot;&gt;\t\t\t&lt;div class=&quot;am-input-group am-input-group-sm am-margin-bottom-sm&quot; data-am-popover=&quot;&#123;content: &#x27;音乐源&#x27;, trigger: &#x27;hover&#x27;&#125;&quot;&gt;\t\t\t\t&lt;span class=&quot;am-input-group-label&quot;&gt;&lt;i class=&quot;am-icon-user am-icon-fw&quot;&gt;&lt;/i&gt;&lt;/span&gt;\t\t\t\t&lt;input id=&quot;j-from&quot; class=&quot;am-form-field&quot; readonly&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div class=&quot;am-g&quot;&gt;\t\t&lt;div class=&quot;am-u-lg-12&quot;&gt;\t\t\t&lt;section data-am-widget=&quot;accordion&quot; class=&quot;am-accordion am-accordion-gapped&quot; data-am-accordion=&#x27;&#123;  &#125;&#x27;&gt;\t\t\t  &lt;dl class=&quot;am-accordion-item am-active&quot;&gt;\t\t\t\t&lt;dt class=&quot;am-accordion-title&quot;&gt;\t\t\t\t  Aplayer ：\t\t\t\t&lt;/dt&gt;\t\t\t\t&lt;dd class=&quot;am-accordion-bd am-collapse am-in&quot;&gt;\t\t\t\t  &lt;!-- 规避 Collapase 处理有 padding 的折叠内容计算计算有误问题， 加一个容器 --&gt;\t\t\t\t  &lt;div class=&quot;am-accordion-content&quot;&gt;\t\t\t\t\t\t&lt;textarea class=&quot;&quot; rows=&quot;5&quot; id=&quot;doc-ta-1&quot;&gt;&lt;/textarea&gt;\t\t\t\t  &lt;/div&gt;\t\t\t\t&lt;/dd&gt;\t\t\t  &lt;/dl&gt;\t\t\t&lt;/section&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div id=&quot;j-show&quot; class=&quot;am-margin-vertical&quot;&gt;\t\t&lt;div id=&quot;j-player&quot; class=&quot;aplayer&quot;&gt;&lt;/div&gt;\t&lt;/div&gt;&lt;/form&gt;\r\n\r\n\r\n\r\n修改\r\nstatic.js文件，找到定义setValue函数的位置，在代码块中追加\r\n【此处折叠】\r\n\r\n$(&#x27;#j-pic&#x27;).val(data.pic);$(&#x27;#j-from&#x27;).val(data.type);$(&#x27;#doc-ta-1&#x27;).val(\t&#x27;name: &quot;&#x27;+ data.title +&#x27;&quot;,\\n&#x27;+\t&#x27;artist: &quot;&#x27;+ data.author +&#x27;&quot;,\\n&#x27;+\t&#x27;url: &quot;&#x27;+ data.url +&#x27;&quot;,\\n&#x27;+\t&#x27;cover: &quot;&#x27;+ data.pic +&#x27;&quot;,\\n&#x27;+\t&#x27;lrc: &quot;&#x27;+ data.lrc.replace(/\\n|\\r/g,&quot;&quot;) +&#x27;&quot;,\\n&#x27;);\r\n\r\n五、 参考\r\nGitHub-aplayer\r\n简书 -\r\nHexo添加Aplayer播放器 简书 -\r\nHexo增加APlayer音乐播放功能 简书 -\r\nHexo博客中插入音乐/视频/\r\n","categories":["未分类"],"tags":["Hexo","Aplayer"]},{"title":"[转载]排序算法","url":"/20190324/%E8%BD%AC%E8%BD%BD-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"一、概述\r\n1. 常见的排序算法：\r\n冒泡排序、快速排序、简单插入排序、希尔排序、简单选择排序、堆排序、二路归并排序、多路归并排序、计数排序、桶排序、基数排序等\r\n\r\n 常用算法\r\n2. 算法复杂度：\r\n\r\n\r\n算法复杂度\r\n\r\n3. 相关概念：\r\n\r\n稳定：两个相等的数，排序后顺序不变\r\n不稳定：两个相等的数，排序后顺序可能会变\r\n时间复杂度：对排序数据的总的操作次数\r\n空间复杂度：指计算机内执行时所需存储空间的度量\r\n\r\n二、排序算法\r\n1、冒泡排序\r\n冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\r\n1.1 算法描述\r\n\r\n比较相邻的元素。如果第一个比第二个大，就交换它们两个；\r\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\r\n针对所有的元素重复以上的步骤，除了最后一个；\r\n重复步骤1~3，直到排序完成。\r\n\r\n1.2 动图演示\r\n\r\n1.3 代码实现\r\nfunction bubbleSort(arr) &#123;    var len = arr.length;    for (var i = 0; i &lt; len - 1; i++) &#123;        for (var j = 0; j &lt; len - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比                var temp = arr[j+1];        // 元素交换                arr[j+1] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    return arr;&#125;\r\n2、快速排序\r\n快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\r\n2.1 算法描述\r\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\r\n+ 从数列中挑出一个元素，称为 “基准”（pivot）； +\r\n重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\r\n+\r\n递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\r\n2.2 动图演示\r\n\r\n2.3 代码实现\r\nfunction quickSort(arr, left, right) &#123;    var len = arr.length,        partitionIndex,        left = typeof left != &#x27;number&#x27; ? 0 : left,        right = typeof right != &#x27;number&#x27; ? len - 1 : right;     if (left &lt; right) &#123;        partitionIndex = partition(arr, left, right);        quickSort(arr, left, partitionIndex-1);        quickSort(arr, partitionIndex+1, right);    &#125;    return arr;&#125; function partition(arr, left ,right) &#123;     // 分区操作    var pivot = left,                      // 设定基准值（pivot）        index = pivot + 1;    for (var i = index; i &lt;= right; i++) &#123;        if (arr[i] &lt; arr[pivot]) &#123;            swap(arr, i, index);            index++;        &#125;           &#125;    swap(arr, pivot, index - 1);    return index-1;&#125; function swap(arr, i, j) &#123;    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;\r\n3、插入排序\r\n插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\r\n3.1 算法描述\r\n一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\r\n\r\n从第一个元素开始，该元素可以认为已经被排序；\r\n取出下一个元素，在已经排序的元素序列中从后向前扫描；\r\n如果该元素（已排序）大于新元素，将该元素移到下一位置；\r\n重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\r\n将新元素插入到该位置后；\r\n重复步骤2~5。\r\n\r\n3.2 动图演示\r\n\r\n3.3 代码实现\r\nfunction insertionSort(arr) &#123;    var len = arr.length;    var preIndex, current;    for (var i = 1; i &lt; len; i++) &#123;        preIndex = i - 1;        current = arr[i];        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;            arr[preIndex + 1] = arr[preIndex];            preIndex--;        &#125;        arr[preIndex + 1] = current;    &#125;    return arr;&#125;\r\n2.4 算法分析\r\n插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\r\n4、希尔排序\r\n1959年Shell发明，第一个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\r\n4.1 算法描述\r\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\r\n+ 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； +\r\n按增量序列个数k，对序列进行k 趟排序； +\r\n每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m\r\n的子序列，分别对各子表进行直接插入排序。仅增量因子为1\r\n时，整个序列作为一个表来处理，表长度即为整个序列的长度。\r\n代码实现\r\n// 修改于 2019-03-06function shellSort(arr) &#123;    var len = arr.length;    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行        for (var i = gap; i &lt; len; i++) &#123;            var j = i;            var current = arr[i];            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;                 arr[j] = arr[j - gap];                 j = j - gap;            &#125;            arr[j] = current;        &#125;    &#125;    return arr;&#125;\r\n5、选择排序\r\n选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\r\n5.1 算法描述\r\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\r\n+ 初始状态：无序区为R[1..n]，有序区为空； +\r\n第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录\r\nR[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\r\n+ n-1趟结束，数组有序化了。\r\n5.2 动图演示\r\n\r\n5.3 代码实现\r\nfunction selectionSort(arr) &#123;    var len = arr.length;    var minIndex, temp;    for (var i = 0; i &lt; len - 1; i++) &#123;        minIndex = i;        for (var j = i + 1; j &lt; len; j++) &#123;            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数                minIndex = j;                 // 将最小数的索引保存            &#125;        &#125;        temp = arr[i];        arr[i] = arr[minIndex];        arr[minIndex] = temp;    &#125;    return arr;&#125; \r\n5.4 算法分析\r\n表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。\r\n6、堆排序\r\n堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\r\n6.1 算法描述\r\n\r\n将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\r\n将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；\r\n由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\r\n\r\n6.2 动图演示\r\n\r\n6.3 代码实现\r\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) &#123;   // 建立大顶堆    len = arr.length;    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;        heapify(arr, i);    &#125;&#125; function heapify(arr, i) &#123;     // 堆调整    var left = 2 * i + 1,        right = 2 * i + 2,        largest = i;     if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;        largest = left;    &#125;     if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;        largest = right;    &#125;     if (largest != i) &#123;        swap(arr, i, largest);        heapify(arr, largest);    &#125;&#125; function swap(arr, i, j) &#123;    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125; function heapSort(arr) &#123;    buildMaxHeap(arr);     for (var i = arr.length - 1; i &gt; 0; i--) &#123;        swap(arr, 0, i);        len--;        heapify(arr, 0);    &#125;    return arr;&#125;\r\n7、归并排序\r\n归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide\r\nand\r\nConquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\r\n7.1 算法描述\r\n\r\n把长度为n的输入序列分成两个长度为n/2的子序列；\r\n对这两个子序列分别采用归并排序；\r\n将两个排序好的子序列合并成一个最终的排序序列。\r\n\r\n7.2 动图演示\r\n\r\n7.3 代码实现\r\nfunction mergeSort(arr) &#123;    var len = arr.length;    if (len &lt; 2) &#123;        return arr;    &#125;    var middle = Math.floor(len / 2),        left = arr.slice(0, middle),        right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));&#125; function merge(left, right) &#123;    var result = [];     while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;        if (left[0] &lt;= right[0]) &#123;            result.push(left.shift());        &#125; else &#123;            result.push(right.shift());        &#125;    &#125;     while (left.length)        result.push(left.shift());     while (right.length)        result.push(right.shift());     return result;&#125;\r\n7.4 算法分析\r\n归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。\r\n8、计数排序\r\n计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。\r\n作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\r\n8.1 算法描述\r\n\r\n找出待排序的数组中最大和最小的元素；\r\n统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\r\n对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\r\n反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\r\n\r\n8.2 动图演示\r\n\r\n8.3 代码实现\r\nfunction countingSort(arr, maxValue) &#123;    var bucket = new Array(maxValue + 1),        sortedIndex = 0;        arrLen = arr.length,        bucketLen = maxValue + 1;     for (var i = 0; i &lt; arrLen; i++) &#123;        if (!bucket[arr[i]]) &#123;            bucket[arr[i]] = 0;        &#125;        bucket[arr[i]]++;    &#125;     for (var j = 0; j &lt; bucketLen; j++) &#123;        while(bucket[j] &gt; 0) &#123;            arr[sortedIndex++] = j;            bucket[j]--;        &#125;    &#125;     return arr;&#125;\r\n8.4 算法分析\r\n计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k\r\n之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。\r\n9、桶排序\r\n桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序\r\n(Bucket\r\nsort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。\r\n9.1 算法描述\r\n\r\n设置一个定量的数组当作空桶；\r\n遍历输入数据，并且把数据一个一个放到对应的桶里去；\r\n对每个不是空的桶进行排序；\r\n从不是空的桶里把排好序的数据拼接起来。\r\n\r\n9.2 动图演示\r\n\r\n9.3 代码实现\r\nfunction bucketSort(arr, bucketSize) &#123;    if (arr.length === 0) &#123;      return arr;    &#125;     var i;    var minValue = arr[0];    var maxValue = arr[0];    for (i = 1; i &lt; arr.length; i++) &#123;      if (arr[i] &lt; minValue) &#123;          minValue = arr[i];                // 输入数据的最小值      &#125; else if (arr[i] &gt; maxValue) &#123;          maxValue = arr[i];                // 输入数据的最大值      &#125;    &#125;     // 桶的初始化    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;      var buckets = new Array(bucketCount);    for (i = 0; i &lt; buckets.length; i++) &#123;        buckets[i] = [];    &#125;     // 利用映射函数将数据分配到各个桶中    for (i = 0; i &lt; arr.length; i++) &#123;        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);    &#125;     arr.length = 0;    for (i = 0; i &lt; buckets.length; i++) &#123;        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序        for (var j = 0; j &lt; buckets[i].length; j++) &#123;            arr.push(buckets[i][j]);                             &#125;    &#125;     return arr;&#125;\r\n9.4 算法分析\r\n桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\r\n10、基数排序\r\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\r\n10.1 算法描述\r\n\r\n取得数组中的最大数，并取得位数；\r\narr为原始数组，从最低位开始取每个位组成radix数组；\r\n对radix进行计数排序（利用计数排序适用于小范围数的特点）；\r\n\r\n10.2 动图演示\r\n\r\n10.3 代码实现\r\nvar counter = [];function radixSort(arr, maxDigit) &#123;    var mod = 10;    var dev = 1;    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;        for(var j = 0; j &lt; arr.length; j++) &#123;            var bucket = parseInt((arr[j] % mod) / dev);            if(counter[bucket]==null) &#123;                counter[bucket] = [];            &#125;            counter[bucket].push(arr[j]);        &#125;        var pos = 0;        for(var j = 0; j &lt; counter.length; j++) &#123;            var value = null;            if(counter[j]!=null) &#123;                while ((value = counter[j].shift()) != null) &#123;                      arr[pos++] = value;                &#125;          &#125;        &#125;    &#125;    return arr;&#125;\r\n10.4 算法分析\r\n基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n)\r\n，当然d要远远小于n，因此基本上还是线性级别的。\r\n基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。\r\n","categories":["未分类"],"tags":["算法"]},{"title":"Hexo-博客备份-2","url":"/20200402/hexo-%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD-2/","content":"一、 安装hexo-git-backup插件\r\n1. 安装\r\n版本是2.x.x使用这条命令：\r\nnpm install hexo-git-backup@0.0.91 --save\r\n版本是3.x.x 或3+则使用这条命令：\r\nnpm install hexo-git-backup --save\r\n\r\n2. 更新\r\n如果使用–save进行安装，则必须在更新时先将其删除。\r\nnpm remove hexo-git-backupnpm install hexo-git-backup --save\r\n3. 配置\r\n修改_config.yml文件: backup:    type: git    repository:       github: git@github.com:xxx/xxx.git,branchName       gitcafe: git@github.com:xxx/xxx.git,branchName\r\n4. 备份到云端\r\nhexo b\r\n\r\n更多参见npmjs或GitHub\r\n\r\n二、 以命令备份\r\n1. 需要备份的文件\r\n\r\n./source资源文件夹，这里面包含了你写的文章的 markdown\r\n源码，这个是最重要的。\r\n./themes主题文件夹，\r\n./scaffolds模板文件夹，这个文件夹里是创建文章时的模板。\r\n配置文件，根目录下的几个配置文件，主要是 _config.yml、\r\npackage.json、 .gitignore。\r\n\r\n2. 创建分支\r\n例如：在此创建了两个分支：master 与\r\nbackup\r\n\r\nmaster 分支用来存放生成的静态网页\r\nbackup 分支用来存放网站的原始文件\r\n\r\n在本地设置backup为默认分支，而_config.yml中的deploy参数，\r\n分支应为master；\r\n依次执行\r\ngit add . git commit -m &#x27;...&#x27;git push –set-upstream origin backup\r\n–set-upstream是将本地分支关联到远程backup分支，\r\n\r\n提交原始文件到backup分支，\r\n","categories":["未分类"],"tags":["Hexo"]},{"title":"Git笔记","url":"/20200408/git%E7%AC%94%E8%AE%B0/","content":"Git 命令操作笔记\r\n安装\r\n下载Git - git 官网. - 淘宝镜像 Git for\r\nWindows  安装步骤略\r\n配置\r\n对你的commit操作设置关联的用户名 git config --global user.name &quot;Your Name&quot;\r\n对你的commit操作设置关联的邮箱地址 git config --global user.email &quot;email@example.com&quot; 查看您的配置\r\ngit config --list 启用有帮助的彩色命令行输出 git config --global color.ui auto\r\n创建仓库\r\n创建一个新的本地仓库 git init 将本地仓库与一个 GitHub\r\n上的空仓库连接起来 git remote add origin [url] Clone（下载）一个已存在于 GitHub\r\n上的仓库，包括所有的文件、分支和提交(commits) git clone [url]\r\n.gitignore 文件\r\n有时一些文件最好不要用 Git 跟踪。这通常在名为 .gitignore\r\n的特殊文件中完成。你可以在 github.com/github/gitignore\r\n找到有用的 .gitignore 文件模板。 本博客的 .gitignore 文件.deploy_git/.deploy_heroku/node_modules/public/db.json.DS_StoreThumbs.db*.log*.~\r\n进行更改\r\n浏览并检查项目文件的发展 # 时刻掌握暂存区状态。# 参数 -s/--short 使其更加简洁：?? 未跟踪 A 新文件已暂存 M 文件修改过# 输出有两栏，左栏是暂存区，右栏是工作区git status 列出当前分支的版本历史\r\ngit log 列出文件的版本历史，包括重命名 git log --follow [file]\r\n展示两个分支之间的内容差异 git diff [first-branch]...[second-branch]\r\n将文件进行快照处理用于版本控制（暂存） git add [file]# 提交所有变化到暂存区（跟踪/暂存）git add -A# 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)git add -u# 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件git add .\r\n将文件快照永久地记录在版本历史中（提交） git commit -m &quot;[descriptive message]&quot;\r\n重做提交（不推荐）\r\n清除错误和构建用于替换的历史 撤销所有 [commit]\r\n后的的提交，在本地保存更改 git reset [commit] 放弃所有历史，改回指定提交。\r\ngit reset --hard [commit]\r\n分支\r\n创建一个新分支 git branch [branch-name] 切换到指定分支并更新工作目录(working\r\ndirectory) git checkout [branch-name]\r\n将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的\r\nGit 操作。 git merge [branch] 删除指定分支 git branch -d [branch-name]\r\n同步更改\r\n下载远端跟踪分支的所有历史（获取） git fetch\r\n将远端跟踪分支合并到当前本地分支 git merge 将所有本地分支提交上传到\r\nGitHub git push 使用来自 GitHub\r\n的对应远端分支的所有新提交更新你当前的本地工作分支。（拉取）\r\ngit pull 是 git fetch 和\r\ngit merge 的结合 git pull\r\n参考文章\r\n\r\n廖雪峰的官方网站\r\nGit Book\r\nGit Reference\r\n初次运行\r\nGit 前的配置\r\nGit\r\n备忘单\r\n\r\n","categories":["未分类"],"tags":["Git"]},{"title":"Pip源切换","url":"/20200521/pip%E6%BA%90%E5%88%87%E6%8D%A2/","content":"pip默认的源服务器在国外，安装速度较慢，推荐使用国内的源。\r\n\r\n源列表\r\n\r\n豆瓣：http://pypi.douban.com/simple/\r\n中科大：https://pypi.mirrors.ustc.edu.cn/simple/\r\n清华：https://pypi.tuna.tsinghua.edu.cn/simple/\r\n\r\n一次性使用\r\n可以在使用pip的时候加参数-i\r\nhttps://pypi.tuna.tsinghua.edu.cn/simple\r\n例如：\r\npip install django-simpleui -i https://pypi.tuna.tsinghua.edu.cn/simple\r\n永久修改\r\nLinux & MacOSWindowslinux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改\r\nindex-url 为国内镜像地址，内容如下：\r\n/.pip/pip.conf[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simplewindows下，直接在user目录中创建一个pip目录，如：C:，新建文件pip.ini，内容如下\r\npip.ini[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple\r\n","categories":["未分类"],"tags":["Python"]},{"title":"CSS字体样式","url":"/20200402/css%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/","content":"收藏了几个CSS字体样式\r\n打开Web 编辑器进行调试\r\n一. CSS字体颜色渐变\r\n\r\n示例: CSS字体颜色渐变,注意调整width\r\n\r\n\r\n.myStyle{\r\n    background-image: linear-gradient(to right, red, orange, yellow, green, yellow, orange, red, orange, yellow, green, yellow, orange, red);\r\n    -webkit-background-clip: text;\r\n    animation: move 5s infinite;\r\n    color: transparent;\r\n    width: 330px;\r\n}\r\n@keyframes move{\r\n  0%{\r\n    background-position: 0 0;\r\n  }\r\n  100% {\r\n      background-position: -330px 0;\r\n  }\r\n}\r\n\r\n\r\nCSS字体颜色渐变&lt;p class=&quot;myStyle&quot;&gt; 示例: CSS字体颜色渐变,注意调整width &lt;/p&gt;&lt;style&gt;.myStyle&#123;\tbackground-image: linear-gradient(to right, red, orange, yellow, green, yellow, orange, red, orange, yellow, green, yellow, orange, red);    -webkit-background-clip: text;    animation: move 5s infinite;    color: transparent;    width: 330px;&#125;@keyframes move&#123;  0%&#123;    background-position: 0 0;  &#125;  100% &#123;      background-position: -330px 0;  &#125;&#125;&lt;/style&gt;\r\n\r\n二. CSS 文字动画\r\n\r\n一段文字\r\n一段文字\r\n一段文字\r\n一段文字\r\n\r\n\r\n.text {\r\n    font-size: 44px;\r\n    font-weight: bold;\r\n    text-transform: uppercase;\r\n    fill: none;\r\n    stroke-width: 2px;\r\n    stroke-dasharray: 90 310;\r\n    animation: stroke 6s infinite linear;\r\n    background:#000;\r\n}\r\n.text-1 {\r\n    stroke: #3498db;\r\n    text-shadow: 0 0 5px #3498db;\r\n    animation-delay: -1.5s;\r\n}\r\n.text-2 {\r\n    stroke: #f39c12;\r\n    text-shadow: 0 0 5px #f39c12;\r\n    animation-delay: -3s;\r\n}\r\n.text-3 {\r\n    stroke: #e74c3c;\r\n    text-shadow: 0 0 5px #e74c3c;\r\n    animation-delay: -4.5s;\r\n}\r\n.text-4 {\r\n    stroke: #9b59b6;\r\n    text-shadow: 0 0 5px #9b59b6;\r\n    animation-delay: -6s;\r\n}\r\n@keyframes stroke {\r\n    100% {\r\n        stroke-dashoffset: -400;\r\n    }\r\n}\r\n\r\nCSS 文字动画&lt;svg width=&quot;100%&quot; height=&quot;80&quot;&gt;&lt;text text-anchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;70%&quot; class=&quot;text text-1&quot;&gt;一段文字&lt;/text&gt;&lt;text text-anchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;70%&quot; class=&quot;text text-2&quot;&gt;一段文字&lt;/text&gt;&lt;text text-anchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;70%&quot; class=&quot;text text-3&quot;&gt;一段文字&lt;/text&gt;&lt;text text-anchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;70%&quot; class=&quot;text text-4&quot;&gt;一段文字&lt;/text&gt;&lt;/svg&gt;&lt;style&gt;.text &#123;\tfont-size: 44px;\tfont-weight: bold;\ttext-transform: uppercase;\tfill: none;\tstroke-width: 2px;\tstroke-dasharray: 90 310;\tanimation: stroke 6s infinite linear;\tbackground:#000;&#125;.text-1 &#123;\tstroke: #3498db;\ttext-shadow: 0 0 5px #3498db;\tanimation-delay: -1.5s;&#125;.text-2 &#123;\tstroke: #f39c12;\ttext-shadow: 0 0 5px #f39c12;\tanimation-delay: -3s;&#125;.text-3 &#123;\tstroke: #e74c3c;\ttext-shadow: 0 0 5px #e74c3c;\tanimation-delay: -4.5s;&#125;.text-4 &#123;\tstroke: #9b59b6;\ttext-shadow: 0 0 5px #9b59b6;\tanimation-delay: -6s;&#125;@keyframes stroke &#123;\t100% &#123;\t\tstroke-dashoffset: -400;\t&#125;&#125;&lt;/style&gt;\r\n\r\n","categories":["编程语言"],"tags":["CSS"]},{"title":"六大设计原则","url":"/20200518/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"设计模式的六大原则有：\r\n\r\nSingle Responsibility Principle：单一职责原则\r\nOpen Closed Principle：开闭原则\r\nLiskov Substitution Principle：里氏替换原则\r\nLaw of Demeter：迪米特法则\r\nInterface Segregation Principle：接口隔离原则\r\nDependence Inversion Principle：依赖倒置原则\r\n\r\n\r\n把这六个原则的首字母联合起来（两个 L 算做一个）就是 SOLID\r\n（solid，稳定的），其代表的含义就是这六个原则结合使用的好处：建立稳定、灵活、健壮的设计。\r\n参考资料：\r\n\r\n书籍《设计模式之禅》\r\n简书-六大设计原则(SOLID)\r\n简书-六大设计原则之依赖倒置原则（DIP）\r\n本文是整理这篇文章及其内链\r\nCSDN-设计模式六大原则——SOLID\r\n\r\n一、 单一职责原则\r\nThere should never be more than one reason for a class to change.\r\n一个类应该只有一个发生变化的原因\r\n\r\n1. 概念\r\n单一职责原则（Single Responsibility Principle, SRP\r\n），就是一个类只负责一个职责，降低类的复杂度，维护起来更加容易。\r\n这个原则不仅仅局限于类，对于接口和方法也同样适用。通常，接口和方法的单一职责更容易实现。\r\n2. 特点\r\n\r\n代码的粒度降低了，类的复杂度降低了。\r\n可读性提高了，每个类的职责都很明确，可读性自然更好。\r\n可维护性提高了，可读性提高了，一旦出现 bug\r\n，自然更容易找到他问题所在。\r\n改动代码所消耗的资源降低了，更改的风险也降低了。\r\n\r\n二、 开闭原则\r\nSoftware entities like classes, modules and functions should be open\r\nfor extension but closed for modification\r\n一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭\r\n\r\n1. 概念\r\n开闭原则（Open Closed Principle,\r\nOCP）旨在如何建立稳定灵活的系统，只定义了对修改关闭，对扩展开放。\r\n对软件原有代码进行修改，可能会给旧代码引入错误，也有可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现。\r\n2. 优点\r\n用抽象构建架构，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保证架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了，当然前提是抽象要合理，要对需求的变更有前瞻性和预见性。\r\n三、 里氏替换原则\r\n所有引用基类的地方必须能透明地使用其子类的对象\r\nFunctions that use use pointers or references to base classes must be\r\nable to use objects of derived classes without knowing it.\r\n\r\n1. 概念\r\n里氏替换原则（Liskov Substitution Principle, LSP\r\n）是指所有基类在的地方，都可以换成子类，程序还可以正常运行。\r\n这个原则是与面向对象语言的继承特性密切相关，是为了弥补继承的缺陷。\r\n在学习java类的继承时，我们知道继承有一些优点：\r\n\r\n子类拥有父类的所有方法和属性，从而可以减少创建类的工作量。\r\n提高了代码的重用性。\r\n提高了代码的扩展性，子类不但拥有了父类的所有功能，还可以添加自己的功能。\r\n\r\n但有优点也同样存在缺点：\r\n\r\n继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。\r\n降低了代码的灵活性。因为继承时，父类会对子类有一种约束。\r\n增强了耦合性。当需要对父类的代码进行修改时，必须考虑到对子类产生的影响。\r\n\r\n\r\n2. 特点\r\n里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面：\r\n\r\n子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。\r\n子类中可以增加自己特有的方法。\r\n当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比-\r\n父类方法的输入参数更宽松。(即只能重载不能重写)\r\n当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。\r\n\r\n四、 迪米特法则\r\nTalk only to your immediate friends and not to strangers\r\n\r\n其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\r\n1. 概念\r\n迪米特法则（Law of Demeter,\r\nLOD）要求限制软件实体之间通信的宽度和深度。\r\n过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。它调以下两点：\r\n\r\n从依赖者的角度来说，只依赖应该依赖的对象。\r\n从被依赖者的角度说，只暴露应该暴露的方法。\r\n\r\n2. 优点\r\n正确使用迪米特法则将有以下两个优点。\r\n\r\n降低了类之间的耦合度，提高了模块的相对独立性。\r\n由于亲合度降低，从而提高了类的可复用率和系统的扩展性。\r\n\r\n五、 接口隔离原则\r\nClients should not be forced to depend upon interfaces that they\r\ndon`t use. The dependency of one class to another one should depend on\r\nthe smallest possible.\r\n\r\n注：该原则中的接口，是一个泛泛而言的接口，不仅仅指Java中的接口，还包括其中的抽象类。\r\n1. 概念\r\n接口隔离原则（Interface Segregation Principle, ISP）的定义：\r\n\r\n客户端不应该依赖它不需要的接口。\r\n类间的依赖关系应该建立在最小的接口上。\r\n\r\n2. 优点\r\n接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下\r\n5 个优点。\r\n\r\n将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\r\n接口隔离\r\n提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。\r\n如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。\r\n使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。\r\n在项目工程中减少代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。\r\n\r\n3. 实现方法\r\n在具体应用接口隔离原则时，应该根据以下几个规则来衡量。\r\n\r\n根据接口隔离原则拆分接口时，首先必须满足单一职责原则。\r\n接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。\r\n为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。\r\n了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。\r\n提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\r\n\r\n4.\r\n接口隔离原则和单一职责的区别\r\n接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：\r\n\r\n\r\n\r\n \r\n接口隔离原则\r\n单一职责\r\n\r\n\r\n\r\n\r\n注重\r\n职责\r\n对接口依赖的隔离\r\n\r\n\r\n主要\r\n约束类\r\n约束接口\r\n\r\n\r\n针对\r\n程序中的实现和细节\r\n抽象和程序整体框架的构建\r\n\r\n\r\n\r\n六、 依赖倒置原则\r\nHigh level modules should not depend upon low level modules. Both\r\nshould depend upon abstractions. Abstractions should not depend upon\r\ndetails. Details should depend upon abstractions.\r\n\r\n1. 概念\r\n依赖倒置原则（Dependence Inversion Principle）\r\n\r\n上层模块不应该依赖底层模块，它们都应该依赖于抽象。\r\n抽象不应该依赖于细节，细节应该依赖于抽象。\r\n\r\n","categories":["编程语言"],"tags":["Java"]},{"title":"使用Heroku遇到的问题","url":"/20200604/%E4%BD%BF%E7%94%A8heroku%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"使用Mezzanine做了一个博客，部署到heroku时遇到了一些问题，此篇以作记录。\r\n\r\n1.\r\n无法完成github项目的部署-H12错误\r\n\r\n项目根目录必须包含app.json、requirements.txt和Procfile，可选Procfile.windows和runtime.txt。\r\n\r\napp.json&#123;  &quot;name&quot;: &quot;name&quot;,  &quot;description&quot;: &quot;description&quot;,  &quot;image&quot;: &quot;heroku/python&quot;,  &quot;repository&quot;: &quot;https://github.com/YOURNAME/repository&quot;,  &quot;keywords&quot;: [&quot;python&quot;, &quot;django&quot;, &quot;Mezzanine&quot; ],  &quot;addons&quot;: [ &quot;heroku-postgresql&quot; ],  &quot;env&quot;: &#123;    &quot;SECRET_KEY&quot;: &#123;      &quot;description&quot;: &quot;The secret key for the Django application.&quot;,      &quot;generator&quot;: &quot;secret&quot;    &#125;  &#125;,  &quot;environments&quot;: &#123;    &quot;test&quot;: &#123;      &quot;scripts&quot;: &#123;        &quot;test-setup&quot;: &quot;python manage.py collectstatic --noinput&quot;,        &quot;test&quot;: &quot;python manage.py test&quot;      &#125;    &#125;  &#125;&#125;\r\nrequirements.txtMezzanine==4.3.1\r\nProcfileweb: python manage.py runserver 0.0.0.0:8000\r\nProcfile.windowsweb: python manage.py runserver 0.0.0.0:8000\r\nrequirements.txtpython-3.7.5\r\n\r\n2. Application error\r\n\r\nError R10 (Boot timeout) -&gt; Web process failed to bind to $PORT\r\nwithin 60 seconds of launch\r\n\r\n也许是数据库的问题？ heroku create [APP_NAME] # 创建APPgit push heroku master # 创建分支heroku run python manage.py migrate # 远端生成数据库heroku ps:scale web=1heroku open\r\n在requirement.txt文件中加入gunicorn，使用这个库开启Web服务，修改项目目录下的Procfile文件（mblog是我的项目里应用的名称，在该应用下应该存在wsgi.py文件）\r\nProcfileweb: gunicorn mblog.wsgi --log-file -\r\n\r\n3. no such table: django_site\r\n尝试生成远端数据库 heroku run python manage.py migrateheroku run python manage.py makemigrationsheroku run python manage.py createdb --noinputheroku run python manage.py syncdb #（在Django 1.9中已删除）\r\nsetting.py# heroku 只支持postgrespool数据库 来自：https://www.jianshu.com/p/610c670eabedimport dj_database_urlDATABASES[&#x27;default&#x27;] = dj_database_url.config()···import django_herokudjango_heroku.settings(locals())\r\n4.\r\n如果看到发现变量不对可以使用如下命令打印变量\r\nheroku run echo \\$JDBC_DATABASE_URL\r\n5.\r\n删除默认数据库，添加MySQL数据库\r\nheroku addons:destroy heroku-postgresqlheroku addons:create cleardb:igniteheroku config # 过程中可以使用 config 命令查看数据库 URL 是否修改成功\r\n6. postgresql 无法连接\r\n错误类似于 could not connect to postgres error: no pg_hba.conf entry for host &quot;1.198.47.212&quot;, user &quot;ijhjecdqztyvfo&quot;, database &quot;d66rrjcr414em1&quot;, SSL off\r\n解决方法取自于Connecting\r\nin Node.js\r\nconst &#123; Client &#125; = require(&#x27;pg&#x27;);const client = new Client(&#123;  connectionString: process.env.DATABASE_URL,  ssl: &#123;    rejectUnauthorized: false  &#125;&#125;);client.connect();client.query(&#x27;SELECT table_schema,table_name FROM information_schema.tables;&#x27;, (err, res) =&gt; &#123;  if (err) throw err;  for (let row of res.rows) &#123;    console.log(JSON.stringify(row));  &#125;  client.end();&#125;);\r\n如果指定PGSSLMODE配置变量，则可以省略ssl\r\n配置对象: heroku config:set PGSSLMODE=no-verify\r\n\r\nX. 可能会用到的命令\r\npython manage.py createsuperuser # 创建超级管理员，帐号登录 admin 后台# 将本地分支 master 提交到 heroku git add -ugit commit -m  &quot;commit&quot;git push heroku masterheroku run python manage.py collectstatic --noinput \r\n","categories":["未分类"],"tags":["Heroku"]},{"title":"基于Django开发的博客","url":"/20200603/%E5%9F%BA%E4%BA%8Edjango%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"\r\nDjango 是一个高级Python\r\nWeb框架，鼓励快速开发和干净，实用的设计。由经验丰富的开发人员构建，它解决了Web开发的大部分麻烦，因此您可以专注于编写应用程序而无需重新造轮子。它是免费的而且开源的框架。\r\n\r\n\r\n一、 开发环境\r\n\r\nVisual Studio\r\npython3\r\nDjango 2.2\r\n\r\n1. 安装 Visual Studio 环境\r\n如果使用 Windows，建议尝试使用Visual Studio\r\n做 Django 开发\r\n2. 安装 Python 环境\r\n具体安装请移步菜鸟教程,在此不做赘述。\r\n安装速度较慢，推荐使用国内的源，pip源切换。\r\n3. 安装 Python 虚拟环境\r\n编写新软件程序时，可能要修改其他软件所需的依赖或环境变量。为了避免这一步可能引起的问题，安装虚拟环境是必要的。虚拟环境把软件所需的全部依赖和环境变量包装到一个文件夹中，与电脑中的其他软件隔离开。\r\n\r\n安装virtualenv\r\n\r\npip install virtualenv\r\n\r\n创建一个虚拟环境[env_mysite]：\r\n\r\nvirtualenv [env_mysite]\r\n等virtualenv 设置好新的虚拟环境之后，会看到一个名为\r\n\\env_mysite\r\n的文件夹（或者为虚拟环境起的其他名称）。打开那个文件夹，会看到下述结构：\r\n* * * * \r\n\r\n\r\n要将其激活虚拟环境\r\n\r\nenv_mysite\\scripts\\activate\r\n这个命令会运行虚拟环境中 \\scripts 文件夹里的\r\nactivate 脚本。你会发现，现在命令提示符变了：\r\n(env_mysite) C:\\Users\\Admin&gt;  \r\n4). 其他命令\r\n命令提示符开头的 (env_mysite) 是告诉你，你正在那个虚拟环境中。\r\n\r\n查看当前环境中所有软件包： pip list\r\n停用当前虚拟环境： env_mysite\\scripts\\deactivate\r\n统计所有软件包： pip freeze &gt; freeze.txt\r\n安装所有必需的包： pip install -r freeze.txt\r\n\r\n\r\n4. 安装 Django\r\n1). 安装\r\n安装Djangos最新稳定版\r\npip install djangopip install django==2.2.12 # 明确了版本号\r\n2). 查看版本号\r\n查看Djangos版本号\r\n(env_mysite) C:\\Users\\Admin&gt; python -m django --version\r\n5. Django 后台建设\r\nSimple\r\nUI，一个基于Django\r\nAdmin的现代化主题，基于element-ui+vue开发，可以作为后台管理。快速入门。\r\n1). 安装\r\n建议在虚拟环境下安装\r\npip install django-simpleui\r\n2). 配置\r\n在自己项目的settings.py文件中INSTALLED_APPS的第一行加入simpleui\r\nsettings.py# Application definitionINSTALLED_APPS = [    &#x27;simpleui&#x27;,    &#x27;django.contrib.admin&#x27;,    &#x27;django.contrib.auth&#x27;,    &#x27;django.contrib.contenttypes&#x27;,    &#x27;django.contrib.sessions&#x27;,    &#x27;django.contrib.messages&#x27;,    &#x27;django.contrib.staticfiles&#x27;,    ...]\r\n3). 升级\r\npip install django-simpleui --upgrade\r\n4). 常见问题\r\n\r\n如果关闭debug模式后，请执行以下命令将simpleui静态文件静态文件克隆到根目录\r\n\r\npython3 manage.py collectstatic\r\n\r\n克隆静态文件出错 请在settings.py文件中加入：\r\n\r\nsettings.pySTATIC_ROOT = os.path.join(BASE_DIR, &quot;static&quot;)\r\n\r\n其他问题请参考django官方文档。\r\n\r\n参考文档：\r\n    Django\r\n文档   Django 教程\r\n  python3之Django基础篇\r\n  菜鸟教程\r\n  \r\n","categories":["编程语言"],"tags":["Python","Django"]},{"title":"Python依赖性管理工具概述[译]","url":"/20200602/python%E4%BE%9D%E8%B5%96%E6%80%A7%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0-%E8%AF%91/","content":"原文：python依赖性管理工具概述\r\n一直分不清管理依赖的工具之间的区别？Pip, venv, Docker, conda,\r\nvirtualenvwrapper, pipenv,\r\n…不知道用哪一个？为什么有这么多不同的工具？它们之间兼容吗？\r\n\r\nPython在依赖项管理这方面很糟糕，但是一旦你理解了这些工具及其存在的原因，就会更容易地选择你最想要的工具，即使您不能在其他环境中选择您最喜欢的，也可以选择最适合的。\r\n我将简要介绍每个工具，创建原因以及要解决的问题。在文章的最后，您可以找到一个表格，其中汇总了所有信息以及人们使用的常用设置。\r\n跳转： pip | venv | pyenv | conda | pipenv | poetry | Docker. 比较所有解决方案 | 常规设置\r\nPip\r\nPip（package installer for\r\npython，python的软件包安装程序）是python领域中最基本的软件包安装程序。\r\n大多数python安装程序中都预先安装了该软件，因此您可能不必自己安装它。\r\n安装软件包就像运行pip install torch一样简单。 该命令与PyPI（The Python\r\nPackage\r\nIndex，Python包索引）进行通信，下载并安装软件包，使它在当前的python环境下可用。\r\n这是一个非常原始的工具。它对不同的python版本或Jupyter内核一无所知。\r\n\r\nPip解决的问题： - 安装python包\r\nVenv\r\nvenv是用于创建轻量级虚拟环境的工具。\r\n最常见的用例是为每个应用程序创建环境。它可以确保应用程序之间不会共享软件包，也不会与系统的python安装共享软件包。每个环境都可以使用同一软件包的任何版本，并且它们不会冲突。\r\n\r\nvenv解决的问题： - 在应用之间隔离包\r\nvenv和pip如何交互？\r\n它们都是标准python工具的一部分，可以解决非常不同的问题，并且可以很好地协同工作。鼓励您使用pip在虚拟环境中安装软件包。\r\npyenv\r\nPython成为一种流行的语言，所有主要的操作系统都开始在它之上构建并将其捆绑在一起。这就是为什么您可以直接python在新安装的Linux或Mac\r\nOS上键入终端而无需自己安装终端的原因。\r\n但是用户应用程序也是用python构建的。而且他们通常需要不同版本的python！结合使用这两种方法，需要根据应用程序以某种方式运行不同版本的python。\r\n创建Pyenv是为了解决在同一台计算机上安装和切换不同版本的python的问题。\r\n这是开发人员机器上的便捷工具，因为它保留了python的系统版本（需要OS才能正常运行），但是可以为不同的应用程序安装和切换不同版本（基于当前路径，用户等）。\r\n这是在系统版本和3.6.3之间切换的示例。运行pyenv local\r\n3.6.3会记住下次您导航到该目录时激活3.6.3版。\r\n\r\npyenv解决的问题： - 安装不同的python版本 -\r\n在不同的上下文中使用不同的python版本\r\npyenv和pip如何交互？\r\nPyenv和pip相辅相成。您可以将pyenv视为pip的容器/外壳。无论pyenv设置为什么，Pip都会为当前python版本安装软件包。实际上，来自两个环境的pip命令是不同的二进制文件，它们互不影响。\r\n\r\nConda\r\n你可能在Anaconda或miniconda知道这个工具\r\n一旦科学界开始认真使用python，Python领域对软件包管理工具的需求就会增加。更具体地说，对于某些纯粹的计算工作负载，python变得太慢了，因此诞生了numpy和scipy。这些库不是真正用python编写的。它们是用C语言编写的，只是包装为python库。\r\n编译此类库带来了一系列挑战，因为必须（或多或少）将它们编译在您的计算机上才能获得最佳性能，并与glibc之类的库正确链接。\r\nConda是作为用于管理科学界的python环境的多合一解决方案而引入的。\r\n它采取了不同的方法。与在机器上使用脆弱的编译库过程不同，库是预编译的，并在您请求它们时才下载。不足的是，该解决方案附带了一个警告-conda不使用PyPI（Python包的最受欢迎索引）。\r\nConda拥有自己的带有多个渠道的包装指数（anaconda渠道由conda的创建者维护，并且是最可靠的渠道）。Anaconda频道不如PyPI完整，并且两个地方都存在的软件包通常比PyPI落后几个版本。其他渠道更新软件包的速度更快，但我强烈建议检查谁维护各自的软件包（通常不是库作者！）。\r\n\r\n总之，Conda正在解决以下问题： - 管理不同的python版本 - 管理不同的环境\r\n- 安装python包 -\r\n编译和安装非python软件包（请考虑使用OpenSSL，CUDA驱动程序等）\r\n什么是anaconda 和miniconda？\r\nAnaconda和miniconda是conda工具的不同发行版。Miniconda的目标是一切从简，它仅安装了python和conda工具。而Anaconda将安装额外的160多个软件包，这些软件包经常在数据科学工作流程中使用。\r\n如果要严格控制运行的环境，建议安装miniconda并使用自底向上的方法构建环境。\r\nconda如何与pip和其他工具互动\r\nConda是一个非常强大的工具，它解决了许多问题，因此经常在某些方面与其他工具发生冲突。虽然conda与其他工具（例如，使用pipenv）可以一起工作，但是需要对这两个工具（python软件包加载）有更深入的了解，而且并不经常这样使用。\r\n我发现有两种可靠的conda设置： - Conda作为多合一解决方案 -\r\nConda用于环境管理并为Python软件包安装二进制软件包+ pip（conda +\r\npip的最佳做法）\r\nPipenv\r\nPipenv是由热门请求包的作者创建的一套开发工作流程工具。除了使普通的工作流更加流畅并根据需求管理文件（Pipfile）之外，pipenv还解决了以下问题：\r\n- 管理不同的python版本（通过pyenv，如果已安装） - 管理不同的环境 -\r\n安装python包 - 环境再现性\r\n它从PyPI加载程序包，因此不会遇到与Conda相同的问题。\r\nPipenv是第一个提出认真解决环境可再现性问题的工具。保存conda环境（environment.yml）和pip\r\n/\r\nvenv（requirements.txt）的标准方法解决了部分问题：它们包含您已安装的版本化软件包，但不包含其依赖项的版本。这就为包括安全问题在内的几类错误留出了空间。\r\n\r\nPipenv通过维护Pipfile.lock文件来密封软件包版本，该文件包含虚拟环境中使用的所有软件包的特定版本。\r\npipenv如何与pip和其他工具一起使用？\r\nPipenv是pip和其他几种工具的不错的包装，这意味着它与pip可以很好地交互。如果您使用pipenv install &lt;package&gt;而不是pip install &lt;package&gt;，则可以节省一些手动步骤（更改Pipfile和Pipfile.lock）。\r\nPoetry\r\nPoetry“简化了python包装和依赖管理”。Poetry与Pipenv最相似，并且它们经常争夺用户。诗歌要解决的主要问题是：\r\n- 管理不同的环境 - 安装python包 - 环境再现性 - 打包和发布python包\r\n您可以看到它与Pipenv没什么不同。建议与pyenv一起使用。完成此操作后，它可以解决pipenv遇到的所有问题，而且还有助于创建python软件包并将其发布到PyPI。\r\n\r\nPoetry如何与其他工具互动？\r\nPoetry是pyenv的补充，它们共同构成了用于管理工作流的完整解决方案。与pipenv相同，它使用PyPI来安装软件包，因此一旦开始使用Poetry就无需使用pip。\r\nPipenv 还是 poetry？\r\n不止你一个人想知道为什么会有两个非常相似的工具。主要的技术差异是它们解析软件包的方式。这实际上是一个非常棘手的问题，而poetry在这一方面更胜一筹。当您安装新软件包时，它将更快地弄清它到底需要做什么，并且将更优雅地处理复杂的依赖关系图。\r\n我的建议是，如果有人尚未针对您正在研究的项目做一个，那就选择其中任一个。\r\nDocker\r\nDocker与python依赖管理无关，但是人们经常在相同的上下文中谈论它，因此绝对值得探索它的作用。\r\nDocker是用于创建，运行和管理容器的工具。您可以将容器视为非常轻量级的虚拟机。没有虚拟化，但是它们与操作系统的其他部分是完全隔离的。它为打包生产软件的通用解决方案而被创建，并且以可复制、隔离的方式在云端中运行。\r\n您可以运行我在Docker容器中介绍过的任何工具。Docker的优点在于，它给您提供的隔离避免了一些问题。例如，常规的设置是您在不同的容器中运行每个应用程序。这意味着您可以在其中安装不同的python版本，并且它们彼此之间不会影响。此外，由于应用程序是设计隔离的，因此无需任何虚拟环境管理。\r\nDocker是一项伟大的创新，它发生在我们在生产环境中运行软件的方式上，但是我不建议将其作为开发机上python依赖管理问题的解决方案。\r\n在将Docker用于开发环境时，人们会遇到很多问题： - 在Windows和Mac\r\nOS上，其性能明显下降 - 除了基本的conda / pipenv /\r\npoetry命令之外，还有很多东西要学习 -\r\n在Docker容器中设置IDE以发现和调试应用程序依赖项通常并非易事，这使开发更加困难\r\n- 安装与基础系统深度链接的库（例如CUDA驱动程序）可能会变得非常棘手\r\n\r\n比较所有解决方案\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n安装python包\r\n安装非python软件包\r\n管理python版本\r\n管理虚拟环境\r\n环境再现性\r\n\r\n\r\n\r\n\r\nPip\r\n✅\r\n✖ *\r\n \r\n \r\n \r\n\r\n\r\nvenv\r\n \r\n \r\n \r\n✅\r\n \r\n\r\n\r\npyenv\r\n \r\n \r\n✅\r\n \r\n \r\n\r\n\r\nconda\r\n✅\r\n✅\r\n✅*\r\n✅\r\n \r\n\r\n\r\npipenv（+ pyenv）\r\n✅\r\n✅\r\n \r\n✅\r\n✅\r\n\r\n\r\npoetry（+ pyenv）\r\n✅\r\n✅\r\n \r\n✅\r\n✅\r\n\r\n\r\nDocker\r\n*\r\n*\r\n*\r\n*\r\n✅\r\n\r\n\r\n\r\n*Pip：pip无法处理非Python软件包的安装，但是pip\r\nwheel消除了在大多数体系结构上大多数库在本地编译软件包的需要\r\nConda：即使conda可以安装非python软件包，它也不能完全替换您的系统软件包管理器（yum，apt-get）。在EC2之类的平台上运行软件仍将需要在conda之外安装一些软件包。\r\nDocker：由于Docker非常不了解Python，因此您需要在容器内使用其他工具来完成这些工作。\r\n常规设置\r\nPipenv（+ pyenv）\r\n易于学习，出色的设置可用于管理依赖关系管理中的所有主要问题。强烈推荐。每当我建立一个新项目时，我都会使用它。\r\nPoetry（+ pyenv）\r\n与pipenv一样，它带来了很多好处，并且没有重大缺点。\r\nConda\r\n有些人仅使用conda。此设置的主要问题是，某些库在conda通道中不可用，因此您必须求助于使用conda\r\n+ pip。\r\nConda + pip\r\n通用设置，使用conda进行python版本管理，虚拟环境管理以及安装二进制依赖项。用于安装python软件包的Pip。不幸的是，我提到它有其自身的问题，conda通常是一个非常庞大的工具。\r\n经常使用它是因为conda通过nb_conda_kernels扩展与Jupyter集成得很好。每当必须在其他人设置的环境（例如SageMaker）中使用conda时，我都会使用它。\r\nPyenv + pip + venv\r\n轻量级的设置来管理不同的python版本和虚拟环境。缺乏用于环境可再现性的解决方案，这对于可靠的生产操作是一个问题。\r\n","categories":["编程语言"],"tags":["Python"]},{"title":"Python 面试准备","url":"/20200408/python-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","content":"\n转载知乎\n 基础知识\n 1. 列出 5 个常用 Python 标准库？\ntime os sys glob timeit datetime calendar random math operator\nre urllib threading multiprocessing queue equests，virtualenv，selenium，scrapy，xadmin，celery，hashlib，md5。\n20个必不可少的Python库也是基本的第三方库\nNumpy，Scipy，Pandas\nqueue\n os 模块\nos 模块# coding:utf-8# os 模块 处理文件和目录import os# 1. os.getcwdos.getcwd()   # 返回当前的工作目录# 2. os.listdiros.listdir(&#x27;d:&#x27;) #　目录下的所有文件（夹）# 3. os.path.existsos.path.exists(filepath) # 判断文件是否存在# 4. os.removeos.remove(filepath) # 删除文件\n sys 模块\nsys 模块# coding:utf-8# sys 模块 提供对解释器使用或维护的一些变量的访问，以及与解释器强烈交互的函数import sys# 1. sys.argv print(sys.argv[1]) # 脚本执行参数列表，0为文件名# 2. sys.exit(n)try:    sys.exit(1) # 异常退出程序except SystemExit,value:    exitfunc(value)# 3. sys.modulesprint(sys.modules.keys()) # sys.modules 全局字典 自动记录模块print(sys.modules.values())print(sys.modules[&quot;os&quot;])# 4. sys.stdin\\stdout\\stderr# 与解释器的标准输入，输出和错误流相对应的文件对象 支持read()、write()和flush()等操作\n glob 模块\nglob 模块# coding:utf-8# glob 模块 提供了一个函数用于从目录通配符搜索中生成文件列表import glob# 1. glob.globglob.glob(&#x27;*.py&#x27;)\n random 模块\nrandom 模块# coding:utf-8# random 模块 随机数import randomprint( random.randint(1,10) ) # 返回 1 到 10 的一个整数型随机数print( random.random() ) # 返回 0 到 1 之间的随机浮点数print( random.uniform(1, 10) ) # 返回 1 到 10 之间的随机浮点数print( random.uniform(1.1,5.4) ) # 返回  1.1 到 5.4 之间的随机浮点数，区间可以不是整数print( random.choice(&#x27;abcdefg&#x27;) ) # 从序列中随机选取一个元素print( random.sample(&#x27;zyxwvutsrqponmlkjihgfedcba&#x27;,5)) # 多个字符中生成指定数量的随机字符print( random.randrange(1,100,2) ) # 返回 从1到100的间隔为2的随机整数a=[1,3,5,6,7] # 将序列a中的元素顺序打乱random.shuffle(a)print(a)\n math 模块\nmath 模块# coding:utf-8# math 模块import mathmath.ceil(x) 上入整数math.exp(x) e的x次幂math.fabs(x) 绝对值 浮点数math.floor(x) 下舍整数math.log(x[,y]) 以e[y]为基数的x的对数math.log2(x) 以2为基数的x的对数math.log10(x) 以10为基数的x的对数math.modf(x) 整数部分与小数部分math.sqrt(x) x的平方根math.atan2(y,x) 返回给定的 X 及 Y 坐标值的反正切值。math.hypot(x,y) 返回给定的 X 及 Y 坐标值的反正切值。math.degress(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0math.radians(x) 将角度转换为弧度math.copysign(x,y) 把y的正负号加到x前面math.factorial(x) x的阶乘math.fmod(x,y) 得到x/y的余数，其值是一个浮点数math.frexp(x) 返回一个元组(m,n),x = m * (2 ** n),m的绝对值属于(0.5,1)math.ldexp(x,i) 返回 x * (2 ** i) 的值math.fsum(iterable) 对迭代器里的每个元素进行求和操作math.gcd(x,y) 返回x和y的最大公约数math.hypot(x,y) 用勾股定理求斜边的长math.isfinite(x) 判定x不是无穷大 boolmath.isinf(x) 判定x是无穷大 boolmath.isnan(x) 判定x不是数字 boolmath.modf(x) 返回由x的小数部分和整数部分组成的元组math.trunc(x) 返回x的整数部分\n operator 模块\noperator 模块# coding:utf-8# operator 模块# operator模块是用c实现的，所以执行速度比python代码快import operatoroperator.lt(a, b) # a &lt; boperator.le(a, b) # a &lt;= boperator.eq(a, b) # a = boperator.ne(a, b) # a != boperator.ge(a, b) # a &gt;= boperator.gt(a, b) # a &gt; boperator.not_(obj)operator.truth(obj) 如果 obj 为真值则返回 True，否则返回 False。 这等价于使用 bool 构造器。operator.is_(a, b)  返回 a is b. 测试对象标识operator.is_not(a, b) 返回 a is not b. 测试对象标识。operator.add(a, b) # 返回 a + boperator.sub(a, b) # 返回 a - b.operator.mul(a, b) # 返回 a * b。operator.truediv(a, b) # 返回 a / b operator.floordiv(a, b) # 返回 a // b. 取整operator.mod(a, b) # 返回 a % b. 字符串格式化operator.matmul(a, b) # 返回 a @ b 矩阵相乘operator.pow(a, b) ＃ 对于数字 a 和 b，返回 a ** b。operator.abs(obj) 返回 obj 的绝对值。operator.neg(obj) 返回 obj 的负值 (-obj)operator.pos(obj) 返回 obj 取正的结果 (+obj)operator.index(a) 返回 a 转换为整数的结果。 等价于 a.__index__()。operator.and_(a, b) 返回 x 和 y 按位与operator.or_(a, b) 返回 a 和 b 按位或的结果。operator.inv(obj) 返回数字 obj 按位取反的结果。 这等价于 ~obj。operator.invert(obj) 返回数字 obj 按位取反的结果。 这等价于 ~obj。operator.xor(a, b) 返回 a 和 b 按位异或的结果。operator.lshift(a, b) 返回 a 左移 b 位的结果。operator.rshift(a, b) 返回 a 右移 b 位的结果。适用于序列的操作（其中一些也适用于映射）包括：operator.concat(a, b) 对于序列 a 和 b，返回 a + b。operator.contains(a, b) 返回 b in a 检测的结果。 请注意操作数是反序的。operator.countOf(a, b) 返回 b 在 a 中的出现次数。operator.setitem(obj, k, v) 将索引号 b 上的值 a 设为 c。operator.getitem(obj, k) 返回索引号 b 上的值 a。operator.delitem(obj, k) 移除索引号 b 上的值 a。operator.indexOf(obj, k) 返回 b 在 a 中首次出现所在的索引号。operator.length_hint(obj, default=0) 返回对象 o 的估计长度。 首先尝试返回其实际长度，再使用 object.__length_hint__() 得出估计值，最后返回默认值。operator.attrgetter(attr)operator.attrgetter(*attrs)# 返回一个可从操作数中获取 attr 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。# 在 f = attrgetter(&#x27;name&#x27;) 之后，调用 f(b) 将返回 b.name。# 在 f = attrgetter(&#x27;name.first&#x27;, &#x27;name.last&#x27;) 之后，调用 f(b) 将返回 (b.name.first, b.name.last)operator.itemgetter(item)operator.itemgetter(*items)# 返回一个使用操作数的 __getitem__() 方法从操作数中获取 item 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。# 在 f = itemgetter(2) 之后，调用 f(r) 将返回 r[2]。# 在 g = itemgetter(2, 5, 3) 之后，调用 g(r) 将返回 (r[2], r[5], r[3])。operator.methodcaller(name[, args...])# 返回一个在操作数上调用 name 方法的可调用对象。 如果给出额外的参数和/或关键字参数，它们也将被传给该方法。 例如：# 在 f = methodcaller(&#x27;name&#x27;) 之后，调用 f(b) 将返回 b.name()。# 在 f = methodcaller(&#x27;name&#x27;, &#x27;foo&#x27;, bar=1) 之后，调用 f(b) 将返回 b.name(&#x27;foo&#x27;, bar=1)。############### 原地操作 ################ 不可变的目标例如字符串、数字和元组,需要再次赋值# 可变的目标例如列表和字典，原地方法将执行更新，因此不需要后续赋值操作\toperator.iadd(a, b) # a = iadd(a, b) 等价于 a += b。operator.iand(a, b) # a = iand(a, b) 等价于 a &amp;= b。operator.iconcat(a, b) # a = iconcat(a, b) 等价于 a += b 其中 a 和 b 为序列。operator.ifloordiv(a, b) # a = ifloordiv(a, b) 等价于 a //= b.operator.ilshift(a, b) # a = ilshift(a, b) 等价于 a &lt;&lt;= b。operator.imod(a, b) # a = imod(a, b) 等价于 a %= b。operator.imul(a, b) # a = imul(a, b) 等价于 a *= b。operator.imatmul(a, b) # a = imatmul(a, b) 等价于 a @= boperator.ior(a, b) # a = ior(a, b) 等价于 a |= b。operator.ipow(a, b) # a = ipow(a, b) 等价于 a **= b。operator.irshift(a, b) # a = irshift(a, b) 等价于 a &gt;&gt;= b。operator.isub(a, b) # a = isub(a, b) 等价于 a -= b。operator.itruediv(a, b) # a = itruediv(a, b) 等价于 a /= b。operator.ixor(a, b) # a = ixor(a, b) 等价于 a ^= b。\n\n\n\n运算\n语法\n函数\n\n\n\n\n加法\na + b\nadd(a, b)\n\n\n字符串拼接\nseq1 + seq2\nconcat(seq1, seq2)\n\n\n包含测试\nobj in seq\ncontains(seq, obj)\n\n\n除法\na / b\ntruediv(a, b)\n\n\n除法\na // b\nfloordiv(a, b)\n\n\n按位与\na &amp; b\nand_(a, b)\n\n\n按位异或\na ^ b\nxor(a, b)\n\n\n按位取反\n~ a\ninvert(a)\n\n\n按位或\na | b\nor_(a, b)\n\n\n取幂\na ** b\npow(a, b)\n\n\n一致\na is b\nis_(a, b)\n\n\n一致\na is not b\nis_not(a, b)\n\n\n索引赋值\nobj[k] = v\nsetitem(obj, k, v)\n\n\n索引删除\ndel obj[k]\ndelitem(obj, k)\n\n\n索引取值\nobj[k]\ngetitem(obj, k)\n\n\n左移\na &lt;&lt; b\nlshift(a, b)\n\n\n取模\na % b\nmod(a, b)\n\n\n乘法\na * b\nmul(a, b)\n\n\n矩阵乘法\na @ b\nmatmul(a, b)\n\n\n否定（算术）\n- a\nneg(a)\n\n\n否定（逻辑）\nnot a\nnot_(a)\n\n\n正数\n+ a\npos(a)\n\n\n右移\na &gt;&gt; b\nrshift(a, b)\n\n\n切片赋值\nseq[i:j] = values\nsetitem(seq, slice(i, j), values)\n\n\n切片删除\ndel seq[i:j]\ndelitem(seq, slice(i, j))\n\n\n切片取值\nseq[i:j]\ngetitem(seq, slice(i, j))\n\n\n字符串格式化\ns % obj\nmod(s, obj)\n\n\n减法\na - b\nsub(a, b)\n\n\n真值测试\nobj\ntruth(obj)\n\n\n比较\na &lt; b\nlt(a, b)\n\n\n比较\na &lt;= b\nle(a, b)\n\n\n相等\na == b\neq(a, b)\n\n\n不等\na != b\nne(a, b)\n\n\n比较\na &gt;= b\nge(a, b)\n\n\n比较\na &gt; b\ngt(a, b)\n\n\n\n 内置函数 部分\n内置函数 部分# coding:utf-8# 1. input([prompt]) 返回为 string 类型# 2. print(*objects, sep=&#x27; &#x27;, end=&#x27;\\n&#x27;, file=sys.stdout, flush=False) 打印输出；flush = True，Loading 的效果# 3. format 格式化字符串# 4. help([object]) 返回对象帮助信息。# 5. dir 返回当前范围内的变量、方法和定义的类型列表。带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。# 6. open(file, mode=&#x27;r&#x27;) 打开一个文件，并返回文件对象;如果该文件无法被打开，会抛出 OSError;关闭文件对象，即调用 close() # 7. type(name, bases, dict) 只有第一个参数则返回对象的类型，三个参数返回新的类型对象。# 8. all(iterable) 判定容器内的元素全部都有意义# 9. any(iterable) 判定容器内的元素存在一个有意义# 10. bool([x]) 返回一个布尔值# 12. str 返回一个对象的string格式。# 13. repr(object) 返回一个对象的 string 格式# 14. tuple( iterable ) 返回元组 将集合转换为元组时，只保留键！# 15. list() 返回列表# 16. dict 返回一个字典# 17. set([iterable]) 创建一个无序不重复元素集-集合， &amp; 交集、 | 并集、 - 差集# 18. frozenset([iterable]) 返回一个冻结的集合-不可变集合# 19. map(function, iterable, ...) 返回迭代器，根据提供的函数对指定序列做映射# 20. hash(object) 返回对象的哈希值。# 21. zip([iterable, ...]) 返回一个对象。# 22. id([object]) 返回对象的唯一标识符，CPython 中获取对象的内存地址# 23. enumerate(sequence, [start=0]) 返回 enumerate(枚举) 对象，list中元素加入下标成元组类型。# 24. iter(object[, sentinel]) 生成迭代器# 25. reversed(seq) 返回一个反转的迭代器，使逆序# 26. next() 返回迭代器的下一个项目# 27. filter(function, iterable) 返回一个迭代器对象,使用 list() 来转换为列表list(enumerate( [&#x27;Spring&#x27;, &#x27;Summer&#x27;, &#x27;Fall&#x27;, &#x27;Winter&#x27;] , start=1))# 28. range(start, stop[, step]) 返回的结果是一个整数序列的对象# 29. len() 返回对象长度。# 30. slice(start, stop[, step]) 实现切片对象list(range(100)[slice(2,25,3)]) # [slice(2,25,3)]等同[2:25:3]# 31. sorted(iterable, key=None, reverse=False) 返回重新排序的列表，对所有可迭代的对象进行排序操作；list.sort()会修改原始的 listd1 = [&#123;&#x27;name&#x27;:&#x27;alice&#x27;, &#x27;score&#x27;:38&#125;, &#123;&#x27;name&#x27;:&#x27;bob&#x27;, &#x27;score&#x27;:18&#125;, &#123;&#x27;name&#x27;:&#x27;darl&#x27;, &#x27;score&#x27;:28&#125;, &#123;&#x27;name&#x27;:&#x27;christ&#x27;, &#x27;score&#x27;:28&#125;]sorted(d1, key=lambda x:(-x[&#x27;score&#x27;], x[&#x27;name&#x27;])) # 先按照成绩降序排序，相同成绩的按照名字升序排序# 32. globals() 返回全局变量的字典# 33. locals() 返回字典类型的局部变量。# 34. vars([object]) 返回对象object的属性和属性值的字典对象，如果没有参数，就打印当前调用位置的属性和属性值 类似 locals()# 35. memoryview(obj) 返回给定参数的内存查看对象# 36. abs(x) 绝对值# 37. max(x1, x2, ...) 最大值# 38. min(x1, x2, ...) 最小值# 39. pow(x,y) x**y# 40. sum(iterable[, start]) 返回计算结果# 41. round( x [, n]  ) 返回浮点数 x 的五舍六入的值# 42. divmod 返回一个包含商和余数的元组# 43. complex 返回一个复数# 44. ascii(object) 返回一个对象可打印的字符串# 45. bytearray 返回一个新字节数组# 46. chr 返回值对应的 ASCII 字符. chr(0x30) == chr(48) == 0# 47. ord(c) 返回值是对应的十进制整数，与 chr() 函数相对# 48. bin(x) 返回二进制字符串# 49. oct(x) 返回一个8 进制字符串，以 0o 开头# 50. int(x[, base=10]) 返回整型数据# 51. hex([x]) 返回一个16 进制字符串，以 0x 开头。# 52. float([x]) 返回浮点数# 53. eval(expression[, globals[, locals]]) 执行一个字符串表达式，并返回表达式的值# 54. exec(object[, globals[, locals]]) 返回表达式的值，支持动态执行。# 55. __import__(name[, globals[, locals[, fromlist[, level]]]]) 用于动态加载类和函数# 56. isinstance(object, classinfo) 判断obj是否和某类有关系# 57. issubclass(class, classinfo) 判断class 是否是 classinfo 的子类。# 58. super(type[, object-or-type]) 用于调用父类(超类)的一个方法，解决多重继承问题——查找顺序（MRO）、重复调用（钻石继承）等# 59. staticmethod 修饰符，声明一个静态方法，不强制要求传递参数，# 60. classmethod 修饰符, 对象不需要实例化，函数不需要 self 参数。但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等# 61. compile(source, filename, mode[, flags[, dont_inherit]]) 返回表达式执行结果。exec(compile(&quot;for i in range(0,10): print(i)&quot;,&#x27;&#x27;,&#x27;exec&#x27;))eval(compile(&quot;3 * 4 + 5&quot;,&#x27;&#x27;,&#x27;eval&#x27;))# 62. setattr 用于[创建]设置属性值# 63. getattr(object, name[, default]) 返回一个对象属性值# 64. hasattr(object, name) 判断对象是否包含对应的属性# 65. delattr(object, name) 删除对象属性dict(a=&#x27;a&#x27;, b=&#x27;b&#x27;, t=&#x27;t&#x27;)   # 传入关键字dict(zip([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], [1, 2, 3]))   # 映射函数方式来构造字典dict([(&#x27;one&#x27;, 1), (&#x27;two&#x27;, 2), (&#x27;three&#x27;, 3)])    # 可迭代对象方式来构造字典# 66. property([fget[, fset[, fdel[, doc]]]]) class C(object):    def __init__(self):        self._x = None     def getx(self):        return self._x     def setx(self, value):        self._x = value     def delx(self):        del self._x     x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)# 如果 c 是 C 的实例化, c.x 将触发 getter,c.x = value 将触发 setter ， del c.x 触发 deleter。如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）。# 将 property 函数用作装饰器可以很方便的创建只读属性# 下面的代码将 voltage() 方法转化成同名只读属性的 getter 方法。class Parrot(object):    def __init__(self):        self._voltage = 100000     @property    def voltage(self):        &quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;        return self._voltage# property 的 getter,setter 和 deleter 方法同样可以用作装饰器，这个代码和第一个例子完全相同：class C(object):    def __init__(self):        self._x = None     @property    def x(self):        &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;        return self._x     @x.setter    def x(self, value):        self._x = value     @x.deleter    def x(self):        del self._x\n 2. Python 内建数据类型有哪些？\n六个标准的数据类型：\n\nNumber（数字类别）: int、float、bool、complex\nString（字符串）\nList（列表）\nTuple（元组）\nSet（集合）\nDictionary（字典）\n\n不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n字典中的键是不可变类型，可变类型list和dict不能作为字典键\n一个对象能不能作为字典的key，就取决于其有没有__hash__方法\n\n另：映射 map、类 class、实例 、异常 BaseException\n\n 3. 简述 with 方法打开处理文件帮我我们做了什么？\nwith语句是“上下文管理器”，用于资源访问的场合，作用是资源释放和异常处理。\n如果按照常规的 f.open 写法，我们需要 try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要在finally里执行f.close()关闭文件，而with方法帮我们实现了finally中f.close。\nwith语句支持通过上下文管理器所定义的运行时上下文\n\nobject.enter（自我）\n输入与此对象相关的运行时上下文。该with语句会将此方法的返回值绑定到as该语句的子句中指定的目标（ 如果有）。\nobject.exit（self，exc_type，exc_value，traceback ）\n退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 None。\n\n\n如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。\n请注意 exit() 方法不应该重新引发被传入的异常，这是调用者的责任。\n\n 4. 列出 Python 中可变数据类型和不可变数据类型，为什么？\n变量更改后地址（id()）是否发生改变\n不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n()\n 5. Python 获取当前日期？\nimport datetimedatetime.now()# &gt;: 2021-06-20 02:12:37import timetime.ctime()# &gt;: Sun Jun 20 02:12:37 2021time.time() # 返回当前时间戳# &gt;: 1624126357time.localtime() #  返回当前时间结构元组# &gt;: time.struct_time(tm_year=2021, tm_mon=6, tm_mday=20, tm_hour=2, tm_min=12, tm_sec=37, tm_wday=6, tm_yday=171, tm_isdst=0)time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,) # 格式化输出当前时间\n 6. 统计字符串每个单词出现的次数\ns = &#x27;I can because i think i can&#x27;from collections import Counterresult = Counter(s.split())print(result)result = &#123;word: s.split().count(word) for word in set(s.split())&#125;print(result)\n 7. 用 python 删除文件和用 linux 命令删除文件方法\nimport osos.remove(filepath) # 删除文件\nrm -rf 文件名rm -rf *文件名关键字*\n 8. 写一段自定义异常代码\nclass MyException(Exception):    def __init__(self,*args):        self.args = argsclass NumErorr(MyException):    def __init__(self,numA,numB):        self.numA=numA        self.numB=numB    def __str__(self):        return f&quot;本计算器只接收整数!&quot;try:    raise MyException(&#x27;stop&#x27;)    raise NumErorr(1,2)except NumErorr as e:    print(e)except MyException as e:    print(e)\n 9. 举例说明异常模块中 try except else finally 的相关意义\n\ntry…except…else没有捕获到异常，执行else语句\ntry…except…finally不管是否捕获到异常，都执行finally语句\n\n 10. 遇到 bug 如何处理\n\n细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log\nassert / try-except / IDE单步调式\n如果涉及一些第三方框架，会去查官方文档或者一些技术博客。\nissue中查询是否有相似bug\n\n 语言特性\n 1. 谈谈对 Python 和其他语言的区别\n语言特点：简洁、优雅，省略了各种大括号和分号，还有一些关键字，类型说明；\n语言类型：解释型语言，运行的时候是一行一行的解释，并运行，所以调试代码很方便，开发效率很高；\n第三方库：python是开源的，并且python的定位是任由其发展。Python具有非常完备的第三方库；标准库与第三方库都非常强大，而且应用领域也非常广，比如Web，运维，自动化测试，爬虫，数据分析，人工智能。\n和Java相比：在很多方面，Python比Java要简单，比如java中所有变量必须声明才能使用，而Python不需要声明,用少量的代码构建出很多功能;（高效的高级数据结构）\n和C相比：类库齐全并且使用简洁，很少代码实现的功能用C可能要很复杂。运行速度相较于C，绝对是很慢了，Python和CPython解释器都是C语言编写的\n 2. 简述解释型和编译型编程语言\n解释型：就是边解释边执行；\n编译性：编译后再执行\n 3. Python 的解释器种类以及相关特点？\nCPython：c语言开发的 使用最广的解释器\nIPython：基于cpython之上的一个交互式计时器 交互方式增强 功能和cpython一样\nPyPy：目标是执行效率 采用JIT技术 对python代码进行动态编译，提高执行效率\nJython/JPython：运行在Java上的解释器 直接把python代码编译成Java字节码执行\nIronPython：运行在微软 .NET 平台上的解释器，把python编译成. NET 的字节码\n 4. 说说你知道的Python3 和 Python2 之间的区别？\npython3 和 python2 是不兼容的，而且差异比较大。\n\n\n\nPython2\nPython3\n\n\n\n\nPython2 打印内容可以不用带小括号\nPython3 中必须带；\n\n\nPython2 range(1,10)返回列表\nPython3 返回迭代器，节约内存；\n\n\nPython2 中使用ascii编码\nPython3 中使用utf-8编码；\n\n\npython2中unicode表示字符串序列，str表示字节序列\npython3中 str表示字符串序列，byte表示字节序列；\n\n\npython2中为正常显示中文，引入coding声明\npython3中 不需要\n\n\npython2中在使用super()必须在参数中写上基类\npython3中 不需要，直接无参数调用即可\n\n\npython2中True 和 False 是两个全局变量\npython3中 True或False不可变\n\n\npython2中range,字典对象的 dict.keys()、dict.values() 方法, map、filter、zip等返回列表，迭代器必须实现next方法\npython3中 将返回列表的方法改为了返回迭代器对象，内置了__next__，不用特意去实现next，rang()相当于python2中 xrang()\n\n\npython2中 没有办法在嵌套函数中将变量声明为一个非局部变量，只能在函数中声明全局变量\npython3中 nonlocal方法实现声明全局变量\n\n\npython2中函数定义不可以用中文定义\npython3中可以用中文\n\n\n\n 5. Python3 和 Python2 中 int 和 long 区别？\npython3 中 int 整合了 python2 重中的 int 和 long\npython3 中 int 类型的范围是动态长度的，正整数或者负整数，用sys.getsizeof()可以看int占了几位.\nPython2中long类型的范围是无限大小\n 6. xrange 和 range 的区别？\npython2 中xrang()返回到的是迭代器对象，rang()返回的是list列表类型\npython3 中弃用了xrang()，rang()返回到的是迭代器对象\n 7. 强类型语言、动态语言和脚本语言之间的区别？\n强类型：不允许不同类型相加。例如：整形+字符串会报类型错误。\n动态：不使用显示数据类型声明，且确定一个变量的类型是在第一次给它赋值的时候。\n脚本语言：一般是解释性语言，运行代码只需要一个解释器，不需要编辑。\n 编码规范\n 1. 什么是 PEP8?\nPEP 8(Python Enhancement Proposal 8)，是 Python 第8号增强提案，针对Python语言编订的代码风格指南、编码约定。\n\n缩进。4个空格的缩进，不使用Tap，更不能混合使用Tap和空格\n每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。\n类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。\n模块导入的顺序：按标准、三方和自己编写顺序依次导入，之间空一行。\n不要在一句中import多个库\n避免不必要的空格\n注释必须要有\n函数命名要遵循规范\n尽可能使用’is’‘is not’取代’=='，比如if x is not None 要优于if x\n异常中try的代码尽可能少\n\n 2. 了解 Python 之禅么？\nimport this&quot;&quot;&quot;The Zen of Python, by Tim PetersBeautiful is better than ugly.#(优美胜于丑陋)# Python 以编写优美的代码为目标Explicit is better than implicit.#(明了胜于晦涩)# 优美的代码应当是明了的，命名规范，风格相似Simple is better than complex.#(简洁胜于复杂)# 优美的代码应当是简洁的，不要有复杂的内部实现Complex is better than complicated.#(复杂胜于凌乱)# 如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁Flat is better than nested.#(扁平胜于嵌套)# 优美的代码应当是扁平的，不能有太多的嵌套Sparse is better than dense.#(间隔胜于紧凑)# 优美的代码有适当的间隔，不要奢望一行代码解决问题Readability counts.#(可读性很重要)# 优美的代码是可读的Special cases aren&#x27;t special enough to break the rules.#(即便假借特例的实用性之名，也不可违背这些规则)Although practicality beats purity.# 这些规则至高无上Errors should never pass silently.#(不要包容所有错误，除非你确定需要这样做)Unless explicitly silenced.# 精准地捕获异常，不写 except:pass 风格的代码In the face of ambiguity, refuse the temptation to guess.#(当存在多种可能，不要尝试去猜测)There should be one-- and preferably only one --obvious way to do it.#(而是尽量找一种，最好是唯一一种明显的解决方案)# 如果不确定，就用穷举法Although that way may not be obvious at first unless you&#x27;re Dutch.#(虽然这并不容易，因为你不是 Dutch )#  Dutch 是指 Guido -- Python 之父Now is better than never.#(做也许好过不做)Although never is often better than *right* now.#(但不假思索就动手还不如不做)# 动手之前要细思量If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.#(如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然)# 方案测评标准Namespaces are one honking great idea -- let&#x27;s do more of those!#(命名空间是一种绝妙的理念，我们应当多加利用)# 倡导与号召&quot;&quot;&quot;\n 3. 了解 docstring 么？\nPython 文档字符串(DocStrings)是一个用于解释文档程序，生成帮助文档的重要工具。通过Docstring建立的文档不仅对人来说有更好的可读性，也能够让IDE等工具自动识别使用函数、类、变量等的一些限制，从而帮助我们更好地理解程序。\nPEP0257里的约定使用三个双引号（“”&quot;）来定义文档字符串，也可以但不建议使用三个单引号 ‘’'，docstring可以写在三个地方：模块或包，对象，函数。\n使用惯例：首行简述函数功能，第二行空行，第三行为函数的具体描述。\n通过__doc__（注意双下划线）调用函数中的文档字符串属性。\n通过help函数直接输出一份有格式的文档，主要是在交互模式下使用\nPython Docstring有三种主要风格，分别是reST风格、Google风格、Numpy风格和Epytext风格等：\n reST风格\n\nreST的全称是reStructredText。通过以冒号开头的几个关键字来说明类、函数中的参数、返回值、异常等。\n\n:param &lt;类属性名称&gt;: &lt;描述&gt;:type &lt;类属性名称&gt;: &lt;类型&gt;:return: &lt;对返回值的描述&gt;:rtype: &lt;返回值类型&gt;:raises: &lt;可能抛出的异常列表&gt;\n Google风格\n\nGoogle 风格将所有的参数写在Args标签下，而所有的返回值写在Returns标签下。我个人认为比起reST风格，Google 风格的可读性要更好一些。在Args标签下，可以在参数名称后面加 (类型)来确定参数的类型，同样可以起到对参数类型的限制作用。\n\nArgs:  &lt;参数&gt; : &lt;描述&gt;  &lt;参数&gt; (&lt;类型&gt;): &lt;描述&gt;Returns:  &lt;类型&gt;: &lt;描述&gt;\n Numpy风格\n\nNumpy是矩阵分析、科学计算、机器学习中都会用到的常见Python程序库。Numpy也有自己独特的Python Docstring风格。Numpy风格的docstring似乎不能用sphinx来生成html形式的文档。\n\nParameters----------参数 : [类型]    参数的描述    Attributes----------属性 : [类型]    属性的描述\n Epytext风格\n\nEpytext类似于javadoc的风格\n\n@param a:@param b:@return:\n 4. 了解类型注解么？\n类型注解是从 Python 3.5 开始引入，提高代码的可读性，可以通过第三方工具测试代码里的类型注解正确性。\n变量类型注解需要 Python 3.6 以上版本。\n# 注解前def add(x, y):    return x + y# 加注解def add(x: int, y: int) -&gt; int:    return x + y# 查看参数和返回值类型的注解print(add.__annotations__)# inspect 模块提供了一些有用的函数帮助获取对象的信息，例如模块、类、方法、函数、回溯、帧对象以及代码对象。例如它可以帮助你检查类的内容，获取某个方法的源代码，取得并格式化某个函数的参数列表，或者获取你需要显示的回溯的详细信息。# 该模块提供了4种主要的功能：类型检查、获取源代码、检查类与函数、检查解释器的调用堆栈。# 文档: https://docs.python.org/zh-cn/3.7/library/inspect.htmlimport inspectprint(sig = inspect.signature(add))print(sig)print(sig.parameters)print(sig.return_annotation)print(sig.parameters[&#x27;x&#x27;])\n使用第三方包mypy测试注解的正确性\n# 安装pip install mypy# 测试mypy filename.py\n 5. 例举你知道 Python 对象的命名规范，例如方法或者类等\n - 变量：\n\n单下划线开头(_xx): protected\n双下划线开头(__xx): private\n双下划线开头结尾(xx): 系统内置变量\n\n - 函数\n\n私有方法(_func): 小写和一个前导下划线\n特殊方法(魔术方法)(func): 小写和两个前导下划线，两个后置下划线\n一般方法(func): 方法\n备注: 函数参数: 小写和下划线，缺省值等号两边无空格 def func(self, user=None):\n\n - 类\n\n驼峰格式命名(CamelClass): 所有单词首字母大写其余字母小写\n基类而言，可以使用一个Base或者Abstract前缀(CamelBase)\n不要滥用*args和**kwargs，可能会破坏函数的健壮性\n\n - 常量\n大写，单词间用下划线\n 6. Python 中的注释有几种？\n单行注释：#\n多行注释：一对’''或者一对&quot;“”\n 7. 如何优雅的给一个函数加注释？\nDocstring 上文有提到。\n另，注释的种类：\n\n复述代码——这种把代码复述一遍的注释最无聊\n解释代码——解释代码的思路，这种代码可以有，但是大部分时候是因为代码写得不好\n标记——可能用的到标注，如 TODO、FIXME\n概述代码——一句话告诉别人代码做了什么，很好的注释代码\n意图说明——指出代码要解决的问题\n传达代码无法表述的信息——非常重要\n\n 8. 如何给变量加注释？\nDocstring 上文有提到\n 9. Python 代码缩进中是否支持 Tab 键和空格混用。\n支持但不建议，如果混用的话，tab按8个空格算\n 10. 是否可以在一句 import 中导入多个库?\n可以但不建议\n 11. 在给 Py 文件命名的时候需要注意什么?\n全小写，可使用下划线，不可与第三方库、内建模块等重名。\n 12. 例举几个规范 Python 代码风格的工具\nDocstring 上文有提到\n 数据类型\n 字符串\n 1. 列举 Python 中的基本数据类型？\n基本数据类型上文有提到\n 2. 如何区别可变数据类型和不可变数据类型\n可变数据类型&amp;不可变数据类型上文有提到\n 3. 将&quot;hello world&quot;转换为首字母大写&quot;Hello World&quot;\nstr = &quot;hello world&quot;# 转换成标题print(str.title())# capitalize() 将字符串的第一个字母变成大写，其他字母变小写# upper() 将字符串的所有字母变成大写words = str.split(&quot; &quot;)print([word.capitalize() for word in words])print([word[0].upper()+word[1:] for word in words])\n 4. 如何检测字符串中只含有数字?\nstr = &#x27;123&#x27;str.isdigit()str.isnumeric() # 只是针对Unicode对象\n 5. 将字符串&quot;ilovechina&quot;进行反转\nstr = &quot;ilovechina&quot;# 一行newStr = str[::-1]newStr = &#x27;&#x27;.join(i for i in str[::-1])newStr = &#x27;&#x27;.join(list(reversed(str)))newStr = &#x27;&#x27;.join(i for i in reversed(str))# 两行str_list = list(str)newStr = &#x27;&#x27;.join( ( str_list, str_list.reverse() )[0] )# 列表倒序(按 “ASCII 字符顺序” 进行排序)str_list = list(str)str_list.sort(reverse=True)newStr = &#x27;&#x27;.join(str_list)# 累积相加法from functools import reducedef add(x, y) :    return y + xnewStr = reduce(add, [1,2,3,4,5]))# 累积相加法 进阶from functools import reducenewStr = reduce(lambda x,y:y+x, str)# 累积相加法 高阶from functools import reducenewStr = reduce(lambda x,y:y+x, str)# 倒序切片法newStr = str[::-1]print(newStr)# 列表弹出newStr= &quot;&quot;str_list = list(str)while len(str_list) &gt; 0:    newStr = newStr + str_list.pop()print(newStr)# 循环反向迭代法newStr= &quot;&quot;for i in str:    newStr = i + newStrprint(newStr)# 列表反转str_list = list(str)str_list.reverse()newStr = &#x27;&#x27;.join(str_list)print(newStr)# 善用递归def func(s):    if len(s)&lt;=1:        return s    return s[-1] + func(s[:-1])newStr = func(str)print(newStr)        \n 6. Python 中的字符串格式化方式你知道哪些？\n由双引号包围的是格式化字符串，可以理解为一个字符串模板。特别地，由三引号包围的字符串更为直观，之间的所有字符，包括换行、TAB，都属于字符串的内容。Python的字符串格式化有两种方式:%格式符方式，format方式、f-string方式。\n\n%格式符方式: %[(name)][flags][width].[precision]typecode\n|  | 解释 |\n| :----- | :----- |\n| (name) | 指定变量 |\n| flags| 默认右对齐，正数前无符号，负数前加负号，用空格填充空白处转为浮点数同时默认以0补充至小数点后6位，第7位开始用空格补充 可选值:   +:正数前加正号  -:左对齐  0:用0填充空白处 |\n| width | 最小占有宽度 |\n| .precision | 小数点后保留的位数|\n| typecode | 转换符号 %d、%i\t转换为带符号的十进制整数%o 转换为带符号的八进制整数%x、%X 转换为带符号的十六进制整数%e 转化为科学计数法表示的浮点数（e 小写）%E 转化为科学计数法表示的浮点数（E 大写）%f、%F\t转化为十进制浮点数%g 智能选择使用 %f 或 %e 格式%G 智能选择使用 %F 或 %E 格式%c 格式化字符及其 ASCII 码%r 使用 repr() 函数将表达式转换为字符串%s 使用 str() 函数将表达式转换为字符串|\n\n几点说明：\n\n对于整数，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。\n对于小数，以上三个标志可以同时存在。如果没有要求小数位，则默认以0补充至小数点后6位，第7位开始用空格补充。\n对于字符串，只能使用-标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。\n当字符串中存在格式化标志时，需要用 %%表示一个百分号\n\n\n\nformat\n数字格式的定义以 ‘:’ 号开始。碰到了’: '字符就知道要定义一个数字的显示格式了。格式的定义顺序为 [[fill]align][sign][#][0][width][,][.precision][type]\n||解释|\n|:–|:–|\n| fill | 【可选】空白处填充的字符 |\n| align| 【可选】对齐方式（需配合width使用）&lt;，内容左对齐&gt;，内容右对齐(默认)＝，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号+填充物+数字^，内容居中 |\n| sign | 【可选】有无符号数字+，正号加正，负号加负；-，正号不变，负号加负；空格 ，正号空格，负号加负； |\n| # | 【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示|\n| , |【可选】为数字添加分隔符，如：1,000,000 |\n| width | 【可选】格式化位所占宽度 |\n| .precision |【可选】小数位保留精度 |\n| type | 【可选】格式化类型s，格式化字符串类型数据空白，未指定类型，则默认是None，同sb，将10进制整数自动转换成2进制表示然后格式化c，将10进制整数自动转换为其对应的unicode字符d，十进制整数o，将10进制整数自动转换成8进制表示然后格式化；x，将10进制整数自动转换成16进制表示然后格式化（小写x）X，将10进制整数自动转换成16进制表示然后格式化（大写X）e， 转换为科学计数法（小写e）表示，然后格式化；E， 转换为科学计数法（大写E）表示，然后格式化;f ， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；g， 自动在e和f中切换G， 自动在E和F中切换%，显示百分比（默认显示小数点后6位） |\nf-string\nf-string就是在format格式化的基础之上做了一些变动，核心使用思想和format一样。在这个方式中，大括号{ }里放被替换字段\\变量，在:前可以填入表达式或调用函数或匿名函数。\n\n 7. 把一个字符串开头和末尾都有空格\n比如&quot; adabdw &quot;,要求写一个函数把这个字符串的前后空格都去掉。\n\nstrip()：把头和尾的空格去掉\nlstrip()：把左边的空格去掉\nrstrip()：把右边的空格去掉\nreplace(‘c1’,‘c2’)：把字符串里的c1替换成c2。故可以用replace(’ ‘,’')来去掉字符串里的所有空格\nsplit()：通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串\n用正则匹配：\n\n# re.sub 表示替换; \\s 表示空白字符re.sub(&#x27; &#x27;,&#x27;&#x27;,str) # 把str中的空格全部清除def trim(s):    &#x27;&#x27;&#x27; 如果两端存在空格，则清除两端的空格，并返回结果 &#x27;&#x27;&#x27;    import re    if s.startswith(&#x27; &#x27;) or s.endswith(&#x27; &#x27;): # 如果两端存在空格      return re.sub(r&quot;^(\\s+)|(\\s+)$&quot;, &quot;&quot;, s) # 仅清除两端的空格    return s\n\n使用递归：\n\ndef trim(s):    if s[0] == &quot; &quot;:      return trim(s[1:])   # 如果开首有多个空格的话，递归去除多个空格    elif s[-1] == &quot; &quot;:      return trim(s[:-1])  # 如果末尾有多个空格的话，递归去除多个空格    else:      return s\n 8. 获取字符串&quot;123456&quot;最后的两个字符。\nprint(&quot;123456&quot;[-2:])\n 9. 一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？\nstr1 = &quot;人生苦短，我用Python&quot;S = str1.encode(&#x27;GBK&#x27;) # 编码 GBKresult = S.decode(&#x27;GBK&#x27;).encode(&#x27;UTF-8&#x27;) # 解码 GBK 后，编码 UTF-8\n 10. 正则切分字符串\ns=“info：xiaoZhang 33 shandong”，用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]\nimport res=&quot;info：xiaoZhang 33 shandong&quot;# compile 预编译正则表达式# \\W 匹配任何不是单词字符的字符pattern = re.compile(r&#x27;\\W&#x27;)print(pattern.split(s))# 同下re.split(r&#x27;\\W&#x27;, s)\n 11. 去除多余空格只留一个空格\na = &quot;你好 中国 &quot;，去除多余空格只留一个空格。\na = &quot;你好 中国 &quot;print(a.rstrip()) # rstrip 去除右边空格\n 12. 怎样将字符串转换为小写\ndemo_str = &quot;HELLO WORLD&quot;demo_str.lower() # 转小写使用lower() 转大写使用upper()\n 13. 单引号、双引号、三引号的区别？\n单引号和双引号都可以用来表示一个字符串，区别不大，遇到需要转义字符的情况需要注意。\n三个单引号和三个双引号一般用于多行注释，也可以用来表示字符串：输出多行文本\n 列表\n 1. 已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。\nAList = [1, 2, 3, 1, 2]# 第一种方法，使用set集合，先转为集合再转回列表result_list = list(set(AList))print(result_list)# 第二种，使用dict.fromkeys，该函数有两个参数，第一个是字典的键，第二个是对应值(默认为空str)，用于创建一个字典类型result_list = list(dict.fromkeys(AList))print(result_list)# 第三种，遍历列表进行判断result_list = []for i in AList:    if i not in result_list:        result_list.append(i)print(result_list)# 第四种，使用pandas.unique()方法，import pandasresult_list = pandas.unique(AList).tolist()print(result_list)# 还有一种不简单的简单行码[(this,this.append(i)) for this in ([],) for i in AList if i not in this ][0][0]\n 2. 如何实现 “1,2,3” 变成 [“1”,“2”,“3”]\ndemo_str = &quot;1,2,3&quot;result_list = demo_str.split(&quot;,&quot;)print(result_list)\n 3. 给定两个 list，A 和 B，找出相同元素和不同元素\n# 找相同same_list = [i for i in list_A if i in list_B]# 找不同 在A不在B + 在B不在Adifferent_list = [i for i in list_A if i not in list_B] + [i for i in list_B if i not in list_A]# 通过集合# # 找相同set(list_A) &amp; set(list_B)# 找不同 对称差分是集合的XOR 又称&quot;异或&quot; 等价的方法：symmetric_difference()set(list_A) ^ set(list_B)\n 4. [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]\nq_list = [[1,2],[3,4],[5,6]]a_list = [ i for item in q_list for i in item]\n 5. 合并列表[1,5,7,9]和[2,2,6,8]\na_list = [1,5,7,9]b_list = [2,2,6,8]# 第一种方法：使用运算符“+”a_list = a_list + b_listprint(a_list)# 第二种方法：使用运算符extend()方法a_list.extend(b_list)print(a_list)# 第三种方法：使用appendfor i in b_list:    a_list.append(i)print(a_list)[ a_list.append(i) for i in b_list]\n 6. 如何打乱一个列表的元素？\nimport randomq_list = [i for i in range(10)]# 使用random.shuffle打乱一个list数组random.shuffle(q_list)print(q_list)\n 字典\n 1. 字典操作中 del 和 pop 有什么区别\nq_dic = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;# pop方法删除指定的键值对，并返回删除的值pop_str = q_dic.pop(&quot;a&quot;)print(q_dic,&#x27;\\n&#x27;,pop_str)# del不会返回相应的值，只是将其删除del q_dic[&quot;b&quot;]print(q_dic)\n 2. 按照字典的内的年龄排序\n\nd1=[\n{‘name’:‘alice’,‘age’:38},\n{‘name’:‘bob’,‘age’:16},\n{‘name’:‘carl’,‘age’:18},\n]\nd1=[    &#123;&#x27;name&#x27;:&#x27;alice&#x27;,&#x27;age&#x27;:38&#125;,    &#123;&#x27;name&#x27;:&#x27;bob&#x27;,&#x27;age&#x27;:16&#125;,    &#123;&#x27;name&#x27;:&#x27;carl&#x27;,&#x27;age&#x27;:18&#125;,    ]# 强大的sort方法，满足大多数排序算法，列表排序优先考虑sort！&quot;&quot;&quot;list.sort( key=None, reverse=False)key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse --排序规则，reverse = True降序，reverse = False升序（默认）。&quot;&quot;&quot;d1.sort(key=lambda x: x[&#x27;age&#x27;])print(d1)\n 3. 请合并下面两个字典 a = {“A”:1,“B”:2},b = {“C”:3,“D”:4}\na = &#123;&quot;A&quot;:1,&quot;B&quot;:2&#125;b = &#123;&quot;C&quot;:3,&quot;D&quot;:4&#125;# 字典拆分 pyhton 3.5+d = &#123;**a, **b&#125;# 使用update方法a.update(b)print(a)# 字典推导式d = &#123;k:v for d in [a, b] for k,v in d.items()&#125; # 列表拼接d = dict(list(a.items()) + list(b.items())) # 元素并集# items() 返回的是一个类似集合的对象，并不准确，集合是无序的，键重复时不能保证谁覆盖谁。# 只适合字典中的值可以保证是唯一的可哈希的d = dict(a.items() | b.items())# 关键字参数# 只适合字典的键是字符串时才有效d = dict(a , **b) # chain itemsfrom itertools import chaind = dict(chain(a.items(), b.items()))# ChainMapfrom collections import ChainMapd = dict(ChainMap(a, b))\n 4. 如何使用生成式的方式生成一个字典，写一段功能代码。\n&#123; k:v for k,v in enumerate(range(10))&#125;\n 5. 如何把元组(“a”,“b”)和元组(1,2)，变为字典{“a”:1,“b”:2}\ntuple_key = (&quot;a&quot;, &quot;b&quot;)tuple_val = (1, 2)result_dic = dict(zip(tuple_key,tuple_val))print(result_dic)\n 综合\n 1. Python 常用的数据结构的类型及其特性？\n\n数据类型 上文有提到\n 2. 如何交换字典 {“A”：1,“B”：2}的键和值？\ndemo_dic = &#123;&quot;A&quot;: 1, &quot;B&quot;: 2&#125;# 使用字典推导式交换位置result_dic = &#123;v: k for k, v in demo_dic.items()&#125;print(result_dic)\n 3. Python 里面如何实现 tuple 和 list 的转换？\n强制类型转换\ntuple(demo_list)list(demo_tup)\n 4. 我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？\nfrom itertools import islicegener = (i for i in range(10))gener_clip = islice(gener, 3, 7)for i in gener_clip:    print(i)\n 5. 请将[i for i in range(3)]改成生成器\n(i for i in range(3))  # 方括号改为圆括号即可\n 6. a=&quot;hello&quot;和 b=&quot;你好&quot;编码成 bytes 类型\na.encode()b.encode()\n 7. 下面的代码输出结果是什么？\na = (1, 2, 3, [4, 5, 6, 7], 8)a[2] = 2# 输出: TypeError: &#x27;tuple&#x27; object does not support item assignment# 原因: 元祖是不可变类型，因此不能修改元祖内的值\n 8. 下面的代码输出的结果是什么?\na = (1, 2, 3, [4, 5, 6, 7], 8)a[3][0] = 2# 输出: (1, 2, 3, [2, 5, 6, 7], 8)# \n 9. Python 交换两个变量的值\na, b = b, a\n 10. 在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用\n\nread:读取整个文件。\nreadline：读取下一行，使用生成器方法。\nreadlines：读取整个文件到一个迭代器以供我们遍历\n\n 11. json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？\n\njson序列化时，可以处理列表、字典、字符、数值、布尔和None\n定制datetime类型↓\n\nfrom datetime import datetimeimport jsonfrom json import JSONEncoderclass DatetimeEncoder(JSONEncoder):    &quot;&quot;&quot;扩展JSONEncoder类中的default方法    判断传入的类型是否是datetime类型，如果是则转为str字符，否则不是返回父类的值    &quot;&quot;&quot;    def default(self, o):        if isinstance(o, datetime):            return o.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)        else:            return super(DatetimeEncoder, self).default(o)if __name__ == &#x27;__main__&#x27;:    dict_demo = &#123;&#x27;name&#x27;: &#x27;alex&#x27;, &#x27;data&#x27;: datetime.now()&#125;    print(json.dumps(dict_demo, cls=DatetimeEncoder))\n 12. json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？\nimport jsondict_demo = &#123;&quot;name&quot;: &quot;中文&quot;&#125;# 使用dumps的默认参数ensure_asciiprint(json.dumps(dict_demo, ensure_ascii=False).encoding=&#x27;utf-8&#x27;)\n 13. 有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。\ndata_A = data_B =&#x27;&#x27;# 读文件A B，将AB内容合并with open(A, &quot;r&quot;) as F:    data_A = F.read()with open(B, &quot;r&quot;) as F:    data_B = F.read()data = data_A + data_B# 按字母顺序排列new_data = &quot;&quot;.join(sorted(data))# 输出到一个新文件 C with open(&quot;C&quot;, &quot;w&quot;) as F:    F.write(new_data) \n 14. 如果当前的日期为 20210630，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20210702)。\nfrom datetime import datetime, timedeltas = &#x27;20210630&#x27;N = 2dt = datetime(int(s[0:4]),int(s[4:6]),int(s[6:8]))dt = datetime.strptime(s, &#x27;%Y%m%d&#x27;)dt = dt + timedelta(days=N)dt.strftime(&#x27;%Y%m%d&#x27;)\n 15. 写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。\n\n闭包是一种特殊的函数，这种函数由多个函数的嵌套组成，且称之为外函数和内函数，外函数返回值是内函数的引用，此时就构成了闭包；\n闭包函数必须返回一个函数对象；\n闭包函数返回的那个函数必须引用外部变量；\n闭包可以保存运行环境，即在闭包内的变量是不能被轻易修改的；\n闭包的好处：提高代码的可复用性。\n\ndef out_func(n):    def in_func(num):        return n*num    return in_funcdemo = out_func(3)res = demo(4)print(res)\n 16. 下面代码会存在什么问题，如何改进？\n\ndef strappend(num):        # 函数作用、参数意义不明，需要加注释    str=&#x27;frist&#x27;            # 不能使用关键字&quot;str&quot;作为变量名    for i in range(num):   # 遍历得到的元素&quot;i&quot;意义不明，无注释        str+=str(i)        # 变量名和关键字在这个时候重名，必定报错，没有了str()方法    return str# 修改后def str_append(append_cound: int) -&gt; str:    &quot;&quot;&quot;字符串修改        遍历append_cound，将遍历的值转为str类型并添加到字符串中    :param append_cound: 遍历次数    :return: 最终修改得到的新字符串    &quot;&quot;&quot;    append_str = &quot;frist&quot;    # 遍历获取到&quot;times&quot;次数int类型    for times in range(append_cound):        append_str += str(times)    return append_strprint(str_append(4))\n 17. 一行代码输出 1-100 之间的所有偶数。\nprint([ num for num in range(0, 101) if num % 2 == 0])print([ num for num in range(2,101,2)])\n 18. with 语句的作用，写一段代码？\nwith 语句上文有提到\nimport threading# 来一个用于线程锁的with使用num = 0  # 全局变量多个线程可以读写，传递数据thread_lock = threading.Lock()  # 创建一个锁class Mythread(threading.Thread):    def run(self):        global num        with thread_lock:               # with Lock的作用相当于自动获取和释放锁(资源)            for i in range(1000000):    # 锁定期间，其他线程不可以运行                num += 1        print(num)\n 19. python 字典和 json 字符串相互转化方法\njson.dumps 用于将 Python 对象编码成 JSON 字符串。\njson.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)\n\njson.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。\njson.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])\n\nimport jsondict_demo = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;# 序列化：使用json.dumps()将python类型转为json字符串json_demo = json.dumps(dict_demo)print(json_demo)# 输出：&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;# 使用其他参数json_demo = json.dumps(dict_demo,sort_keys=True, indent=4, separators=(&#x27;,&#x27;, &#x27;: &#x27;))print(json_demo)&quot;&quot;&quot;输出：&#123;    &quot;a&quot;: 1,    &quot;b&quot;: 2&#125;&quot;&quot;&quot;# 反序列化：json.loads 用于解码 JSON 数据dict_demo = json.loads(json_demo)\n 20. 请写一个 Python 逻辑，计算一个文件中的大写字母数量\nimport redef captial_count(file_name):    &quot;&quot;&quot;计算文件中的大写字母数量    读取文件并计算文件数据的大写字母数量，返回大写字母数量    :param file_name: 文件名    :return: 文件中的大写字母数量    &quot;&quot;&quot;    with open(file_name, &quot;r&quot;) as f:        file_data = f.read()    # 删除掉除大写字母之外的所有字符    file_data = re.sub(&quot;[^A-Z]&quot;, &quot;&quot;, file_data)    return len(file_data)if __name__ == &#x27;__main__&#x27;:    print(capital_count(&quot;test.txt&quot;))    \n 21. 请写一段 Python连接 Mongo 数据库，然后的查询代码。\nfrom pymongo import MongoClient# 连接本地数据库db_client = MongoClient(&quot;mongodb://localhost:27017/&quot;)# 切换到 testdb 测试数据库test_db = db_client[&quot;testdb&quot;]# 切换到 sites 文档sites_obj = test_db[&quot;sites&quot;]# find_one() 方法来查询集合中的一条数据first_data = sites_obj.find_one()print(first_data)\n 22. 说一说 Redis 的基本类型。\nstring（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n 23. 请写一段 Python连接 Redis 数据库的代码。\nimport redis# 创建连接对象connec_obj = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)# 设置一个键值connec_obj.set(&#x27;test&#x27;, &#x27;1&#x27;)# 读取一个键值connec_obj.get(&#x27;test&#x27;)   # -&gt;&gt; &#x27;1&#x27;\n 24. 请写一段 Python 连接 MySQL 数据库的代码。\nimport pymysql# 打开数据库连接db = pymysql.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset=&#x27;utf8&#x27; )# 使用cursor()方法获取操作游标cursor = db.cursor()# 使用execute方法执行SQL语句cursor.execute(&quot;SELECT VERSION()&quot;)# 使用 fetchone() 方法获取一条数据data = cursor.fetchone()# 关闭数据库连接db.close()\n 25. 了解 Redis 的事务么？\n\nRedis 事务可以一次执行多个命令，即将多个命令打包，一次性提交并按顺序执行\n批量操作在发送 EXEC 命令前被放入队列缓存\n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行\nRedis 事务的执行并不是原子性的：在事务执行过程，其他命令不会插入到事务执行命令序列中，中间某条指令的失败不会导致中断也不会导致回滚\n事务提供了一种&quot;将多个命令打包，一次性提交并按顺序执行&quot;的机制，提交后在事务执行中不会中断。只有在执行完所有命令后才会继续执行来自其他客户的消息。\n\n\nRedis通过multi，exec，discard，watch实现事务功能。\n\nmulti：开始事务\nexec：提交事务并执行\ndiscard：取消事务\nwatch：事务开始之前监视任意数量的键\nunwatch：取消WATCH命令对多有key的监控，所有监控锁将会被取消。\n关于ACID：\n单独的隔离操作：事务中的所有命令会被序列化、按顺序执行，在执行的过程中不会被其他客户端发送来的命令打断\n没有隔离级别的概念：队列中的命令在事务没有被提交之前不会被实际执行\n不保证原子性：redis中的一个事务中如果存在命令执行失败，那么其他命令依然会被执行，没有回滚机制。\n\n\n 26. 了解数据库的三范式么？\n\n1NF：字段不可分割，每个字段是原子级别\n2NF：有主键，非主键字段依赖主键\n3NF：非主键字段不能相互依赖，即消除传递依赖\nBCNF：非主键字段不能对主键的子集依赖，即消除了对主码子集的依赖\n4NF：\n\n\n多值依赖的概念:\n多值依赖即属性之间的一对多关系，记为K→→A。\n函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。\n平凡的多值依赖：全集U=K+A，一个K可以对应于多个A，即K→→A。此时整个表就是一组一对多关系。\n非平凡的多值依赖：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B互相独立，即K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。\n第四范式即在满足巴斯-科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表内的多对多关系删除）。\n\n\n5NF：\n\n\n即在满足第四范式（4NF）的基础上，消除不是由候选码所蕴含的连接依赖。如果关系模式R中的每一个连接依赖均由R的候选码所隐含，则称此关系模式符合第五范式。\n函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。\n\n 27. 了解分布式锁么？\n多线程和多进程在抢占同一资源时可能会导致数据不一致，为了保证线程或者进程安全，引入线程锁和进程锁，保证了数据的一致性和完整性。同样的，在分布式系统中对共享资源进行操作时，使用分布式锁来解决这一问题。\n分布式锁的实现有很多种，常见的有redis、zookeeper和数据库mysql等。\n详解\n 28. 用 Python 实现一个 Reids 的分布式锁的功能。\n引自：junli_chen\n#!/usr/bin/python3# coding=utf-8import timeimport redisclass RedisLock(object):    def __init__(self, key):        # 连接数据库，创建连接对象        self.rdcon = redis.Redis(host=&#x27;&#x27;, port=6379, password=&quot;&quot;, db=1)        # 设置锁的值        self._lock = 0        # 分布式锁的键        self.lock_key = &quot;%s_dynamic_test&quot; % key    @staticmethod    def get_lock(cls, timeout=10):        &quot;&quot;&quot;获取redis分布式锁        设置分布式锁，判断锁是否超时        :param cls: 锁的类对象        :param timeout: 锁超时时间        :return:        &quot;&quot;&quot;        while cls._lock != 1:            # 设置锁的过期时间            timestamp = time.time() + timeout + 1            # 设置redis分布式锁键值            cls._lock = cls.rdcon.setnx(cls.lock_key, timestamp)            # 判断锁的值是否为1，或者当前时间大于锁预期释放的时间，如果成立则退出循环，释放锁            if cls._lock == 1 or (                    time.time() &gt; cls.rdcon.get(cls.lock_key) and                    time.time() &gt; cls.rdcon.getset(cls.lock_key, timestamp)):                print(&quot;get lock&quot;)                break            else:                time.sleep(0.3)    @staticmethod    def release(cls):        &quot;&quot;&quot;释放锁        :param cls: 锁的类对象        :return:        &quot;&quot;&quot;        # 判断当前时间是否大于锁最大释放时间        if time.time() &lt; cls.rdcon.get(cls.lock_key):            print(&quot;release lock&quot;)            cls.rdcon.delete(cls.lock_key)def deco(cls):    &quot;&quot;&quot;分布式锁装饰器    :param cls: 分布式锁类对象    :return: 外层函数    &quot;&quot;&quot;    def _deco(func):        def __deco(*args, **kwargs):            print(&quot;before %s called [%s].&quot; % (func.__name__, cls))            cls.get_lock(cls)            try:                return func(*args, **kwargs)            finally:                cls.release(cls)        return __deco    return _deco@deco(RedisLock(&quot;demoLock&quot;))def myfunc():    print(&quot;myfunc() called.&quot;)    # 设置20s模拟超过锁释放时间就自动释放锁的操作    time.sleep(20)if __name__ == &quot;__main__&quot;:    myfunc()\n 29. 写一段 Python 使用 Mongo 数据库创建索引的代码。\n#!/usr/bin/python3# coding=utf-8import pymongofrom pymongo import ASCENDING, DESCENDING# 连接数据库，创建连接对象myclient = pymongo.MongoClient(mongodbUrl)# 切换数据库mydb = myclient[dbName]# 创建索引，create_index()创建索引，可以有多个约束条件，值为1则升序，-1是降序mydb.create_index([(&quot;date&quot;, DESCENDING), (&quot;author&quot;, ASCENDING)])\n 高级特性\n 1. 函数装饰器有什么作用？请列举说明？\n装饰器主要是在不修改代码前提下进行功能的扩展，满足面向对象的“开闭原则”。\n\n应用场景：\n\n\n引入日志\n函数执行时间统计\n执行函数前预备处理\n执行函数后清理功能\n权限校验等场景\n缓存\n事务处理\n\n 2. Python 垃圾回收机制？\n引用计数为主，标记清除和分代回收为辅：\n 整数\n\n小整数：Python 对小整数的定义是 [-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象。单个字母同样也是如此。\n大整数：每一个大整数的创建均在内存中会分配一个内存空间，所以大整数的内存空间是需要被回收的。\n\n 引用计数：\npython里每一个东西都是对象，它们的核心就是一个结构体：PyObject\nPyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少当引用计数为0时，该对象生命就结束了。\n\n\n\n优点\n缺点\n\n\n\n\n简单\n维护引用计数消耗资源\n\n\n实时性*\n循环引用\n\n\n\n\n*实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。\n\n 3. 魔法函数 __call__ 怎么使用?\n\n__call__允许一个类的实例像函数一样被调用\n\n#!/usr/bin/python3# coding=utf-8class Entity(object):    def __init__(self, size, x, y):        self.x, self.y = x, y        self.size = size    def __call__(self, x, y):        # 改变实例属性        self.x, self.y = x, yif __name__ == &#x27;__main__&#x27;:    # 创建实例    demo_obj = Entity(1, 2, 3)    # 实例可以像函数那样执行，并传入x y值，修改对象的x y    demo_obj(4, 5)\n 4. 如何判断一个对象是函数还是方法？\n\n使用isinstance()判断\n声明def\n\n类外声明def为函数\n类中声明def：\n\n使用类调用的为函数\n使用实例化对象调用的为方法\n\n\n\n\n摘自马玉刚的博客\n\n从分类的角度\n\n\n函数的分类：\n\n内置函数\n匿名函数\n递归函数\n自定义函数\n\n\n方法的分类\n\n普通方法：直接用self调用的方法。\n私有方法：__函数名，只能在类中被调用的方法。\n属性方法：@property，将方法伪装成为属性，让代码看起来更合理。\n特殊方法(双下划线方法)：以__init__为例，是用来封装实例化对象的属性，只要是实例化对象就一定会执行__init__方法，如果对象子类中没有则会寻找父类（超类），如果父类（超类）也没有，则直接继承object（python 3.x）类，执行类中的__init__方法。\n类方法：通过类名的调用去操作公共模板中的属性和方法。\n静态方法：不用传入类空间、对象的方法， 作用是保证代码的一致性，规范性，可以完全独立类外的一个方法，但是为了代码的一致性统一的放到某个模块（py文件）中。\n\n\n\n\n从作用域的角度\n\n\n函数作用域：从函数调用开始至函数执行完成，返回给调用者后，在执行过程中开辟的空间会自动释放，也就是说函数执行完成后，函数体内部通过赋值等方式修改变量的值不会保留，会随着返回给调用者后，开辟的空间会自动释放。\n方法作用域：通过实例化的对象进行方法的调用，调用后开辟的空间不会释放，也就是说调用方法中对变量的修改值会一直保留。\n\n\n从调用的方式\n\n\n函数：通过类.函数名()的方式进行调用\n方法：通过实例化对象.方法名()的方式进行调用。\n\n\n\n 5. @classmethod 和@staticmethod 用法和区别\n\n@classmethod 是类方法：访问和修改类属性，进行类相关的操作，通过类或示例对象调用，需要传递cls类对象为参数；\n@staticmethod 是静态方法：不访问类属性和实例属性，通过类或实例调用，相当于一个普通函数。\n\n 6. Python 中的接口如何实现？\n摘自终结大笨狗的博客#python中接口实现#\n\n用抽象类和抽象函数实现接口\n\n#抽象类加抽象方法就等于面向对象编程中的接口from abc import ABCMeta,abstractmethodclass interface(object):    __metaclass__ = ABCMeta #指定这是一个抽象类    @abstractmethod  #抽象方法    def Lee(self):        pass    def Marlon(self):        passclass RelalizeInterfaceLee(interface):#必须实现interface中的所有函数，否则会编译错误    def __init__(self):            print &#x27;这是接口interface的实现&#x27;    def Lee(self):        print &#x27;实现Lee功能&#x27;            def Marlon(self):        pass   class RelalizeInterfaceMarlon(interface): #必须实现interface中的所有函数，否则会编译错误    def __init__(self):            print &#x27;这是接口interface的实现&#x27;    def Lee(self):        pass          def Marlon(self):        print &quot;实现Marlon功能&quot;\n\n用普通类定义接口\n\nclass interface(object): #假设这就是一个接口，接口名可以随意定义，所有的子类不需要实现在这个类中的函数    def Lee(self):，        pass    def Marlon(self):        passclass Realaize_interface(interface):    def __init__(self):        pass    def Lee(self):        print &quot;实现接口中的Lee函数&quot;class Realaize_interface2(interface):    def __init__(self):        pass    def Marlon(self):        print &quot;实现接口中的Marlon函数&quot;obj=Realaize_interface()obj.Lee()obj=Realaize_interface2()obj.Marlon()\n 7. Python 中的反射了解么?\n\n计算机中的反射，是在运行的时候来自我检查，并对内部成员进行操作。就是说这个变量的类型可以动态的改变，在运行的时候确定它的作用。\n\n反射是指程序可以访问。检测和修改它本身状态或行为的一种能力（自省）。\n在Python中，能够通过一个对象，找出其type、class、attribute或method的能力，称为反射或自省。\n具有反射能力的函数有type()，isinstance()，callable()，dir()，getattr()，hasattr()，setattr()，delattr()，__import__()等。\n反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！\n 8. metaclass 作用？以及应用场景？[重难点]\nmetaclass 元类是Python中非常具有魔术性的对象，可以动态的定制或修改继承它的子类。由于太过于灵活，改日另起一篇。\n三个重点：__new__,__init__,__call__.\n扩展链接:\n\n廖雪峰-使用元类\n\nclass Mymeta(type):    def __init__(self, name, bases, dic):        super().__init__(name, bases, dic)        print(&#x27;===&gt;Mymeta.__init__&#x27;)        print(self.__name__)        print(dic)        print(self.yaml_tag)    def __new__(cls, *args, **kwargs):        print(&#x27;===&gt;Mymeta.__new__&#x27;)        print(cls.__name__)        return type.__new__(cls, *args, **kwargs)    def __call__(cls, *args, **kwargs):        print(&#x27;===&gt;Mymeta.__call__&#x27;)        obj = cls.__new__(cls)        cls.__init__(cls, *args, **kwargs)        return objclass Foo(metaclass=Mymeta):    yaml_tag = &#x27;!Foo&#x27;    def __init__(self, name):        print(&#x27;Foo.__init__&#x27;)        self.name = name    def __new__(cls, *args, **kwargs):        print(&#x27;Foo.__new__&#x27;)        return object.__new__(cls)&#x27;&#x27;&#x27;输出===&gt;Mymeta.__new__Mymeta===&gt;Mymeta.__init__Foo&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;Foo&#x27;, &#x27;yaml_tag&#x27;: &#x27;!Foo&#x27;, &#x27;__init__&#x27;: &lt;function Foo.__init__ at 0x0000000007EF3828&gt;, &#x27;__new__&#x27;: &lt;function Foo.__new__ at 0x0000000007EF3558&gt;&#125;!Foo&#x27;&#x27;&#x27;foo = Foo(&#x27;foo&#x27;)&#x27;&#x27;&#x27;输出===&gt;Mymeta.__call__Foo.__new__Foo.__init__&#x27;&#x27;&#x27;\n正常情况下我们在父类中是不能对子类的属性进行操作，但是元类可以。换种方式理解：元类、装饰器、类装饰器都可以归为元编程。\n 9. hasattr() getattr() setattr()的用法\n这三种方法用于为对象属性的存在判断、获取和添加修改。\nclass A():    name = &#x27;python&#x27;    def func(self):        return &#x27;A()类的方法func()&#x27;if __name__ == &#x27;__main__&#x27;:    print(hasattr(A, &#x27;name&#x27;))  # True    print(hasattr(A, &#x27;func&#x27;))  # True    print(hasattr(A, &#x27;age&#x27;))   # False        print(getattr(A, &#x27;name&#x27;))  # &#x27;python&#x27;    print(getattr(A, &#x27;func&#x27;))  # &lt;function A.func at 0x000XXX&gt;    print(getattr(A(),&#x27;func&#x27;)) # &#x27;A()类的方法func()&#x27;    print(getattr(A,&#x27;age&#x27;))    # AttributeError        setattr(A, &#x27;name&#x27;, &#x27;java&#x27;)    print(getattr(A, &#x27;name&#x27;))  # &#x27;java&#x27;    setattr(A, &#x27;age&#x27;, 20)    print(getattr(A, &quot;age&quot;))    # 20\n 10. 请列举你知道的 Python 的魔法方法及用途。\n\n魔法方法，即dunder method，是以&quot;__&quot;包起来的方法。\n\n\n__new__：是用来创建类并返回这个类的实例,\n__init__：将传入的参数来初始化该实例，以及初始化示例属性，与__new__共同构成了“构造函数”\n__del__：将实例化后的对象销毁，即为析构函数\n__call__：允许一个类像函数一样被调用\n__getattr__：访问对象不存在的属性时，调用该方法，用于定义访问行为\n__setattr__：设置对象属性时调用\n__delattr__：删除对象属性时调用\n__enter__和__exit__： 上下文管理器\n__iter__：返回一个容器迭代器，很多情况下会返回迭代器，尤其是当内置的iter()方法被调用的时候，以及当使用for x in container:方式循环的时候。迭代器是它们本身的对象，它们必须定义返回self的__iter__方法。\n__next__：返回迭代器的下一个元素\n\n 11. 如何知道一个 Python 对象的类型？\n用type()判断对象类型\n 12. Python 的传参是传值还是传址？\n结论先行：Python 对可变对象（字典或列表）传址，对不可变对象（数字、字符或元祖）传值。\n 13. Python 中的元类(metaclass)使用举例\nmetaclass上文有提到\n 14. 简述 any()和 all()方法\nany()判断 一个可迭代对象 存在不为空的元素，返回True；空列表和空元祖为False；\nall()判断 一个可迭代对象 全部的元素不为空，返回True；空列表和空元祖为True。\n 15. filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\na = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlist(filter(lambda x: x % 2 == 1, a))\n 16. 什么是猴子补丁？\n猴子补丁的含义是指在动态语言中，不去改变源码而对功能进行追加和变更。\n举个栗子:\n\n之前做的一个游戏服务器,很多地方用的import json,后来发现ujson比自带json快了N倍,于是问题来了,难道几十个文件要一个个把import json改成import ujson as json吗?\n其实只需要在进程startup的地方monkey patch就行了.是影响整个进程空间的.\n同一进程空间中一个module只会被运行一次.\n\nimport jsonimport ujsondef monkey_patch_json():    json.__name__ = &#x27;ujson&#x27;    json.dumps = ujson.dumps    json.loads = ujson.loadsmonkey_patch_json()\n 17. 在 Python 中是如何管理内存的？\nPython内存池：内存池的概念就是预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。\npython中的内存管理机制——Pymalloc：python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new/malloc的行为来申请内存空间。\n内存释放: 参考垃圾回收\n 18. 当退出 Python 时是否释放所有内存分配？\n那些具有对象循环引用或者全局命名空间引用的变量，在 Python 退出是往往不会被释放。另外不会释放 C 库保留的部分内容。\n 正则表达式\n正则表达式可视化\n对正则表达式进行解释\n 1. 使用正则表达式匹配出中的地址 a=“张明 98 分”，用 re.sub，将 98 替换为 100\nimport rehtml_str = &#x27;&lt;html&gt;&lt;h1&gt;&lt;div&gt;a=&quot;张明 98 分&quot;&lt;/div&gt;&lt;/html&gt;&#x27;result_str = re.sub(r&#x27;\\d&#123;2&#125;&#x27;, &quot;100&quot;, html_str)print(result_str)\n 2. 正则表达式匹配中(.*)和(.*?)匹配区别？\n\n贪婪匹配在匹配字符串时总是尝试匹配尽可能多的字符\n非贪婪匹配在匹配字符串时总是尝试匹配尽可能少的字符。\nPython里数量词默认是贪婪模式的，在&quot;*“,”?“,”+“,”{m,n}&quot;后面加上？，可使贪婪模式变成非贪婪模式。\n\n 3. 写一段匹配邮箱的正则表达式\nimport restr1 = &#x27;fdg.123@163.cn  hdfh.abc@qq.com  hidfsd@qq.com gfgfa@qq.net  bdfdg@163.com&#x27;reg_str1 = r&#x27;([\\w]+(\\.[\\w]+)*@[\\w]+(\\.[\\w]+)+)&#x27;mod = re.compile(reg_str1)items = mod.findall(str1)for item in items:    print(item)\n 其他内容\n 1. 解释一下 python 中 pass 语句的作用？\n空语句，是为了保持程序结构的完整性；\npass不做任何事情，一般用做占位语句；\n一般在搭建程序框架的时候或在判断语句中使用。\n 2. 简述你对 input()函数的理解\n\nPython3.x: input()函数接受一个标准输入数据，返回为字符串类型\nPython2.x: input() 需要输入 python 表达式。比如程序中有语句a = input(&quot;input:&quot;)，当输入 runoob会报错，此时 runoob 解释成一个变量，而&quot;runoob&quot;不会报错。\nPython2.x: raw_input() 将所有输入作为字符串看待\n\n 3. python 中的 is 和==\nis 是身份运算符，判断两个对象的内存id是否相等\n== 是比较运算符，判断两个对象的值是否相等\n进行值比较的时候使用==，判断是否是同一对象的时候使用is\n 4. Python 中的作用域\nL （Local） 局部作用域\nE （Enclosing） 闭包函数外的函数中\nG （Global） 全局作用域\nB （Built-in） 内建作用域\n以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。\n 5. 三元运算写法和应用场景？\n三元运算符就是在赋值变量的时候，可以直接加判断，然后赋值格式\n条件为真时的结果 if 判段的条件 else 条件为假时的结果\n#先定义变量：a,b = 1,2#第一种写法：erroStr = &quot;More&quot; if a &gt; b else &quot;Less&quot;print(erroStr) # 运行结果为：Less#第二种写法：print(&#123;True: &quot;More&quot;, False: &quot;Less&quot;&#125;[a &gt; b]) # 运行结果为：Less#第三种写法：print((&quot;FalseValue&quot;, &quot;TrueValue&quot;)[a &gt; b]) # 运行结果为：FalseValue\n其中我们比较常见的是第一种。\n第二三种是挺简洁的，但是写在项目里怕是接手的同事要抓狂了。\n 6. 了解 enumerate 么？\n\nenumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n\n语法:\nenumerate(sequence, [start=0])\n\n 7. 列举 5 个 Python 中的标准模块\n参见：常用 Python 标准库\n 8. 如何在函数中设置一个全局变量\n使用global\n 9. pathlib 的用法举例\npathlib 模块提供了一组面向对象的类，这些类可代表各种操作系统上的路径，程序可通过这些类操作路径。\nfrom pathlib import Path# 1.查看路径# 使用cmd()方法输出当前的工作目录# 使用home()输出用户的主目录now_path = Path.cwd()home_path = Path.home()print(&quot;当前工作目录&quot;, now_path, type(now_path))print(&quot;home目录&quot;, home_path, type(home_path))# 2. 路径拼接# 将字符串转为Pathlib.Path类型# 使用 &quot;/&quot; 直接拼接路径dir_path = Path(r&quot;D:\\code\\web&quot;) / &quot;flaskweb&quot;print(dir_path, type(dir_path))# 3.读写文件# 使用基础的open()函数demo_file = Path.cwd() / &#x27;test.md&#x27;with open(demo_file, mode=&#x27;r&#x27;) as fid:    file_data = fid.read()print(file_data)&quot;&quot;&quot;使用pathlib的open()方法这样写的好处就是open里面我们不需要再去传入路径了，直接指定文件读写模式即可。实际上这里的open方法，底层也是调用了os.open的方法。使用哪种方式看个人的喜好。也可以不使用with open的形式即可以进行读写.read_text(): 找到对应的路径然后打开文件，读成str格式。等同open操作文件的&quot;r&quot;格式。.read_bytes(): 读取字节流的方式。等同open操作文件的&quot;rb&quot;格式。.write_text(): 文件的写的操作，等同open操作文件的&quot;w&quot;格式。.write_bytes(): 文件的写的操作，等同open操作文件的&quot;wb&quot;格式&quot;&quot;&quot;demo_file = Path.cwd() / &#x27;test.md&#x27;with demo_file.open(&quot;r&quot;) as fid:    file_data = fid.read()print(file_data)# 4.使用resolve可以通过传入文件名，来返回文件的完整路径# 需要注意的是&quot;demo.py&quot;文件要和我当前的程序文件在同一级目录。py_path =Path(&quot;demo.py&quot;)print(py_path.resolve())\nCSDN-Pathlib模块\nPython文档-shutil 高阶文件操作\n 10. Python 中的异常处理，写一个简单的应用场景\n参见：写一段自定义异常代码\n参见：异常模块中 try except else finally 的相关意义\n 11. Python 中递归的最大次数，那如何突破呢？\n最大次数为1000次\nTAIL CALL OPTIMIZATION DECORATOR\n一脸懵逼\n 12. 什么是面向对象的 mro\nMRO：Method Resolution Order(方法解析顺序)\nMRO就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。\nMRO 是在Python多继承和钻石继承问题上的核心内容，它规定了如何，什么时候，怎么样去 调用父类的方法\n# 输出类的解析继承关系顺序：类名.__mro__DemoClass.__mro__\n 13. isinstance 作用以及应用场景？\nisinstance：判断对象是否是一个已知的类型\nisinstance(object, classinfo)\n\nobject – 实例对象。\nclassinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。\n\n使用场景举例：\n\n判断对象的数据类型，如参数和返回值判断，根据不同的数据类型\n判断类的继承关系，isinstance可以用作判断是否继承了某个父类\n\n拓展：type和isinstance\n\ntype只输出当前类名，不管继承关系\nisinstance在使用当前类的父类做判断时，输出为True（多重继承适用）\n\nclass A:    pass class B(A):    pass isinstance(A(), A)    # returns Truetype(A()) == A        # returns Trueisinstance(B(), A)    # returns Truetype(B()) == A        # returns False\n 14. 什么是断言？应用场景？\n断言语句是将调试断言插入程序的便捷方式\nassert condition：在condition为True时不触发，False触发AssertionError错误\n&gt;&gt;&gt; assert 1==1&gt;&gt;&gt; assert 1==0Traceback (most recent call last):  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;    assert 1==0AssertionError\n如果没有特别的目的，断言应该用于如下情况：\n\n防御性的编程\n运行时对程序逻辑的检测\n合约性检查（比如前置条件，后置条件）\n程序中的常量\n检查文档\n\n 15. lambda 表达式格式以及应用场景？\nlambda表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。\nlambda表达式：lambda 参数1，参数2...: 参数表达式\n\n适用场景：\n\n简单功能的函数实现\n不需要关注函数命名\n复用性不高或只用一次的函数\n\n# 输出1到100内的奇数 filder和lambda的组合print(list(filter(lambda x: x % 2 == 1, range(1, 101))))# 列表的排序：按照绝对值大小排序# sorted和lambda也是很好的组合，这里的abs是绝对值函数list_demo = [3, 5, -4, -1, 0, -2, -6]print(sorted(list_demo, key=lambda x: abs(x)))# 闭包lambdadef get_y(a, b):    return lambda x: a*x + by1 = get_y(3, 1)print(y1(1))  # 结果为4\n 16. 新式类和旧式类的区别\n新式类旧式类在Python 3.x中取消了经典类，默认都是新式类，并且不必显式的继承object，也就是说：\n\nclass Person(object):pass\nclass Person():pass\nclass Person:pass\n三种写法并无区别，推荐第一种\n\nclass Person(object):pass 新式类写法\nclass Person():pass 经典类写法\nclass Person:pass 经典类写法\n\n新式类和经典类的最大的区别：继承搜索顺寻的变化\n\n新式类多继承搜索顺序(广度优先)：先在水平方向查找，然后再向上查找\n经典类多继承搜索顺序(深度优先)：先深入继承树左侧查找，然后再返回，开始查找右侧\n\n\n\ngraph TD\nA[ 基类 A  ] --&gt; C[ C ]\nA --&gt; B[ B ]\nB --&gt; D[ D ]\nC --&gt; D[ D ]\n\n\n 17. dir()是干什么用的？\ndir()函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；\n带参数时，返回参数的属性、方法列表。\n如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。\n 18. 一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。\n包(package)，本质来说就是一个文件夹，但是其中有一个 init .py文件。\n包是从逻辑上来组织模块的，也就是说它是用来存放模块的，如果想导入其他目录下的模块，那么这个目录必须是一个包才可以导入。\n在本题中 tools 包下有 demo1.py, demo2.py, demo3.py 和 __init__.py 四个文件，我们只需要在 init 文件中写：\nfrom . import demo1from . import demo3from .demo2 import *\n 19. 列举 5 个 Python 中的异常类型以及其含义\nBaseException  # 所有异常的基类 +-- SystemExit  # 解释器请求退出 +-- KeyboardInterrupt  # 用户中断执行(通常是输入^C) +-- GeneratorExit  # 生成器(generator)发生异常来通知退出 +-- Exception  # 常规异常的基类      +-- StopIteration  # 迭代器没有更多的值      +-- StopAsyncIteration  # 必须通过异步迭代器对象的__anext__()方法引发以停止迭代      +-- ArithmeticError  # 各种算术错误引发的内置异常的基类      |    +-- FloatingPointError  # 浮点计算错误      |    +-- OverflowError  # 数值运算结果太大无法表示      |    +-- ZeroDivisionError  # 除(或取模)零 (所有数据类型)      +-- AssertionError  # 当assert语句失败时引发      +-- AttributeError  # 属性引用或赋值失败      +-- BufferError  # 无法执行与缓冲区相关的操作时引发      +-- EOFError  # 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发      +-- ImportError  # 导入模块/对象失败      |    +-- ModuleNotFoundError  # 无法找到模块或在在sys.modules中找到None      +-- LookupError  # 映射或序列上使用的键或索引无效时引发的异常的基类      |    +-- IndexError  # 序列中没有此索引(index)      |    +-- KeyError  # 映射中没有这个键      +-- MemoryError  # 内存溢出错误(对于Python 解释器不是致命的)      +-- NameError  # 未声明/初始化对象 (没有属性)      |    +-- UnboundLocalError  # 访问未初始化的本地变量      +-- OSError  # 操作系统错误，EnvironmentError，IOError，WindowsError，socket.error，select.error和mmap.error已合并到OSError中，构造函数可能返回子类      |    +-- BlockingIOError  # 操作将阻塞对象(e.g. socket)设置为非阻塞操作      |    +-- ChildProcessError  # 在子进程上的操作失败      |    +-- ConnectionError  # 与连接相关的异常的基类      |    |    +-- BrokenPipeError  # 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入      |    |    +-- ConnectionAbortedError  # 连接尝试被对等方中止      |    |    +-- ConnectionRefusedError  # 连接尝试被对等方拒绝      |    |    +-- ConnectionResetError    # 连接由对等方重置      |    +-- FileExistsError  # 创建已存在的文件或目录      |    +-- FileNotFoundError  # 请求不存在的文件或目录      |    +-- InterruptedError  # 系统调用被输入信号中断      |    +-- IsADirectoryError  # 在目录上请求文件操作(例如 os.remove())      |    +-- NotADirectoryError  # 在不是目录的事物上请求目录操作(例如 os.listdir())      |    +-- PermissionError  # 尝试在没有足够访问权限的情况下运行操作      |    +-- ProcessLookupError  # 给定进程不存在      |    +-- TimeoutError  # 系统函数在系统级别超时      +-- ReferenceError  # weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象      +-- RuntimeError  # 在检测到不属于任何其他类别的错误时触发      |    +-- NotImplementedError  # 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现      |    +-- RecursionError  # 解释器检测到超出最大递归深度      +-- SyntaxError  # Python 语法错误      |    +-- IndentationError  # 缩进错误      |         +-- TabError  # Tab和空格混用      +-- SystemError  # 解释器发现内部错误      +-- TypeError  # 操作或函数应用于不适当类型的对象      +-- ValueError  # 操作或函数接收到具有正确类型但值不合适的参数      |    +-- UnicodeError  # 发生与Unicode相关的编码或解码错误      |         +-- UnicodeDecodeError  # Unicode解码错误      |         +-- UnicodeEncodeError  # Unicode编码错误      |         +-- UnicodeTranslateError  # Unicode转码错误      +-- Warning  # 警告的基类           +-- DeprecationWarning  # 有关已弃用功能的警告的基类           +-- PendingDeprecationWarning  # 有关不推荐使用功能的警告的基类           +-- RuntimeWarning  # 有关可疑的运行时行为的警告的基类           +-- SyntaxWarning  # 关于可疑语法警告的基类           +-- UserWarning  # 用户代码生成警告的基类           +-- FutureWarning  # 有关已弃用功能的警告的基类           +-- ImportWarning  # 关于模块导入时可能出错的警告的基类           +-- UnicodeWarning  # 与Unicode相关的警告的基类           +-- BytesWarning  # 与bytes和bytearray相关的警告的基类           +-- ResourceWarning  # 与资源使用相关的警告的基类。被默认警告过滤器忽略。\n 20. copy 和 deepcopy 的区别是什么？\na = [1,[2,3]]b = a # 引用 a变b变c = copy.copy(a) # 浅复制 复制子对象的引用 d = copy.deepopy(a) # 深复制 复制子对象的副本# copy模块的信息help(copy)\npython 文档\n\n两者区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关：\n\n一个 浅层复制 会构造一个新的复合对象，然后（在可能的范围内）将原对象中找到的 引用 插入其中。\n一个 深层复制 会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的 副本 插入。\n\n深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：\n\n递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。\n由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。\n\nPython的深度复制操作通过以下方式避免了上面俩问题：\na）保留一个字典，这个字典是在当前复制过程中已复制的对象的 “备忘录” (memo) 字典\nb）允许用户定义的类重载复制操作或复制的组件集合\n该模块不复制模块、类、函数、方法、栈追踪（stack trace）、栈帧（stack frame）、文件、套接字、窗口、数组或任何类似类型的类型。\n制作字典的浅层复制可以使用 dict.copy() 方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如， &gt; copied_list = original_list[:] 。\n\n 21. 代码中经常遇到的*args, **kwargs 含义及用法。\n\nargs 是 arguments 的缩写，表示位置参数；\nkwargs 是 keyword arguments 的缩写，表示关键字参数\n\ndef demo_func(*args, **kwargs):    # arg是一个元祖类型    print(args[1])    # kwargs是一个字典类型    print(kwargs.keys())if __name__ == &#x27;__main__&#x27;:    # 直接传参，但关键字类型必须为str    demo_func(1, 2, 3, a=1, b=2)    # 使用*和**进行解包    demo_func(*(1, 2, 3), **&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;)\n 22. Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?\n\n单下划线\n单下划线开头的命名方式被常用于模块中，在一个模块中以单下划线开头的变量和方法会被默认划入模块内部范围。\n当使用 from my_module import * 导入时，单下划线开头的变量和方法是不会被导入的。\n但使用 import my_module 导入的话，仍然可以用 my_module._var 这样的形式访问属性或方法。单下划线结尾的命名方式也存在，但是不常用，其实也不推荐用。这种命名方式的作用就是为了和 python 的一些内置关键词区分开来，假设我们想给一个变量命名为 class，但是这会跟 python 的关键词 class 冲突，所以我们只好退一步使用单下划线结尾命名，也就是 class_。双下划线双下划线开头和结尾的是一些 python 的“魔术”对象，如类成员的 __init__、__del__、__add__、__getitem__ 等，以及全局的__file__、__name__ 等。 python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。双下划线开头的命名方式有实际的作用，采用这种命名的变量或方法无法直接通过 “对象名.变量名（方法名）” 这样的方式访问。\n\n 23. w、a+、wb 文件写入模式的区别\n\nr : 读取文件，若文件不存在则会报错\nw: 写入文件，若文件不存在则会先创建再写入，会覆盖原文件\na : 写入文件，若文件不存在则会先创建再写入，但不会覆盖原文件，而是追加在文件末尾\nrb,wb：分别于r,w类似，用于读写二进制文件\nr+ : 可读、可写，文件不存在也会报错，写操作时会覆盖\nw+ : 可读，可写，文件不存在先创建，会覆盖\na+ ：可读、可写，文件不存在先创建，不会覆盖，追加在末尾\n\n 24. 举例 sort 和 sorted 的区别\nsorted是一个函数，返回一个新的list\nsort是实例方法，直接作用在list本身，没有返回新的list\ndemo_list = [1, 3, 4, 2, 7, 5]result_list = sorted(demo_list)print(result_list)demo_list.sort()print(demo_list)\n 25. 什么是负索引？\n负索引是指使用负数做为索引，-1代表数组的最后一位\n 26. pprint 模块是干什么的？\npprint用于输出一个整齐美观Python数据的结构\nimport pprintdemo_list = [str(i)*20 for i in range(10)]pp_object = pprint.PrettyPrinter(indent=4) # indent 是指句首缩进pp_object.pprint(demo_list)  # 整齐输出print(demo_list)             # 只输出一行\n 27. 解释一下 Python 中的赋值运算符\n赋值运算符包括：= 加+= 减-= 乘*= 除/= 取模%= 幂**= 取整除//=\n 28. 解释一下 Python 中的逻辑运算符\n逻辑运算符包括：与and 或or 非nor\n 29. 讲讲 Python 中的位运算符\n位运算符包括：按位与&amp; 按位或| 按位异或^ 按位取反~ 左移动&lt;&lt; 右移动&gt;&gt;\n 30. 在 Python 中如何使用多进制数字？\n二进制前缀 0b或0B\n八进制前缀 0o或0O\n十六进制前缀 0x或0X\nint(0b1010) # 10int(0o10) # 8int(0xf) # 15bin(15) # &#x27;0b1111&#x27;oct(15) # &#x27;0o17&#x27;hex(15) # &#x27;0xf&#x27;\n 31. 怎样声明多个变量并赋值？\na, b = 1, 2\n 算法和数据结构\n 1. 已知：\nAList = [1,2,3]BSet = &#123;1,2,3&#125;\n(1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？\n(2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？\n\npython的列表内部实现是数组（具体实现要看解析器, CPython的实现 ），因此就有数组的特点。超过容量会增加更多的容量，set, get 是O(1)，但del, insert, in的性能是O(n)。\n关于字典需要了解的是hash函数和哈希桶。一个好的hash函数使到哈希桶中的值只有一个，若多个key hash到了同一个哈希桶中，称之为哈希冲突。查找值时，会先定位到哈希桶中，再遍历hash桶。在hash基本没有冲突的情况下get, set, delete, in方面都是O(1)。\n集合内部实现是dict的。在in操作上是O(1), 这一点比list要强。\n\n所以答案是\n\n查找操作set优于list；\n插入操作两个相同；\n\n 2. 用 Python 实现一个二分查找的函数\ndef binary_Search(search_list: list, search_num: int):    &quot;&quot;&quot;二分查找    利用二分法找到list数组中的值    :param search_list: 目标list    :param search_num: 待查询值    :return:    &quot;&quot;&quot;    # 最小的下标    min_index = 0    # 最大的下标    max_index = len(search_list) - 1    # 查找次数    count = 0    while True:        # 中间的下标每次向下取整        mid_index = (min_index + max_index) // 2        if search_num &gt; search_list[mid_index]:            # 小于需要的猜的数，则将最小下标变为中间的，因为中间的已经猜过，所以要加1            min_index = mid_index + 1        elif search_num &lt; search_list[mid_index]:            # 大于需要的猜的数，则将最大下标变为中间的，因为中间的已经猜过，所以要减1            max_index = mid_index - 1        else:            print(&quot;找到数据&quot;, &quot;索引是&#123;&#125;&quot;.format(mid_index))            print(&quot;一共查找&#123;&#125;次&quot;.format(count))            break        # 索引值加一        print(f&quot;&#123;search_num&#125; 与 &#123;search_list[mid_index]&#125; 相比较&quot;)        count += 1if __name__ == &quot;__main__&quot;:    list1 = [i for i in range(0, 1000)]    num = 0    binary_Search(list1, num)\n 3. python 单例模式的实现方法\n应用单例模式的类只会生成一个实例：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。\n下面是使用四种方式实现单例模式：原文链接\n\n使用函数装饰器实现单例  def singleton(cls):    _instance = &#123;&#125;    def inner():        if cls not in _instance:            _instance[cls] = cls()        return _instance[cls]    return inner    @singletonclass Cls(object):    def __init__(self):        passcls1 = Cls()cls2 = Cls()print(id(cls1) == id(cls2))\n\n使用类装饰器实现单例  class Singleton(object):    def __init__(self, cls):        self._cls = cls        self._instance = &#123;&#125;    def __call__(self):        if self._cls not in self._instance:            self._instance[self._cls] = self._cls()        return self._instance[self._cls]@Singletonclass Cls2(object):    def __init__(self):        passcls1 = Cls2()cls2 = Cls2()print(id(cls1) == id(cls2))# 同样也可以用下面的方式class Cls3():    passCls3 = Singleton(Cls3)cls3 = Cls3()cls4 = Cls3()print(id(cls3) == id(cls4))\n\n使用 new 关键字实现单例  class Single(object):    _instance = None    def __new__(cls, *args, **kw):        if cls._instance is None:            cls._instance = object.__new__(cls, *args, **kw)        return cls._instance    def __init__(self):        passsingle1 = Single()single2 = Single()print(id(single1) == id(single2))\n\n使用 metaclass 实现单例  class Singleton(type):    _instances = &#123;&#125;    def __call__(cls, *args, **kwargs):        if cls not in cls._instances:            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)        return cls._instances[cls]class Cls4(metaclass=Singleton):    passcls1 = Cls4()cls2 = Cls4()print(id(cls1) == id(cls2))\n\n\n 4. 使用 Python 实现一个斐波那契数列\ndef fbnq(num):    &quot;&quot;&quot;斐波那契生成器    :param num: 生产数量    :return: 斐波那契迭代器    &quot;&quot;&quot;    a, b = 1, 1    for _ in range(num):        a, b = b, a+b        yield aif __name__ == &#x27;__main__&#x27;:    gener = fbnq(20)    print(list(gener))    for i in gener:        print(i)\n 5. 找出列表中的重复数字\n# 统计每个数字个数from collections import Counterresult = Counter([1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4])print(result)# \n 6. 找出列表中的单个数字\n同上\n 7. 写一个冒泡排序\ndef bubble_sort(parm_list):    for n in range(len(parm_list)):        for m in range(len(parm_list) -n -1):            if parm_list[m] &gt; parm_list[m +1]:                parm_list[m], parm_list[m +1] = parm_list[m +1], parm_list[m]    return parm_list\n 8. 写一个快速排序\n快排:\n每次选取第一个值为基准值，再把列表中比基准值大的组成新列表，小的组成另一个新列表，再次对两个新列表进行操作，直到新列表为空\ndef quick_sort(parm_list):    if not parm_list:        return []    else:        pivot = parm_list[0]        # 利用递归每次找出大于和小于基准值得两个新列表        lesser = quick_sort([x for x in parm_list[1:] if x &lt; pivot])        greater = quick_sort([x for x in parm_list[1:] if x &gt;= pivot])        # 最后将排列好的值相加        return lesser + [pivot] + greater\n 9. 写一个拓扑排序\ndef topology_sort(relation_parm):    &quot;&quot;&quot;简单拓扑排序    简单实现拓扑排序算法，不考虑时间复杂度    :param relation_parm: 拓扑关系字典参数    :return: 排序后结果    &quot;&quot;&quot;    in_degrees = dict((u, 0) for u in relation_parm)            # 初始化所有顶点入度为0，转为字典类型    vertex_num = len(in_degrees)                                # 字典键值个数    for key in relation_parm:                                   # 遍历关系参数字典，求出每个顶点的入度值        for value in relation_parm[key]:                        # 遍历每个键的值，将关系其他顶点的键值+1到in_degrees字典中            in_degrees[value] += 1                              # 计算每个顶点的入度    zero_list = [u for u in in_degrees if in_degrees[u] == 0]   # 筛选入度为0的顶点    result_list = []                                            # 创建结果空列表    while zero_list:                                            # 循环判断列表为空        last_zero = zero_list.pop()                             # 删除最后一个入度为0的对象        result_list.append(last_zero)                           # 结构列表添加刚删除的对象        for zero_value in relation_parm[last_zero]:             # 遍历以入度为0作为键的字典值            in_degrees[zero_value] -= 1                         # 和last_zero有关系的键值-1            if in_degrees[zero_value] == 0:                     # 判断-1过后的键值是否为0                zero_list.append(zero_value)                    # 再次筛选入度为0的顶点    if len(result_list) != vertex_num:                          # 如果循环结束后结果列表对象个数不等于原始键个数，说明存在环        print(&quot;there&#x27;s a circle.&quot;)    else:        return result_listrelation_dict = &#123;    &#x27;a&#x27;: &#x27;bcd&#x27;,    &#x27;b&#x27;: &#x27;&#x27;,    &#x27;c&#x27;: &#x27;be&#x27;,    &#x27;d&#x27;: &#x27;e&#x27;,    &#x27;e&#x27;: &#x27;&#x27;,    &#x27;f&#x27;: &#x27;de&#x27;&#125;print(topology_sort(relation_dict)) # [&#x27;f&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;b&#x27;]\n 11. python 实现一个二进制计算\n 12. 有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。\n 13. 单链表反转\n 14. 交叉链表求交点\n 15. 用队列实现栈\n 16. 找出数据流的中位数\n 17. 二叉搜索树中第 K 小的元素\n 爬虫相关\n 1. 在 requests 模块中，requests.content 和 requests.text 什么区别\n.content中间存的是字节码 .text存的是.content编码后的字符串\n 2. 简要写一下 lxml 模块的使用方法框架\nfrom lxml import etreetext = &#x27;&#x27;&#x27;&lt;div&gt;    &lt;ul&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;     &lt;/ul&gt; &lt;/div&gt;&#x27;&#x27;&#x27;htmlEmt = etree.HTML(text)result = etree.tostring(htmlEmt)\n 3. 说一说 scrapy 的工作流程\n\n首先Spiders（爬虫）将需要发送请求的url(requests)经ScrapyEngine（引擎）交给Scheduler（调度器）。\nScheduler（排序，入队）处理后，经ScrapyEngine，DownloaderMiddlewares(可选，主要有User_Agent, Proxy代理)交给Downloader。\nDownloader向互联网发送请求，并接收下载响应（response）。将响应（response）经ScrapyEngine，SpiderMiddlewares(可选)交给Spiders。\nSpiders处理response，提取数据并将数据经ScrapyEngine交给ItemPipeline保存（可以是本地，可以是数据库）。\n提取url重新经ScrapyEngine交给Scheduler进行下一个循环。直到无Url请求程序停止结束。\n\n 4. scrapy 的去重原理\n\nScrapy本身自带有一个中间件;\nscrapy源码中可以找到一个dupefilters.py去重器;\n需要将dont_filter设置为False开启去重，默认是false去重，改为True,就是没有开启去重；\n对于每一个url的请求，调度器都会根据请求得相关信息加密得到一个指纹信息，并且将指纹信息和set()集合中的指纹信息进 行 比对，如果set()集合中已经存在这个数据，就不在将这个Request放入队列中;\n如果set()集合中没有存在这个加密后的数据，就将这个Request对象放入队列中，等待被调度。\n\n 5. scrapy 中间件有几种类，你用过哪些中间件\nspider中间件（主职过滤）对Request、Response的主要作用在过滤，可以对特定路径的URL请求丢弃、对特定页面响应过滤、同时对一些不含有指定信息的item过滤，当然pipeline也能实现item的过滤。\n下载中间件（主职加工）主要作用是加工，如给Request添加代理、添加UA、添加cookie，对Response返回数据编码解码、压缩解压缩、格式化等预处理。\nuser-agend中间件、代理ip中间件、selenium中间件、cookie中间件\n 6. 你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？\n反爬策略1：通过UA限制或者其他头信息限制\n解决方案：构建用户代理池或其他头信息\n反爬策略2：通过访问者IP限制\n解决方案：构建IP代理池\n反爬策略3：通过验证码限制\n解决方案：手工打码、验证码接口自动识别或者通过机器学习自动识别\n反爬策略4：通过数据的异步加载限制\n解决方案：抓包分析或者使用PhantomJS\n反爬策略5：通过Cookie限制\n解决方案：进行Cookie处理\n反爬策略6：通过JS限制（如请求的数据通过JS随机生成等）解决方案：分析JS解密或者使用PhantomJS\n 7. 为什么会用到代理？\n网站采取了反爬虫措施——限制IP的访问，这时就用到了代理IP，将本机的IP伪装起来，通过代理服务器发送请求。\n 8. 代理失效了怎么处理？\n换一个？！用代理池？\n 9. 列出你知道 header 的内容以及信息\n主要的请求方式GET和POST\nHost: 请求的Web服务器地址\nUser-Agent: 客户端浏览器信息\nAccept: 客户端能够接收的内容类型\n 10. 说一说打开浏览器访问 百度一下，你就知道 获取到结果，整个流程。\n\n浏览器向 DNS 服务器发送 baidu.com 域名解析请求。\nDNS 服务器返回解析后的 ip 给客户端浏览器，浏览器想该 ip 发送⻚⾯请求。\nDNS 服务器接收到请求 后，查询该⻚⾯，并将⻚⾯发送给客户端浏览器。\n客户端浏览器接收到⻚⾯后，解析⻚⾯中的引⽤，并再 次向服务器发送引⽤资源请求。\n服务器接收到资源请求后，查找并返回资源给客户端。\n客户端浏览器接收 到资源后，渲染，输出⻚⾯展现给⽤户。\n\n 11. 爬取速度过快出现了验证码怎么处理\n最好方法就是尽量避免遇到它，采集速度不要太快，短时间内不要过度频繁的访问一个网站，而是要表现得更像一个人，模拟人浏览网页的操作行为。\n将许多验证码解算器集成到他的爬虫系统中。如：验证码识别服务供应商 Death by CAPTCHA和Bypass CAPTCHA 都允许用户通过调用API服务来进行自动打码，从而在抓取数据过程中自动解决验证码。这些验证码解决工具可以处理普通的文本验证码，甚至是更高级的验证码\n 12. scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？\nScrapy 是一个通用的爬虫框架，但是不支持分布式.\nScrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)。\n 13. 分布式爬虫主要解决什么问题\n\nip\n带宽\ncpu\nio\n\n 14. 写爬虫是用多进程好？还是多线程好？ 为什么？\nIO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。\n在实际的数据采集过程中，既考虑网速和响应的问题，也需要考虑自身机器的硬件情况，来设置多进程或多线程.\nphantomjs 或者chrome-headless 来抓取的爬虫，应当是多进程的，因为每一个phan/chro 实例就是一个进程了，并发只能是多进程。此外爬虫中还是数据处理业务，如果数据处理业务是一个比较耗时的计算型操作，那么对数据处理部分应当设为多进程，但更多可能会考虑将该部分数据处理操作和爬虫程序解耦，也就是先把数据抓取下来，事后单独运行另外的程序解析数据。\n 15. 解析网页的解析器使用最多的是哪几个\nlxml, re, beautifulsope.\n 16. 需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？\n解决限制 IP 可以使用代理 IP 地址池、服务器；\n不适用动态爬取的情况下可以使用反编译 JS 文件获取相应的文件，或者换用其他平台（比如手机端） 看看是否可以获取相应的 json 文件。\n 17. 验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）\n图形验证码：干扰、杂色不是特别多的图片可以使用开源库 Tesseract 进行识别，太过复杂的需要借助第三方打码平台。\n点击和拖动滑块验证码：可以借助 selenium、无图形界面浏览器（chromedirver 或者 phantomjs） 和 pillow 包来模拟人的点击和滑动操作，pillow 可以根据色差识别需要滑动的位置。\n手动打码（有的验证码确实无解）\n 18. 使用最多的数据库（mysql，mongodb，redis 等），对他的理解？\nMySQL 数据库：开源免费的关系型数据库，需要实现创建数据库、数据表和表的字段，表与表之间可以进行关联（一对多、多对多），是持久化存储。\nMongodb 数据库：是非关系型数据库，数据库的三元素是，数据库、集合、文档，可以进行持久化存储，也可作为内存数据库，存储数据不需要事先设定格式，数据以键值对的形式存储。\nredis 数据库：非关系型数据库，使用前可以不用设置格式，以键值对的方式保存，文件格式相对自由，主要用与缓存数据库，也可以进行持久化存储。\n 网络编程\n 1. TCP 和 UDP 的区别？\n\n基于连接与无连接；\n对系统资源的要求（TCP较多，UDP少）；\nUDP程序结构较简单；\n流模式与数据报模式 ；\nTCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。\n\n\n\n\n\nTCP\nUDP\n\n\n\n\n是否连接\n面向连接\n面向非连接\n\n\n是否可靠\n可靠\n不可靠\n\n\n数据量\n少量\n大量\n\n\n速度\n慢\n快\n\n\n\n 2. 简要介绍三次握手和四次挥手\n\n第一次握手：客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。\n第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。\n第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据\n\n由于TCP连接是全双工的，连接的拆除需要发送四个包，因此称为“四次挥手”。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。\n\n第一次挥手：客户端发送一个FIN，用来关闭客户到服务器的数据传送。\n第二次挥手：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。\n第三次挥手：服务器关闭与客户端的连接，发送一个FIN给客户端。\n第四次挥手：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。\n\n 3. 什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？\n\n\n粘包的概念\n粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。\n\n\n出现粘包的原因出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。\n发送方引起的粘包是由TCP协议本身造成的：，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。\n接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。\n\n\n","categories":["编程语言","面试"],"tags":["Python"]},{"title":"Python多进程","url":"/20200831/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/","content":"multiprocessing 是一个支持使用与 threading\r\n模块类似的 API 来产生进程的包。\r\nmultiprocessing\r\n包同时提供了本地和远程并发操作，通过使用子进程而非线程有效地绕过了\r\n全局解释器锁。\r\n\r\n因此，multiprocessing\r\n模块允许程序员充分利用给定机器上的多个处理器。 它在 Unix 和\r\nWindows 上均可运行。 multiprocessing\r\n模块还引入了 Pool\r\n对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。\r\nProcess\r\n通过创建一个 Process 对象然后调用它的\r\nstart() 方法来生成进程。\r\nfrom multiprocessing import Processdef f(name):    print(&#x27;hello&#x27;, name)if __name__ == &#x27;__main__&#x27;:    p = Process(target=f, args=(&#x27;bob&#x27;,))    p.start()    p.join()\r\nQueue 队列\r\n进程之间的通信通道之一\r\nfrom multiprocessing import Process, Queuedef f(q):    q.put([42, None, &#x27;hello&#x27;])if __name__ == &#x27;__main__&#x27;:    q = Queue()    p = Process(target=f, args=(q,))    p.start()    print(q.get())    # prints &quot;[42, None, &#x27;hello&#x27;]&quot;    p.join()\r\nPipe 管道\r\n进程之间的通信通道之一，返回一个由管道连接的连接对象，默认情况下是双工（双向）。\r\n返回的两个连接对象表示管道的两端。每个连接对象都有 send()\r\n和 recv() 方法（相互之间的）。 { note waring no-icon}\r\n请注意，如果两个进程（或线程）同时尝试读取或写入管道的同一端，则管道中的数据可能会损坏。当然，在不同进程中同时使用管道的不同端的情况下不存在损坏的风险。\r\n{ endnote}\r\nfrom multiprocessing import Process, Pipedef f(conn):    conn.send([42, None, &#x27;hello&#x27;])    conn.close()if __name__ == &#x27;__main__&#x27;:    parent_conn, child_conn = Pipe()    p = Process(target=f, args=(child_conn,))    p.start()    print(parent_conn.recv())   # prints &quot;[42, None, &#x27;hello&#x27;]&quot;    p.join()\r\n进程间同步\r\n使用锁来确保一次只有一个进程打印到标准输出 from multiprocessing import Process, Lockdef f(l, i):    l.acquire()    try:        print(&#x27;hello world&#x27;, i)    finally:        l.release()if __name__ == &#x27;__main__&#x27;:    lock = Lock()    for num in range(10):        Process(target=f, args=(lock, num)).start()\r\n进程间共享状态\r\n共享内存\r\n可以使用 Value 或 Array\r\n将数据存储在共享内存映射中。 from multiprocessing import Process, Value, Arraydef f(n, a):    n.value = 3.1415927    for i in range(len(a)):        a[i] = -a[i]if __name__ == &#x27;__main__&#x27;:    num = Value(&#x27;d&#x27;, 0.0)    arr = Array(&#x27;i&#x27;, range(10))    p = Process(target=f, args=(num, arr))    p.start()    p.join()    print(num.value)    # 3.1415927    print(arr[:])    # [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\r\n创建 num 和 arr 时使用的 'd'\r\n和 'i' 参数是 array 模块使用的类型的\r\ntypecode ： 'd' 表示双精度浮点数，\r\n'i'\r\n表示有符号整数。这些共享对象将是进程和线程安全的。为了更灵活地使用共享内存，可以使用\r\nmultiprocessing.sharedctypes\r\n模块，该模块支持创建从共享内存分配的任意ctypes对象。\r\n服务进程\r\n由 Manager()\r\n返回的管理器对象控制一个服务进程，该进程保存Python对象并允许其他进程使用代理操作它们。\r\nManager() 返回的管理器支持类型： list 、\r\ndict 、 Namespace 、 Lock 、\r\nRLock 、 Semaphore 、\r\nBoundedSemaphore 、 Condition 、\r\nEvent 、 Barrier 、 Queue 、\r\nValue 和 Array 。例如 from multiprocessing import Process, Managerdef f(d, l):    d[1] = &#x27;1&#x27;    d[&#x27;2&#x27;] = 2    d[0.25] = None    l.reverse()if __name__ == &#x27;__main__&#x27;:    with Manager() as manager:        d = manager.dict()        l = manager.list(range(10))        p = Process(target=f, args=(d, l))        p.start()        p.join()        print(d)        # &#123;0.25: None, 1: &#x27;1&#x27;, &#x27;2&#x27;: 2&#125;        print(l)        # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\r\n使用服务进程的管理器比使用共享内存对象更灵活，因为它们可以支持任意对象类型。此外，单个管理器可以通过网络由不同计算机上的进程共享。但是，它们比使用共享内存慢。\r\n使用工作进程 Pool()\r\nPool\r\n类表示一个工作进程池。它具有允许以几种不同方式将任务分配到工作进程的方法。\r\nimport timeimport osdef f(x):    return x*xif __name__ == &#x27;__main__&#x27;:    # 开 4 个工作进程    with Pool(processes=4) as pool:        # print &quot;[0, 1, 4,..., 81]&quot;        print(pool.map(f, range(10)))        # 以任意顺序打印相同的数字        for i in pool.imap_unordered(f, range(10)):            print(i)        # evaluate &quot;f(20)&quot; asynchronously        res = pool.apply_async(f, (20,))      # runs in *only* one process        print(res.get(timeout=1))             # prints &quot;400&quot;        # evaluate &quot;os.getpid()&quot; asynchronously        res = pool.apply_async(os.getpid, ()) # runs in *only* one process        print(res.get(timeout=1))             # prints the PID of that process        # 异步启动多个 evaluations *可能*使用更多进程        multiple_results = [pool.apply_async(os.getpid, ()) for i in range(4)]        print([res.get(timeout=1) for res in multiple_results])        # 使一个进程 sleep 10 秒        res = pool.apply_async(time.sleep, (10,))        try:            print(res.get(timeout=1))        except TimeoutError:            print(&quot;我们得到一个 multiprocessing.TimeoutError&quot;)        print(&quot;目前，pool 仍然可供更多工作&quot;)    # exiting the &#x27;with&#x27;-block has stopped the pool    print(&quot;现在 pool 已关闭，不再可用&quot;)\r\n{ note info } 参数 processes 默认大小是CPU的核数,\r\nmap(func, iterator) 获取结果，参数 func 是进程执行的函数，iterator\r\n是可迭代对象\r\n特点：保持阻塞直到获得结果，对于很长的迭代对象，可能消耗很多内存，可以考虑使用\r\nimap() 或 imap_unordered() 并且显示指定 chunksize 以提升效率。\r\napply_async(func[, args]) 获取结果，参数 func 是进程执行的函数，args\r\n是可迭代对象 { endnote }\r\n","categories":["编程语言"],"tags":["Python","并行计算"]},{"title":"Python 正则","url":"/20200720/python-%E6%AD%A3%E5%88%99/","content":"python 正则表达式，导入re模块。\r\n正则表达式可视化 对正则表达式进行解释\r\n\r\n转义字符\r\n\r\n\r\n\r\n转义字符\r\n含义\r\n\r\n\r\n\r\n\r\n\\A\r\n只匹配字符串开始。\r\n\r\n\r\n\\b\r\n匹配单词的词首和词尾,r'\\bclass\\b'\r\n\r\n\r\n\\B\r\n匹配空字符串，但不能在词的开头或者结尾\r\n\r\n\r\n\\d\r\n匹配数字\r\n\r\n\r\n\\D\r\n匹配任何非十进制数字的字符\r\n\r\n\r\n\\s\r\n匹配[ \\t\\n\\r\\f\\v]等空白符\r\n\r\n\r\n\\S\r\n匹配任何非空白字符\r\n\r\n\r\n\\w\r\n匹配数字或字母[a-zA-Z0-9_]\r\n\r\n\r\n\\W\r\n匹配任何不是单词字符的字符。 这与\r\n正相反。[^a-zA-Z0-9_]\r\n\r\n\r\n\\Z\r\n只匹配字符串尾\r\n\r\n\r\n.\r\n匹配一个字符\r\n\r\n\r\n[0-9a-zA-Z\\_]\r\n匹配一个数字、字母或者下划线\r\n\r\n\r\n\r\n\r\n\r\n\r\n*\r\n匹配0个或多个字符\r\n\r\n\r\n+\r\n匹配1个或多个字符\r\n\r\n\r\n?\r\n匹配0个或1个字符;非贪婪匹配，即尽可能少匹配\r\n\r\n\r\n{n}\r\n匹配n个字符\r\n\r\n\r\n{n,m}\r\n匹配n-m个字符\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\\|B\r\n匹配A或B\r\n\r\n\r\n^\r\n表示行的开头 等同\\A\r\n\r\n\r\n$\r\n表示行的结束 等同\\Z\r\n\r\n\r\n()\r\n表示分组\r\n\r\n\r\n\r\nre函数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nre函数\r\n含义\r\n\r\n\r\n\r\n\r\nre.match()\r\n方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。\r\n\r\n\r\nre.match(r'','').groups(default=None)\r\n返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。\r\ndefault 参数用于不参与匹配的情况，默认为 None。\r\n\r\n\r\nre.match(r'','').group([n])\r\n返回被 RE\r\n匹配的字符串，默认n为0,等同re.match(r'','')[0]\r\n\r\n\r\nre.match(r'','').start()\r\n返回匹配开始的位置\r\n\r\n\r\nre.match(r'','').end()\r\n返回匹配结束的位置\r\n\r\n\r\nre.match(r'','').span()\r\n返回一个元组包含匹配 [开始,结束)\r\n的位置\r\n\r\n\r\nre.search(r'','')\r\n\r\n\r\n\r\nre.split(r'\\s+', 'a b   c')\r\n切分字符串\r\n\r\n\r\nre.compile(r'')\r\n预编译正则表达式\r\n\r\n\r\nre.findall(r'','')\r\n将所有匹配的结果作为元组组成列表\r\n\r\n\r\nre.finditer(r'','')\r\n将所有匹配的结果作为迭代器返回\r\n\r\n\r\nre.sub(r'', A, B, n))\r\n把B字符串中的匹配项替换成A字符串，匹配n次，默认为0即全部替换\r\n\r\n\r\n\r\n编译标志\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n编译标志\r\n含义\r\n\r\n\r\n\r\n\r\nre.S / [DOTALL]\r\n使 . 匹配包括换行在内的所有字符\r\n\r\n\r\nre.I / [IGNORECASE]\r\n使匹配对大小写不敏感\r\n\r\n\r\nre.M / [MULTILINE]\r\n多行匹配，影响 ^ 和\r\n$\r\n\r\n\r\nre.L / [LOCALE]\r\n做本地化识别（locale-aware）匹配\r\n\r\n\r\nre.X / [VERBOSE]\r\n更清晰地组织和缩进\r\nRE，允许将注释\"#\"写入\r\nRE，该符号不能在字符串或反斜杠之后\r\n\r\n\r\n\r\n高级用法–？的使用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n(?…)\r\n含义\r\n\r\n\r\n\r\n\r\n(?aiLmsux)\r\n正则表达式内的编译标志，例子：\r\nre.match(r'(?i)(ab)c','aBc').group(1)\r\n\r\n\r\n(?:...)\r\n正则括号的非捕获版本，可理解为忽略该分组，例子：\r\nre.match(r'(?i:aB)','aB00').groups()\r\n\r\n\r\n(?P&lt;name&gt;...)\r\n命名组合，引用组合的方式1.正则式\r\n(?P=name) 《==》\\1 。比如\r\n(?P&lt;name&gt;['\"]).*?(?P=name) 2.处理匹配对象m，\r\nm.group('name') 等3.传递到 re.sub() 里的\r\nrepl 参数中， \\g&lt;quote&gt; 《==》\r\n\\g&lt;1&gt; 《==》 \\1\r\n\r\n\r\n(?P=name)\r\n反向引用一个命名组合；它匹配前面那个叫\r\nname 的命名组中匹配到的串同样的字串。\r\n\r\n\r\n(?#...)\r\n注释；里面的内容会被忽略。\r\n\r\n\r\n(?=...)\r\n前瞻性断言，匹配时的判断条件，比如\r\nhello (?=world) 只有在后面是 'world'\r\n的时候匹配 'hello '\r\n\r\n\r\n(?!...)\r\n否定超前断言，前视取反，比如\r\nhello (?!world) 只有在后面不是 'world'\r\n的时候匹配 'hello '\r\n\r\n\r\n(?&lt;=...)\r\n肯定断言，正向后视断定\r\n\r\n\r\n(?&lt;!...)\r\n否定后视断言，后视断定取非，\r\n\r\n\r\n(?(id/name)yes-pattern\\|no-pattern)\r\n判断 id 或 name\r\n存在。比如， (&lt;)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)&gt;\\|$)\r\n是一个email样式匹配\r\n\r\n\r\n\r\n练习题\r\n\r\n来源：廖雪峰的python教程\r\n\r\n验证Email地址的正则表达式，\r\n\r\nsomeone@gmail.com\r\nbill.gates@microsoft.com\r\n&lt;someone@gmail.com&gt;\r\n\r\n代码参考# coding:utf-8# re 模块import redef is_valid_email(addr):    m = re.match(r&#x27;^[\\w\\.]+@[a-zA-Z]+\\.com$&#x27;,addr)    r&#x27;([\\w]+(\\.[\\w]+)*@[\\w]+(\\.[\\w]+)+)&#x27;    return True if m else Falsedef is_valid_email2(addr):    &quot;&quot;&quot;匹配&#x27;&lt;user@host.com&gt;&#x27; 或 &#x27;user@host.com&#x27;    &quot;&quot;&quot;    m = re.match(r&#x27;(&lt;)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)&gt;|$)&#x27;,addr)    return True if m else False# 测试:assert is_valid_email(&#x27;someone@gmail.com&#x27;)assert is_valid_email(&#x27;bill.gates@microsoft.com&#x27;)assert not is_valid_email(&#x27;bob#example.com&#x27;)assert not is_valid_email(&#x27;mr-bob@example.com&#x27;)assert is_valid_email2(&#x27;&lt;someone@gmail.com&gt;&#x27;)print(&#x27;ok&#x27;)\r\n可以提取出带名字的Email地址：\r\n\r\n&lt;Tom Paris&gt; tom@voyager.org =&gt;\r\nTom Paris\r\nbob@example.com =&gt; bob\r\n\r\n代码参考# coding:utf-8# re 模块import redef name_of_email(addr):    return re.match(r&#x27;\\&lt;?([\\w\\s]+)\\&gt;?\\s?(\\w*)\\@&#x27;,addr).group(1)def name_of_email2(addr):    return re.match(r&#x27;(&lt;)?([\\w\\s]+)(?(1)(?:&gt; \\w+))@&#x27;,addr).group(2)# 测试:assert name_of_email(&#x27;&lt;Tom Paris&gt; tom@voyager.org&#x27;) == &#x27;Tom Paris&#x27;assert name_of_email(&#x27;tom@voyager.org&#x27;) == &#x27;tom&#x27;print(&#x27;ok&#x27;)\r\n其他\r\n匹配网页\r\n(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*,]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)|([a-zA-Z]+.+.+[a-zA-Z0-9/_]+)\r\n","categories":["未分类"],"tags":["Python","正则表达式"]},{"title":"Python日期时间","url":"/20200721/python%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/","content":"python 内置的几个关于时间的模块，time\r\ntimeit datetime calendar\r\n — ## time 模块\r\ntime 模块# coding:utf-8# time 模块import time# 1. time.time() print(time.time()) # time.time() 返回当前时间戳# &gt;: 1624126357# 2. time.localtime() print(time.localtime()) # time.localtime() 返回当前时间结构元组# &gt;: time.struct_time(tm_year=2021, tm_mon=6, tm_mday=20, tm_hour=2, tm_min=12, tm_sec=37, tm_wday=6, tm_yday=171, tm_isdst=0)# 3. time.ctime()  时间戳-&gt;日期print(time.ctime()) # time.ctime() 返回当前日期# &gt;: Sun Jun 20 02:12:37 2021# 4. time.asctime() 结构元组-&gt;日期print(time.asctime((2021, 6, 20, 2, 12, 37, 6, 171, 0))) # time.asctime() 返回一个可读的形式# &gt;: Sun Jun 20 02:12:37 2021print(time.ctime(1624126357)) # 返回该时间戳的日期# &gt;: Sun Jun 20 02:12:37 2021# 5. tiem.gmtime() 时间戳-&gt;结构元组print(tiem.gmtime(1624126357.0)) # # &gt;: time.struct_time(tm_year=2021, tm_mon=6, tm_mday=20, tm_hour=2, tm_min=12, tm_sec=37, tm_wday=6, tm_yday=171, tm_isdst=0)# 6. time.mktime() 结构元组-&gt;时间戳print(time.mktime( (2021, 6, 20, 2, 12, 37, 6, 171, 0) )) # time.mktime() 返回时间结构元组的时间戳# &gt;: 1624126357.0print(time.localtime(1624126357)) # 返回传入的时间戳的时间结构元组# &gt;: time.struct_time(tm_year=2021, tm_mon=6, tm_mday=20, tm_hour=2, tm_min=12, tm_sec=37, tm_wday=6, tm_yday=171, tm_isdst=0)# 7. time.strftime() 时间元组-&gt;指定的格式print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,)) # time.strftime() 格式化输出当前时间# 8. time.strptime() 指定的格式-&gt;时间元组print(time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;))# &gt;: time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1) # 时间日期格式化符号：https://www.runoob.com/python/att-time-strptime.html# 9. time.sleep(:int)time.sleep(2) # time.sleep(2) selenium中常用的休眠，休眠2秒# 10. time.perf_counter()T1 = time.perf_counter()#______假设下面是程序部分______for i in range(100*100):    passT2 =time.perf_counter()print(&#x27;程序运行时间:%s毫秒&#x27; % ((T2 - T1)*1000))# 11. time.process_time()T1 = time.process_time() # time.process_time() 不包括sleep()休眠时间；需要调用两次，做差值#______假设下面是程序部分______for i in range(100*100):    passT2 =time.process_time()print(&#x27;程序在CPU运行时间:%s毫秒&#x27; % ((T2 - T1)*1000))\r\ntimeit 模块\r\ntimeit 模块# coding:utf-8# timeit 模块 性能分析import timeit# 待测试的函数def add():    return sum(range(111))# stmt 需要测试的函数或语句，字符串形式# setup 运行的环境，本例子中表示 if __name__ == &#x27;__main__&#x27;:# number 被测试的函数或语句，执行的次数，本例表示执行100000次add()。省缺则默认是10000次# repeat 测试做100次# 综上：此函数表示 测试 在if __name__ == &#x27;__main__&#x27;的条件下，执行100000次add()消耗的时间，并把这个测试做100次,并求出平均值t = timeit.timeit(stmt=&quot;add()&quot;, setup=&quot;from __main__ import add&quot;, number=100000)t = timeit.repeat(stmt=&quot;add()&quot;, setup=&quot;from __main__ import add&quot;, number=100000, repeat=100)print(t)print(sum(t) / len(t))\r\ndatetime 模块\r\ndatetime 模块# coding:utf-8# datetime 模块from datetime import datetime# 1. datetime.now()print(datetime.now()) # datetime.now() 返回当前日期和时间 [datetime 类型]# &gt;: 2021-06-20 02:12:37# 2. datetime()print(datetime(2021, 6, 20, 2, 12, 37, 6)) # datetime() 返回指定日期和时间 [datetime 类型]# &gt;: 2021-06-20 02:12:37.000006# 3. datetime().timestamp()print(datetime(2021, 6, 20, 2, 12, 37, 6).timestamp())  # datetime().timestamp() [datetime 类型]转换为本地时区timestamp# &gt;: 1624126357.000006# 4. datetime.fromtimestamp(t)t = datetime(2021, 6, 20, 2, 12, 37, 6).timestamp()print(datetime.fromtimestamp(t)) # datetime.fromtimestamp(t) 本地时区timestamp[t]转换为[datetime 类型]# &gt;: 2021-06-20 02:12:37.000006# 5. datetime.utcfromtimestamp(t)t = datetime(2021, 6, 20, 2, 12, 37, 6).timestamp()print(datetime.utcfromtimestamp(t)) # datetime.utcfromtimestamp(t) UTC标准时区timestamp[t]转换为[datetime 类型]# &gt;: 2021-06-19 18:12:37.000006# 6. strptime()# datetime.strptime() 字符串日期和时间转成[datetime 类型]# 格式说明: https://docs.python.org/3/library/datetime.html#strftime-strptime-behaviorprint(datetime.strptime(&#x27;2021-6-20 02:12:37&#x27;, &#x27;%Y-%m-%d %H:%M:%S&#x27;)) # &gt;: 2021-06-20 02:12:37# 6. strftime()dt = datetime(2021,6,20,2,12,37,6)print(dt.strftime(&#x27;&#x27;&#x27;本地时间%c星期 , 月 , 日 , 日期 ,时:分:秒%A(%a), %B(%b) %d , %x , %X日期时间24小时制%d/%m/%y %H:%M:%S %z日期时间12小时制%Y-%m-%d %p. %I:%M:%S第 %j 天第 %U 个星期, 星期 %w [日始0-6]第 %W 个星期, 星期 %u [一始1-7]&#x27;&#x27;&#x27;)) # datetime.strftime() [datetime 类型]转成字符串日期和时间.# 7. timedelta # 对日期和时间进行加减,可以直接用+和-运算符from datetime import datetime, timedeltadt = datetime(2021, 6, 20, 2, 12, 37, 6)dt = dt + timedelta(hours=10) # 8. timezonefrom datetime import datetime, timedelta, timezonetz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00now = datetime.now()dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00# 9. astimezoneutc_dt = datetime.utcnow().replace(tzinfo=timezone.utc) # 获取UTC时间，并强制设置时区为UTC+0:00:bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8))) # astimezone()将转换时区为北京时间:tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9))) # 将转换时区为东京时间tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9))) # 将bj_dt转换时区为东京时间# ** 假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp：# -*- coding:utf-8 -*-import refrom datetime import datetime, timezone, timedeltadef to_timestamp(dt_str, tz_str):    i_utc = int(re.match( r&#x27;UTC(.*):00&#x27;, tz_str).group(1))    tz_utc = timezone(timedelta(hours=i_utc))    dt= datetime.strptime(dt_str, &#x27;%Y-%m-%d %H:%M:%S&#x27;)    dt = dt.replace(tzinfo=tz_utc) # 强制设置为UTC+X:00    return dt.timestamp()# 测试:t1 = to_timestamp(&#x27;2015-6-1 08:10:30&#x27;, &#x27;UTC+7:00&#x27;)assert t1 == 1433121030.0, t1t2 = to_timestamp(&#x27;2015-5-31 16:10:30&#x27;, &#x27;UTC-09:00&#x27;)assert t2 == 1433121030.0, t2print(&#x27;ok&#x27;)\r\ncalendar 模块\r\ncalendar 模块# coding:utf-8# calendar 模块 处理年历和月历import calendar# 1. calendar.calendar(year,w=2,l=1,c=6) print(calendar.calendar(2021,w=2,l=1,c=7)) # 3个月一行，间隔距离为c，每日宽度间隔为w字符，l是每星期行数。每行长度为21* W+18+2* C# 相当于 calendar.prcal(year,w=2,l=1,c=6)# 2. calendar.month(year,month,w=2,l=1)print(calendar.month(2021,6,w=2,l=1)) # 一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。# 相当于 calendar.prmonth(year,month,w=2,l=1)# 3. calendar.weekday(year,month,day)print(calendar.weekday(2021,6,20)) # calendar.weekday() 0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。# &gt;: 6 # 解释：星期日# 4. calendar.firstweekday()print(calendar.firstweekday()) # calendar.firstweekday() 返回当前每周起始日期的设置,默认返回0，即星期一# &gt;: 0# 5. calendar.isleap(year)print(calendar.isleap(2020)) # calendar.isleap(year) 闰年返回 True，否则为 false。# &gt;: True# 6. calendar.leapdays(y1,y2)calendar.leapdays(1900,2020) # 返回在[Y1，Y2)两年之间的闰年总数# &gt;: 29# 7. calendar.monthrange(year,month)print(calendar.monthrange(2021,6))# &gt;: (1,30) # 解释：1 表示 2021 年 6 月份的第一天是周一，30 表示 2021 年 6 月份总共有 30 天。# 8. calendar.setfirstweekday(weekday)calendar.setfirstweekday(1) # 设置每周的起始日期码。0（星期一）到6（星期日）。\r\n","categories":["编程语言"],"tags":["Python"]},{"title":"Scoop 包管理器","url":"/20200815/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","content":"Scoop是一个Windows下的包管理器，完全免费，依赖于Github。\r\n应注意以下几点\r\n\n\r\n用户名不含中文字符\r\n能正常、快速的访问 GitHub 并下载上面的资源\r\n如果下载scoop的过程中断，那么必须先删除(C:\\Users\\&lt;user&gt;\\scoop)文件夹，再执行以上命令安装。\r\nWindows 7 SP1+ / Windows Server 2008+\r\nPowerShell 3+\r\n.NET Framework 4.5+\r\n\r\n若Powershell或.NET Franmework版本过旧，更新后重启即可。\r\n若不清楚版本号，可Win+R运行powershell，输入以下命令获取版本号。\r\n$PSVersionTable.PSVersion.Major   #查看Powershell版本 &gt; 3$PSVersionTable.CLRVersion.Major  #查看.NET Framework版本 &gt; 4.5\r\n\n \r\n获取 Scoop 包管理器\r\n安装 scoop\r\n# 准备将 Scoop 本体安装到已定义目录$env:SCOOP=&#x27;D:\\Scoop&#x27;# 先添加用户级别的环境变量 SCOOP[environment]::setEnvironmentVariable(&#x27;SCOOP&#x27;,$env:SCOOP,&#x27;User&#x27;)# 允许本地脚本的执行：set-executionpolicy remotesigned -scope currentuser# 安装 Scoop：Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)# 或者更短#iwr -useb get.scoop.sh | iex# 安装完成，查看 scoop 的版本和 main bucket 的版本scoop -v\r\n修改默认全局安装路径，体现在额外的参数-g上\r\n$env:SCOOP_GLOBAL=&#x27;D:\\GlobalScoopApps&#x27;[environment]::setEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;,$env:SCOOP_GLOBAL,&#x27;Machine&#x27;)\r\n更新 Scoop\r\nscoop update\r\n卸载 Scoop\r\nscoop uninstall scoop\r\n管理仓库\r\nScoop 默认使用的是 main\r\n仓库，官方维护的另一个 Bucket 为 extras\r\n，需要手动添加。有些软件并没有收录在仓库中，需要额外添加其他仓库。\r\n# scoop help bucketUsage: scoop bucket add|list|known|rm [&lt;args&gt;]# ...\r\n查询仓库\r\n# 查看可直接添加的仓库scoop bucket known# 查看已添加的仓库scoop bucket list\r\n添加仓库\r\n# 添加 extras 仓库scoop bucket add extras# 添加第三方 bucketscoop bucket add &lt;bucketname&gt; https://github.com/xxx/xxx\r\n删除仓库\r\n# 删除 extrasscoop bucket rm extras\r\n更新仓库\r\n# 更新 extrasscoop update\r\n其他仓库\r\nbucket 排行榜 - 链接1 -\r\n链接2\r\n一些 bucket 简单介绍 - main: 默认的主仓库 -\r\nextras: 常用，诸多有用的软件都在里面。地址 lukesampson/scoop-extras\r\n- nirsoft: NirSoft\r\n开发的小工具的安装合集，包括系统工具、网络工具、密码恢复等 - 地址: kodybrown/scoop-nirsoft\r\n- 官网地址: NirSoft -\r\ndorado: 添加了一些国内的app，比如 qqplayer 👍🏻️ h404bi/dorado -\r\nnerd-fonts: 编程字体一览无遗  -\r\nash258: Ash258/scoop-Ash258 -\r\nnonportable: 收录神奇的UWP应用 windows平台应用 -\r\nversions: 收录软件包的历史版本 - java:\r\n可以通过它安装各种 jdk 、 jre\r\n仓库的多少影响搜索软件包的搜索结果、搜索速度、「一键更新」的速度、清理的速度。所以收录/订阅必要的软件仓库即可，也不必盲目添加。\r\n\r\n管理APP\r\n查询APP\r\n# 查找APP, 不带APP即查询所有软件scoop search &lt;APP&gt;# 查看已安装的 APPscoop list\r\n安装APP\r\n## scoop help install# scoop install &lt;app&gt; [options]# -g, --global              全局安装应用# -i, --independent         不要自动安装依赖# -k, --no-cache            不使用下载缓存# -u, --no-update-scoop     如果已经过时，安装前不要更新 Scoop# -s, --skip                跳过哈希验证（谨慎使用！）# -a, --arch &lt;32bit|64bit&gt;  使用指定的架构，如果应用支持的话# 安装APPscoop install &lt;app&gt;\r\n更新APP\r\n## scoop help update# scoop update &lt;app&gt; [options]# -f, --force       即使没有更新版本也强制更新# -g, --global      更新全局安装的应用# -i, --independent 不要自动安装依赖# -k, --no-cache    不使用下载缓存# -s, --skip        跳过哈希验证（谨慎使用！）# -q, --quiet       隐藏无关消息# -a, --all         更新所有应用程序（替代“*”）# 更新APP,  不带APP即更新scoop本身及bucketscoop update &lt;app&gt;\r\n卸载APP\r\n## scoop help uninstall# scoop uninstall &lt;app&gt; [options]# -g, --global  卸载全局安装的应用# -p, --purge   删除所有持久数据# 卸载并删除配置文件scoop uninstall -gp &lt;app&gt;\r\n缓存的安装包\r\n# 显示安装包的缓存scoop cache show# 删除 指定APP的安装包scoop cache rm &lt;app&gt;# 删除所有APP安装包scoop cache rm *# 禁用安装包缓存 -k 或 --no-cachescoop install -k &lt;app&gt;scoop update -k *\r\n删除旧版本APP\r\n由于自身的特性（滚动更新，当更新时是立刻拉取最新的commit）可能会导致程序异常，所以当软件被更新后\r\nScoop 还会保留软件的旧版本，更新软件后可以通过 scoop cleanup\r\n命令进行删除。 # 删除指定APP旧版本scoop cleanup &lt;app&gt;# 删除所有APP旧版本scoop cleanup *# 不仅删除所有APP旧版本，也包括缓存的安装包scoop cleanup -k *\r\n推荐软件\r\n必装\r\n\r\n7zip\r\ngit\r\naria2 #\r\n安装aria2后，scoop会自动调用aria2进行多线程下载以加速下载\r\ncurl\r\nminiconda3 # 由于scoop不保留 Conda envs 和\r\npkgs，在更新后创建的虚拟环境会丢失，所以建议设置 envs_dirs\r\n以使用 ‘~/.conda/envs’ 修改配置文件 ~/.condarcenvs_dirs:  - D:/Scoop/apps/miniconda3/envspkgs_dirs:  - D:/Scoop/apps/miniconda3/pkgs\r\n\r\n可选\r\n\r\nvscode\r\nmactype-np # 装机必备的字体优化工具\r\nmotrix # 开源美观的下载工具\r\npotplayer # 超强的视频播放器\r\nquicklook # 快速预览工具\r\nsnipaste # 大名鼎鼎的截图工具\r\ntypora # 久负盛名的 Markdown 编辑器\r\nwindows-terminal # windows官方的终端应用\r\nfluent-terminal-np # Windows平台终端工具\r\nsudo\r\ngcc\r\nvim\r\n\r\n其他\r\n\r\ngimp\r\ninkscape\r\nlatex\r\ncalibre\r\nzotero\r\n\r\n加速下载\r\n在使用scoop安装aria2后，scoop会自动调用aria2进行多线程下载以加速下载：\r\nscoop install aria2scoop aria2-enabled truescoop config aria2-max-connection-per-server 16scoop config aria2-split 16scoop config aria2-min-split-size 1M# aria2-enabled (默认值: true)# aria2-retry-wait (默认值: 2)# aria2-split (默认值: 5)# aria2-max-connection-per-server (默认值: 5)# aria2-min-split-size (默认值: 5M)# scoop config proxy 127.0.0.1:10809 （额外的代理，如果有的话）\r\n字体\r\n# 添加 nerd-fonts 仓库scoop bucket add nerd-fonts# 搜索字体scoop search &quot;-NF&quot;# 安装字体sudo scoop install FiraCode-NF\r\n提权\r\n如果不是以管理员的身份运行PowerShell，常常会出现一些错误。此时sudo来了。\r\nscoop install -g sudosudo scoop install -g &lt;app&gt;\r\n其他问题\r\n1. 添加extras失败\r\n使用命令scoop bucket add extras添加仓库时出现错误：\r\nChecking repo... okefatal: the remote end hung up unexpectedlyrror: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: early EOFfatal: index-pack failedThe extras bucket was added successfully.\r\n虽然提示添加成功，但在安装anaconda3软件时出现：\r\nUpdating Scoop...Updating &#x27;extras&#x27; bucket...fatal: not a git repository (or any of the parent directories): .gitfatal: not a git repository (or any of the parent directories): .gitfatal: not a git repository (or any of the parent directories): .gitUpdating &#x27;main&#x27; bucket... * 9d903fc3 git-up: Update to version 2.0.0                              9 hours agoScoop was updated successfully!Couldn&#x27;t find manifest for &#x27;anaconda3&#x27;.\r\n看起来是文件夹里缺少一些必要的东西，于是去查看仓库所在路径(C:\\&lt;user&gt;)，发现extras只是一个空文件夹，为此在网络上搜罗解决办法：\r\n-\r\n说是缓冲区溢出，需要执行git config --global http.postBuffer 524288000，无果！\r\n-\r\n说是网络太慢，需要执行git config --global http.lowSpeedLimit 0和git config --global http.lowSpeedTime 999999，无果！\r\nChecking repo... okefrror: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054fatal: the remote end hung up unexpectedlyatal: early EOFfatal: index-pack failedThe extras bucket was added successfully. -\r\n需要执行git config --global http.sslVerify \"false\"，无果！\r\nChecking repo... okefrror: RPC failed; curl 18 transfer closed with outstanding read data remainingatal: the remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failedThe extras bucket was added successfully. -\r\n需要执行git clone --depth=1 https://github.com/lukesampson/scoop-extras.git，成功！！\r\n这里是先找到extras仓库分支，然后在路径(C:\\&lt;user&gt;)下clone这个分支，再修改下这个下载下来的文件夹的名称为extras，就可以正常使用了。\r\n&gt;\r\n注：--depth=1参数是指只克隆最近一次commit，只会把默认分支clone下来。对不是参与整个项目的开发工作的我们来说问题不大。\r\n\r\n相关链接\r\n\r\nScoop 官网\r\nQuick Start\r\nOn GitHub\r\n\r\n","categories":["未分类"],"tags":["Scoop"]},{"title":"Django的CMS框架","url":"/20200604/django%E7%9A%84cms%E6%A1%86%E6%9E%B6/","content":"\r\nMezzanine 是一个功能强大，一致且灵活的内容管理平台。Mezzanine\r\n使用Django框架构建，提供了一个简单但高度可扩展的体系结构。\r\n\r\n\r\nOn\r\nGitHub\r\n官方网站\r\n开发文档\r\n\r\n\r\n\r\n我的项目地址\r\n我的演示\r\n\r\n一、 开始\r\n环境：python3\r\n1. 安装\r\npip install mezzanine\r\n2. 创建项目\r\nmezzanine-project project_namecd project_namepython manage.py createdb --noinputpython manage.py runserver\r\n该createdb命令是使用Django命令的快捷方式\r\nmigrate，该命令还将安装一些演示内容，例如联系表格，图片库等。如果您想省略此步骤，请将该--nodata选项与createdb一起使用。\r\n\r\n3. 静态文件\r\n对于静态文件（包括JavaScript和CSS文件等），官方是这样解释的\r\n\r\nDjango在生产环境中部署时不提供静态内容，而将其留给面向公众的Web服务器，这绝对是完成此工作的最佳工具。\r\n\r\n这时静态文件在（虚拟）环境下\\Lib\\site-packages\\mezzanine\\core\\static，执行下列命令可以将文件直接存储在项目中\r\npython manage.py collectstaticpython manage.py collecttemplates\r\n4. 主题\r\n主题\r\n5. 第三方插件\r\n第三方插件\r\n6. 示例站点\r\n示例站点\r\n7. 常见问题\r\n常见问题\r\n","categories":["未分类"],"tags":["Python","Django"]},{"title":"简述新电脑开荒","url":"/20211103/%E7%AE%80%E8%BF%B0%E6%96%B0%E7%94%B5%E8%84%91%E5%BC%80%E8%8D%92/","content":"给人开荒赚钱，给己开荒省钱！\r\n临近双十一，手下的笔记本也该更新换代了，就把自己的开荒操作大致记录下来，具体软件使用不是本文重点。有大厂出品的软件，也有一些小而巧的小众软件\r\n\r\n\r\n常规操作（获得较新的系统环境）\r\nWindows激活，Office激活，系统分区，系统更新，软件卸载，软件更新，驱动更新，漏洞补丁，还有电脑图标，启动项等等，在此没必要再造轮子，就不一一叙述。\r\n安全防护（获得较习惯的安全环境，以个人习惯为准） Windows\r\n防护：关闭所有功能。 原厂防护：关闭自启，未卸载\r\n电脑管家：安装到C盘。（其他软件到D盘）\r\n安装\r\nV2ray（获得更好的网络环境，通过某些VPN才能让scoop更好地连接Github\r\n小声哔哔Free ）\r\n由于不可抗力，在此也不能详细叙述，一本github各位好自为之 。\r\n提前配置 conda,git,scoop ：\r\n创建文件C:\\Users\\&lt;USER&gt;\\.condarc参考 清华源\r\nssl_verify: falseshow_channel_urls: truereport_errors: falseauto_activate_base: truealways_yes: truechannels:  - defaultsdefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudproxy_servers:    http: http://127.0.0.1:10808    https: http://127.0.0.1:10808 创建文件C:\\Users\\&lt;USER&gt;\\.gitconfig\r\n[core]\tautocrlf = false[http]\tsslVerify = false\tproxy = socks5://127.0.0.1:10808[https]\tsslVerify = false\tproxy = socks5://127.0.0.1:10808 修改C:\\Windows\\System32\\drivers\\etc\\hosts参考\r\ngithub520\r\n安装 Scoop （获得更干净的软件环境）\r\n自己去安装这个确实需要一点先验知识，所以还是要记录下。 以管理员权限运行\r\nPowerShell，并执行下面代码。\r\n$env:SCOOP=&#x27;D:\\Scoop&#x27;[environment]::setEnvironmentVariable(&#x27;SCOOP&#x27;,$env:SCOOP,&#x27;User&#x27;)set-executionpolicy remotesigned -scope currentuserSet-ItemProperty &#x27;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem&#x27; -Name &#x27;LongPathsEnabled&#x27; -Value 1Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)# 设置全局（如果需要）# $env:SCOOP_GLOBAL=&#x27;D:\\GlobalScoopApps&#x27;# [environment]::setEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;,$env:SCOOP_GLOBAL,&#x27;Machine&#x27;)# 检查 scoopscoop checkup# scoop update *# scoop update scoopscoop install git aria2 # 同时自动下载 7zip# 添加三个 bucketscoop bucket rm extras ;; scoop bucket add extrasscoop bucket add javascoop bucket add dorado https://github.com/chawyehsu/dorado # scoop 代理scoop config rm proxy ;; scoop config proxy 127.0.0.1:10808# 关于 git 代理# git config --global http.proxy http://127.0.0.1:10808# git config --global https.proxy http://127.0.0.1:10808# git config --global --unset http.proxy# git config --global --unset https.proxy# 以上安装完成。以下看个人需求。scoop install sudo curl scoop install vscode miniconda3 #conda clean --packages#conda clean --all#conda update --all#conda update -n base condascoop install motrix # 下载工具scoop install mactype-np # 字体优化工具scoop install potplayer # 视频播放器scoop install quicklook # 快速预览工具scoop install snipaste # 截图工具\r\n安装 Everything + Wox\r\n（获得更强大的搜索环境）\r\n其他 聊天（QQ/Tim/微信/腾讯会议） 输入法（搜狗） 浏览器（Chrome）\r\n视频（QQ影音） PE（BalenaEther） 远程（向日葵，蒲公英）\r\n压缩（bandizip6.x版本无广告）\r\n编程（SourceTree/Fiddler/Navicat） 学术（PDF\r\n阅读器，知云文献翻译，CAJViewer，EasyConnect，SciHub）\r\n网盘（百度网盘、阿里云盘、OneDriver）\r\n还有一点点（Xmind、Notion）\r\n\r\n","categories":["未分类"]},{"title":"TodoMVC应用","url":"/20211018/todomvc%E5%BA%94%E7%94%A8/","content":"使用VueJs实现官方的 TodoMVC\r\n示例，将其数据存储到后端数据库，并部署上线。 示例\r\n\r\n\r\n我的项目地址\r\n我的演示\r\n\r\n\r\n环境 Git、Node、npm、heroku\r\n\r\n一、 TodoMVC 应用\r\n1. 下载模板\r\nGitHub下载模板\r\ngit clone git@github.com:tastejs/todomvc-app-template.git\r\n2. 获取支持文件\r\n通过npm下载模板的CSS和JS文件，以及之后要用到的Vue.js。\r\ncd todomvc-app-templatenpm installnpm install vue\r\n3. 使用Vuejs实现Todo\r\n主要修改js/app.js和index.html两个文件。\r\njs/app.js(function (Vue) &#123;    // 数据    let todos=[        &#123;id:1,title:&#x27;吃饭&#x27;,completed:false&#125;,        &#123;id:2,title:&#x27;睡觉&#x27;,completed:true&#125;,        &#123;id:3,title:&#x27;打豆豆&#x27;,completed:true&#125;    ];    /*/ 全局自定义指令,自动获取焦点    Vue.directive(&#x27;focus&#x27;, &#123;        inserted: function (el) &#123;              el.focus();        &#125;    &#125;);*/    // vue实例    window.app=new Vue(&#123;        el:&#x27;#todoapp&#x27;,        data:&#123;            todos:todos,            currentEditing:null,            filterState:&#x27;all&#x27;,            toggleAllstate:true,        &#125;,        computed:&#123;            leftCount:function()&#123;                return this.todos.filter(item =&gt; !item.completed).length            &#125;,            filterTodos:function()&#123;                switch(this.filterState)&#123;                    case &#x27;active&#x27;:                        return this.todos.filter(item=&gt;!item.completed);                        break;                    case &#x27;completed&#x27;:                        return this.todos.filter(item=&gt;item.completed);                        break;                    default:                        return this.todos;                        break;                &#125;;            &#125;,            // 全选的联动效果            toggleState:function()&#123;                return this.todos.every(item=&gt;item.completed);            &#125;,        &#125;,        methods:&#123;            // 添加任务            addTodo(event)&#123;                let todoText=event.target.value.trim();                if(!todoText.length)&#123;                    return                &#125;                const lastTodo=this.todos[this.todos.length-1];                const id=lastTodo?lastTodo.id+1:1;                this.todos.push(&#123;                    id:id,                    title:todoText,                    completed:false,                &#125;);                event.target.value=&#x27;&#x27;;            &#125;,            // 点击全部完成或者未完成            toggleAll(event)&#123;                let checked=event.target.checked;                this.todos.forEach(todo =&gt; todo.completed=checked);            &#125;,            // 删除单个任务项            removeTodo(delIndex,event)&#123;                this.todos.splice(delIndex,1);            &#125;,            // 显示所有未完成任务数(删除所有已完成)            removeAllDone()&#123;                this.todos=this.todos.filter((item,index)=&gt;&#123;                    return !item.completed;//return true,即item.completed为false                &#125;);            &#125;,            // 保存编辑项            saveEdit(item,index,event)&#123;                var editText=event.target.value.trim();                // 如果为空,直接删除这个item                if(!editText.length)&#123;                    return this.todos.splice(index,1);                &#125;                // 如果不为空,修改title的值,然后去除eiditing样式                item.title=editText;                this.currentEditing=null;            &#125;,        &#125;,        directives:&#123;            // 局部自定义属性            editingFocus:&#123;                update(el,binding)&#123;                    if(binding.value)&#123;                        el.focus();                    &#125;                &#125;,            &#125;,\t\t\tfocus:&#123;\t\t\t\tinserted: function (el) &#123;\t\t\t\t      el.focus();\t\t\t\t&#125;\t\t\t&#125;        &#125;,    &#125;);    // 路由状态切换    window.onhashchange=function()&#123;        var hash=window.location.hash.substr(2) || &#x27;all&#x27;;        window.app.filterState=hash;    &#125;;    // 页面第一次进来,保持状态    window.onhashchange();&#125;)(Vue);\r\nindex.html&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\t\t&lt;title&gt;Template • TodoMVC&lt;/title&gt;\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/todomvc-common/base.css&quot;&gt;\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/todomvc-app-css/index.css&quot;&gt;\t\t&lt;!-- CSS overrides - remove if you don&#x27;t need it --&gt;\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;section id=&quot;todoapp&quot; class=&quot;todoapp&quot;&gt;\t\t\t&lt;header class=&quot;header&quot;&gt;\t\t\t\t&lt;h1&gt;todos&lt;/h1&gt;\t\t\t\t&lt;input class=&quot;new-todo&quot; placeholder=&quot;What needs to be done?&quot; @keyup.enter=&#x27;addTodo&#x27; v-focus&gt;\t\t\t&lt;/header&gt;\t\t\t&lt;!-- This section should be hidden by default and shown when there are todos --&gt;\t\t\t&lt;template v-if=&#x27;todos.length&#x27;&gt;\t\t\t&lt;section class=&quot;main&quot;&gt;\t\t\t\t&lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot; @click=&#x27;toggleAll&#x27; v-bind:checked=&#x27;toggleState&#x27;&gt;\t\t\t\t&lt;label for=&quot;toggle-all&quot;&gt;Mark all as complete&lt;/label&gt;\t\t\t\t&lt;ul class=&quot;todo-list&quot;&gt;\t\t\t\t\t&lt;!-- These are here just to show the structure of the list items --&gt;\t\t\t\t\t&lt;!-- List items should get the class `editing` when editing and `completed` when marked as completed --&gt;\t\t\t\t\t&lt;!-- vue列表渲染 --&gt;\t\t\t\t\t&lt;li v-for=&quot;(item,index) of filterTodos&quot; v-bind:class=&#x27;&#123;completed:item.completed,editing:item===currentEditing&#125;&#x27;&gt;                        &lt;div class=&quot;view&quot;&gt;                            &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; v-model=&#x27;item.completed&#x27;&gt;                            &lt;label @dblclick=&quot;currentEditing=item&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/label&gt;                            &lt;button class=&quot;destroy&quot; @click=&#x27;removeTodo(index,$event)&#x27; &gt;&lt;/button&gt;                        &lt;/div&gt;                        &lt;input class=&quot;edit&quot; :value=&#x27;item.title&#x27; @blur=&#x27;saveEdit(item,index,$event)&#x27; @keyup.enter=&#x27;saveEdit(item,index,$event)&#x27; @keyup.esc=&#x27;currentEditing=null&#x27; v-editing-focus=&quot;item===currentEditing&quot;&gt;                    &lt;/li&gt;\t\t\t\t&lt;/ul&gt;\t\t\t&lt;/section&gt;\t\t\t&lt;!-- This footer should hidden by default and shown when there are todos --&gt;\t\t\t&lt;footer class=&quot;footer&quot;&gt;\t\t\t\t&lt;!-- This should be `0 items left` by default --&gt;\t\t\t\t&lt;span class=&quot;todo-count&quot;&gt;&lt;strong&gt;&#123;&#123;leftCount&#125;&#125;&lt;/strong&gt; 个待办&lt;/span&gt;\t\t\t\t&lt;!-- Remove this if you don&#x27;t implement routing --&gt;\t\t\t\t&lt;ul class=&quot;filters&quot;&gt;\t\t\t\t\t&lt;li&gt;\t\t\t\t\t\t&lt;a :class=&quot;&#123;selected:filterState===&#x27;all&#x27;&#125;&quot; href=&quot;#/&quot;&gt;全部&lt;/a&gt;\t\t\t\t\t&lt;/li&gt;\t\t\t\t\t&lt;li&gt;\t\t\t\t\t\t&lt;a :class=&quot;&#123;selected:filterState===&#x27;active&#x27;&#125;&quot; href=&quot;#/active&quot;&gt;未完成&lt;/a&gt;\t\t\t\t\t&lt;/li&gt;\t\t\t\t\t&lt;li&gt;\t\t\t\t\t\t&lt;a :class=&quot;&#123;selected:filterState===&#x27;completed&#x27;&#125;&quot; href=&quot;#/completed&quot;&gt;已完成&lt;/a&gt;\t\t\t\t\t&lt;/li&gt;\t\t\t\t&lt;/ul&gt;\t\t\t\t&lt;!-- Hidden if no completed items are left ↓ --&gt;\t\t\t\t&lt;button class=&quot;clear-completed&quot; @click=&#x27;removeAllDone&#x27;&gt;清除已完成&lt;/button&gt;\t\t\t&lt;/footer&gt;\t\t\t&lt;/template&gt;\t\t&lt;/section&gt;\t\t&lt;footer class=&quot;info&quot;&gt;\t\t\t&lt;p&gt;Double-click to edit a todo&lt;/p&gt;\t\t\t&lt;!-- Remove the below line ↓ -- &gt;\t\t\t&lt;p&gt;Template by &lt;a href=&quot;http://sindresorhus.com&quot;&gt;Sindre Sorhus&lt;/a&gt;&lt;/p&gt;\t\t\t&lt;!-- Change this out with your name and url ↓ -- &gt;\t\t\t&lt;p&gt;Created by &lt;a href=&quot;http://todomvc.com&quot;&gt;you&lt;/a&gt;&lt;/p&gt;\t\t\t&lt;p&gt;Part of &lt;a href=&quot;http://todomvc.com&quot;&gt;TodoMVC&lt;/a&gt;&lt;/p&gt;\t\t\t&lt;!--  --&gt;\t\t&lt;/footer&gt;\t\t&lt;!-- Scripts here. Don&#x27;t remove ↓ --&gt;\t\t&lt;script src=&quot;node_modules/todomvc-common/base.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;node_modules/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\t\t&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\r\n至此，完成了本地Todo。\r\n4. 配置本地服务\r\n由于要在heroku上部署，这一节将使用Node创建Web服务。本节有一部分参考heroku的项目，使用的是\r\nWeb 开发框架Express\r\n通过npm下载express和ejs\r\nnpm install expressnpm install ejs\r\n在项目根目录下添加index.js。\r\nindex.jsconst express = require(&#x27;express&#x27;)const path = require(&#x27;path&#x27;)const PORT = process.env.PORT || 5000express()  .use(express.static(path.join(__dirname, &#x27;.&#x27;)))  .set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;))  .get(&#x27;/&#x27;, (req, res) =&gt; res.render(&#x27;index&#x27;))  .listen(PORT, () =&gt; console.log(`Listening on $&#123; PORT &#125;`))\r\n尝试执行命令\r\nnode index.js\r\n显示\r\nListening on 5000\r\n打开 http://localhost:5000或者http://127.0.0.1:5000访问本地服务，使用本地IP也是可以的。\r\n5. 部署到heroku\r\n部署之前需要在项目根目录添加一个文件Procfile\r\nProcfileweb: node index.js\r\n1). 通过GitHub部署\r\n先上传到Github，然后登录heroku网站在\r\nweb控制台配置里配置即可。\r\n2). 直接在本地上传部署\r\n下载Heroku\r\nCLI\r\nWindows命令heroku create ::创建git push heroku master ::部署heroku ps:scale web=1 ::运行实例heroku open ::打开预览heroku logs --tail ::网站运行日志\r\n其他可能用到的\r\nWindows命令heroku local web ::本地启动git add -ugit commit -m  &quot;Todo&quot;git push heroku master\r\n6. 后端数据库\r\n在这里使用的postgresql数据库。在heroku中添加postgresql数据库。查看文档。\r\nheroku addons:create heroku-postgresql:hobby-dev\r\n查看数据库(postgresql)。通过以下两种方式之一检索PG连接字符串\r\nheroku pg:credentials DATABASEheroku config -s | grep DATABASE_URL\r\n设置主数据库(postgresql)，如果存在多个数据库 heroku pg:promote HEROKU_POSTGRESQL_RED\r\n查看数据库使用信息 heroku pg:info\r\n7.\r\n封装对postgresql的增删改查基本操作\r\n\r\nNodejs对postgresql基本操作的封装·cheneypao·CSDN\r\n\r\nPG.jsvar pg = require(&#x27;pg&#x27;);var conString = &quot;postgres://username:password@localhost/databasename&quot;;var client = new pg.Client(conString); var PG = function()&#123;    console.log(&quot;准备向****数据库连接...&quot;);&#125;; PG.prototype.getConnection = function()&#123;    client.connect(function (err) &#123;        if (err) &#123;            return console.error(&#x27;could not connect to postgres&#x27;, err);        &#125;        client.query(&#x27;SELECT NOW() AS &quot;theTime&quot;&#x27;, function (err, result) &#123;            if (err) &#123;                return console.error(&#x27;error running query&#x27;, err);            &#125;            console.log(&quot;hbdfxt数据库连接成功...&quot;);        &#125;);    &#125;);&#125;; // 查询函数//@param str 查询语句//@param value 相关值//@param cb 回调函数var clientHelper = function(str,value,cb)&#123;    client.query(str,value,function(err,result)&#123;        if(err) &#123;            cb(&quot;err&quot;);        &#125;        else&#123;            if(result.rows != undefined)                cb(result.rows);            else                cb();        &#125;    &#125;);&#125;//增//@param tablename 数据表名称//@param fields 更新的字段和值，json格式//@param cb 回调函数PG.prototype.save = function(tablename,fields,cb)&#123;    if(!tablename) return;    var str = &quot;insert into &quot;+tablename+&quot;(&quot;;    var field = [];    var value = [];    var num = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i);        value.push(fields[i]);        num.push(&quot;$&quot;+count);    &#125;    str += field.join(&quot;,&quot;) +&quot;) values(&quot;+num.join(&quot;,&quot;)+&quot;)&quot;;    clientHelper(str,value,cb);&#125;; //删除//@param tablename 数据表名称//@param fields 条件字段和值，json格式//@param cb 回调函数PG.prototype.remove = function(tablename,fields,cb)&#123;    if(!tablename) return;    var str = &quot;delete from &quot;+tablename+&quot; where &quot;;    var field = [];    var value = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i+&quot;=$&quot; +count);        value.push(fields[i]);    &#125;    str += field.join(&quot; and &quot;);    clientHelper(str,value,cb);&#125; //修改//@param tablename 数据表名称//@param mainfields 条件字段和值，json格式//@param fields 更新的字段和值，json格式//@param cb 回调函数PG.prototype.update = function(tablename,mainfields,fields,cb)&#123;    if(!tablename) return;    var str = &quot;update &quot;+tablename+&quot; set &quot;;    var field = [];    var value = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i+&quot;=$&quot;+count);        value.push(fields[i]);    &#125;    str += field.join(&quot;,&quot;) +&quot; where &quot;;    field = [];    for(var j in mainfields)&#123;        count++;        field.push(j+&quot;=$&quot;+count);        value.push(mainfields[j]);    &#125;    str += field.join(&quot; and &quot;);    clientHelper(str,value,cb);&#125; //查询//@param tablename 数据表名称//@param fields 条件字段和值，json格式//@param returnfields 返回字段//@param cb 回调函数PG.prototype.select = function(tablename,fields,returnfields,cb)&#123;    if(!tablename) return;    var returnStr = &quot;&quot;;    if(returnfields.length == 0)        returnStr = &#x27;*&#x27;;    else        returnStr= returnfields.join(&quot;,&quot;);    var str = &quot;select &quot;+returnStr+ &quot; from &quot;+tablename+&quot; where &quot;;    var field = [];    var value = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i+&quot;=$&quot;+count);        value.push(fields[i]);    &#125;    str += field.join(&quot; and &quot;);    clientHelper(str,value,cb);&#125;; module.exports = new PG();\r\n使用方法：\r\nindex.jsvar pgclient = require(&#x27;./PG.js&#x27;);// 引用上述文件pgclient.getConnection(); // 调用上述四个函数即可pgclient.save(&#x27;userinfo&#x27;,&#123;&#x27;name&#x27;: admin&#125;,cb);\r\n创建数据库表可以在PG.js中完善。\r\n\r\n8. 后续\r\n以上的代码并不符合我的预期，在之后我对代码稍作修改。\r\n\r\n\r\njs/app.js(折叠)\r\n\r\n\r\njs/app.js(function (Vue) &#123;\tlet todos=[];    // vue实例    window.app=new Vue(&#123;        el:&#x27;#todoapp&#x27;,        data:&#123;            todos: todos,            currentEditing:null,            filterState:&#x27;all&#x27;,            toggleAllstate:true,\t\t\towner:&#x27;&#x27;,        &#125;,\t\tcreated: function () &#123;\t\t\t// this.getTodo();\t\t&#125;,        computed:&#123;            leftCount:function()&#123;                return this.todos.filter(item =&gt; !item.completed).length            &#125;,            filterTodos:function()&#123;                switch(this.filterState)&#123;                    case &#x27;active&#x27;:                        return this.todos.filter(item=&gt;!item.completed);                        break;                    case &#x27;completed&#x27;:                        return this.todos.filter(item=&gt;item.completed);                        break;                    default:                        return this.todos;                        break;                &#125;;            &#125;,            // 全选的联动效果            toggleState:function()&#123;                return this.todos.every(item=&gt;item.completed);            &#125;,        &#125;,        methods:&#123;\t\t\tgetTodo()&#123;\t\t\t\tvar _this = this;\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/getTodo&#x27;,\t\t\t\t\tparams: this.owner,\t\t\t\t&#125;).then(function(res)&#123;\t\t\t\t\t//console.log(res);\t\t\t\t\t_this.todos=[];\t\t\t\t\tres.data.forEach( (item, index) =&gt; &#123;\t\t\t\t\t\t_this.todos.push(&#123;\t\t\t\t\t\t\tid:index+1,\t\t\t\t\t\t\ttitle:item.title,\t\t\t\t\t\t\tcompleted:item.completed\t\t\t\t\t\t&#125;)\t\t\t\t\t&#125;)\t\t\t\t\tconsole.log(&#x27;获取数据库的Todos：\\n&#x27;,res.data);\t\t\t\t\tconsole.log(&#x27;_this.todos：\\n&#x27;,_this.todos);\t\t\t\t&#125;);\t\t\t&#125;,            // 设置Owner            setOwner(event)&#123;\t\t\t\tlet ownerText=event.target.value.trim();//当前文本的值\t\t\t\tif(!ownerText.length)return;\t\t\t\tthis.owner = ownerText;\t\t\t\tthis.todos=[];\t\t\t\tthis.getTodo();\t\t\t&#125;,            // 添加任务            addTodo(event)&#123;                let todoText=event.target.value.trim();//当前文本的值                if(!todoText.length)return;                const lastTodo=this.todos[this.todos.length-1];                const id=lastTodo?lastTodo.id+1:1;                this.todos.push(&#123;                    id:id,                    title:todoText,                    completed:false,\t\t\t\t\t//owner: this.owner                &#125;);\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/addTodo&#x27;,\t\t\t\t\tparams: &#123;\t\t\t\t\t\ttitle:todoText,\t\t\t\t\t\tcompleted:false,\t\t\t\t\t\towner: this.owner,\t\t\t\t\t&#125;,\t\t\t\t&#125;);                event.target.value=&#x27;&#x27;;            &#125;,            // 全部完成/全不完成            toggleAll(event)&#123;                let checked=event.target.checked                this.todos.forEach(todo =&gt; todo.completed=checked)\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/toggleAll&#x27;,\t\t\t\t\tparams: &#123;\t\t\t\t\t\tcompleted: checked,\t\t\t\t\t\towner: this.owner,\t\t\t\t\t&#125;,\t\t\t\t&#125;);            &#125;,            // check单个任务项            checkTodo(index,event)&#123;\t\t\t\tlet _this = this                let todo = this.todos[index]\t\t\t\t// todo.completed = !(todo.completed)\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/changeTodo&#x27;,\t\t\t\t\tparams: &#123;\t\t\t\t\t\tfilter:&#123;\t\t\t\t\t\t\ttitle: todo.title,\t\t\t\t\t\t\towner: _this.owner,\t\t\t\t\t\t&#125;,\t\t\t\t\t\tdata:&#123;\t\t\t\t\t\t\tcompleted: !todo.completed,\t\t\t\t\t\t&#125;,\t\t\t\t\t&#125;,\t\t\t\t&#125;)\t\t\t\t.then(function(res)&#123;_this.getTodo()&#125;);            &#125;,            // 删除单个任务项            removeTodo(delIndex,event)&#123;                let data = this.todos.splice(delIndex,1)[0];\t\t\t\tlet _this = this;\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/removeTodo&#x27;,\t\t\t\t\tparams: &#123;\t\t\t\t\t\ttitle:data.title,\t\t\t\t\t\tcompleted:data.completed,\t\t\t\t\t\towner: _this.owner,\t\t\t\t\t&#125;,\t\t\t\t&#125;)\t\t\t\t.then(function(res)&#123;_this.getTodo()&#125;);            &#125;,            // 显示所有未完成任务数(删除所有已完成)            removeAllDone()&#123;\t\t\t\tlet _this = this;                this.todos=this.todos.filter((item,index)=&gt;&#123;                    return !item.completed;//return true,即item.completed为false                &#125;);\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/removeTodo&#x27;,\t\t\t\t\tparams: &#123;\t\t\t\t\t\tcompleted:true,\t\t\t\t\t\towner: _this.owner,\t\t\t\t\t&#125;,\t\t\t\t&#125;)            &#125;,            // 保存编辑项            saveEdit(item,index,event)&#123;\t\t\t\tlet _this = this;                var editText=event.target.value.trim();                // 如果为空,直接删除这个item                if(!editText.length)&#123;\t\t\t\t\tthis.removeTodo(index,event)                    //return this.todos.splice(index,1);                &#125;                // 如果不为空,修改title的值,然后去除eiditing样式\t\t\t\taxios(&#123;\t\t\t\t   method:&#x27;get&#x27;,\t\t\t\t\turl:&#x27;/changeTodo&#x27;,\t\t\t\t\tparams: &#123;\t\t\t\t\t\tdata:&#123;\t\t\t\t\t\t\teditText:editText,\t\t\t\t\t\t&#125;,\t\t\t\t\t\tfilter:&#123;\t\t\t\t\t\t\ttitle:item.title,\t\t\t\t\t\t\towner: _this.owner,\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;,\t\t\t\t&#125;)                item.title=editText;                this.currentEditing=null;            &#125;,        &#125;,        directives:&#123;            // 局部自定义属性            editingFocus:&#123;                update(el,binding)&#123;                    if(binding.value)&#123;                        el.focus();                    &#125;                &#125;,            &#125;,\t\t\tfocus:&#123;\t\t\t\tinserted: function (el) &#123;\t\t\t\t      el.focus();\t\t\t\t&#125;\t\t\t&#125;        &#125;,    &#125;);    // 路由状态切换    window.onhashchange=function()&#123;        var hash=window.location.hash.substr(2) || &#x27;all&#x27;;        window.app.filterState=hash;    &#125;;    // 页面第一次进来,保持状态    window.onhashchange();&#125;)(Vue);\r\n\r\n\r\n\r\n\r\nindex.html (折叠)\r\n\r\n\r\nindex.html&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\t\t&lt;title&gt;Template • TodoMVC&lt;/title&gt;\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/todomvc-common/base.css&quot;&gt;\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/todomvc-app-css/index.css&quot;&gt;\t\t&lt;!-- CSS overrides - remove if you don&#x27;t need it --&gt;\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;css/app.css&quot;&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;section id=&quot;todoapp&quot; class=&quot;todoapp&quot;&gt;\t\t\t&lt;header class=&quot;header&quot;&gt;\t\t\t\t&lt;h1&gt;&lt;input class=&quot;new-todo&quot; placeholder=&quot;你的名字&quot; style=&quot;display: table-cell;width: 40%;padding: 6px 12px;color: #555;background-color: #fff;border: 1px solid #ccc;box-shadow: inset 0 1px 1px rgba(0,0,0,.075);font-size: 30px;top: -12px;&quot; @keyup.enter=&#x27;setOwner&#x27; &gt; &lt;span&gt;todos&lt;/span&gt; &lt;/h1&gt;\t\t\t\t&lt;input class=&quot;new-todo&quot; placeholder=&quot;What needs to be done?&quot; @keyup.enter=&#x27;addTodo&#x27; v-focus&gt;\t\t\t&lt;/header&gt;\t\t\t&lt;!-- This section should be hidden by default and shown when there are todos --&gt;\t\t\t&lt;template v-if=&#x27;todos.length&#x27;&gt;\t\t\t&lt;section class=&quot;main&quot;&gt;\t\t\t\t&lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot; @click=&#x27;toggleAll&#x27; v-bind:checked=&#x27;toggleState&#x27;&gt;\t\t\t\t&lt;label for=&quot;toggle-all&quot;&gt;Mark all as complete&lt;/label&gt;\t\t\t\t&lt;ul class=&quot;todo-list&quot;&gt;\t\t\t\t\t&lt;!-- These are here just to show the structure of the list items --&gt;\t\t\t\t\t&lt;!-- List items should get the class `editing` when editing and `completed` when marked as completed --&gt;\t\t\t\t\t&lt;!-- vue列表渲染 --&gt;\t\t\t\t\t&lt;li v-for=&quot;(item,index) of filterTodos&quot; v-bind:class=&#x27;&#123;completed:item.completed,editing:item===currentEditing&#125;&#x27;&gt;                        &lt;div class=&quot;view&quot;&gt;                            &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; @click=&#x27;checkTodo(index,$event)&#x27; v-model=&#x27;item.completed&#x27;&gt;                            &lt;label @dblclick=&quot;currentEditing=item&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/label&gt;                            &lt;button class=&quot;destroy&quot; @click=&#x27;removeTodo(index,$event)&#x27; &gt;&lt;/button&gt;                        &lt;/div&gt;                        &lt;input class=&quot;edit&quot; :value=&#x27;item.title&#x27; @blur=&#x27;saveEdit(item,index,$event)&#x27; @keyup.enter=&#x27;saveEdit(item,index,$event)&#x27; @keyup.esc=&#x27;currentEditing=null&#x27; v-editing-focus=&quot;item===currentEditing&quot;&gt;                    &lt;/li&gt;\t\t\t\t&lt;/ul&gt;\t\t\t&lt;/section&gt;\t\t\t&lt;!-- This footer should hidden by default and shown when there are todos --&gt;\t\t\t&lt;footer class=&quot;footer&quot;&gt;\t\t\t\t&lt;!-- This should be `0 items left` by default --&gt;\t\t\t\t&lt;span class=&quot;todo-count&quot;&gt;&lt;strong&gt;&#123;&#123;leftCount&#125;&#125;&lt;/strong&gt; 个待办&lt;/span&gt;\t\t\t\t&lt;!-- Remove this if you don&#x27;t implement routing --&gt;\t\t\t\t&lt;ul class=&quot;filters&quot;&gt;\t\t\t\t\t&lt;li&gt;\t\t\t\t\t\t&lt;a :class=&quot;&#123;selected:filterState===&#x27;all&#x27;&#125;&quot; href=&quot;#/&quot;&gt;全部&lt;/a&gt;\t\t\t\t\t&lt;/li&gt;\t\t\t\t\t&lt;li&gt;\t\t\t\t\t\t&lt;a :class=&quot;&#123;selected:filterState===&#x27;active&#x27;&#125;&quot; href=&quot;#/active&quot;&gt;未完成&lt;/a&gt;\t\t\t\t\t&lt;/li&gt;\t\t\t\t\t&lt;li&gt;\t\t\t\t\t\t&lt;a :class=&quot;&#123;selected:filterState===&#x27;completed&#x27;&#125;&quot; href=&quot;#/completed&quot;&gt;已完成&lt;/a&gt;\t\t\t\t\t&lt;/li&gt;\t\t\t\t&lt;/ul&gt;\t\t\t\t&lt;!-- Hidden if no completed items are left ↓ --&gt;\t\t\t\t&lt;button class=&quot;clear-completed&quot; @click=&#x27;removeAllDone&#x27;&gt;清除已完成&lt;/button&gt;\t\t\t&lt;/footer&gt;\t\t\t&lt;/template&gt;\t\t&lt;/section&gt;\t\t&lt;footer class=&quot;info&quot;&gt;\t\t\t&lt;p&gt;Double-click to edit a todo&lt;/p&gt;\t\t\t&lt;!-- Remove the below line ↓ -- &gt;\t\t\t&lt;p&gt;Template by &lt;a href=&quot;http://sindresorhus.com&quot;&gt;Sindre Sorhus&lt;/a&gt;&lt;/p&gt;\t\t\t&lt;!-- Change this out with your name and url ↓ -- &gt;\t\t\t&lt;p&gt;Created by &lt;a href=&quot;http://todomvc.com&quot;&gt;you&lt;/a&gt;&lt;/p&gt;\t\t\t&lt;p&gt;Part of &lt;a href=&quot;http://todomvc.com&quot;&gt;TodoMVC&lt;/a&gt;&lt;/p&gt;\t\t\t&lt;!--  --&gt;\t\t&lt;/footer&gt;\t\t&lt;!-- Scripts here. Don&#x27;t remove ↓ --&gt;\t\t&lt;script src=&quot;node_modules/todomvc-common/base.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;node_modules/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\t\t&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\r\n\r\n\r\n\r\n\r\nindex.js(折叠)\r\n\r\n\r\nindex.jsconst express = require(&#x27;express&#x27;)const app = express()const path = require(&#x27;path&#x27;)const PORT = process.env.PORT || 5000const tableNme = &#x27;todos&#x27;var cb=console.log;var pgclient = require(&#x27;./PG.js&#x27;);// 引用文件pgclient.getConnection();app.use(express.static(path.join(__dirname, &#x27;.&#x27;)))app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;))app\t.get(&#x27;/&#x27;, (req, res) =&gt; res.render(&#x27;index&#x27;))\t.get(&#x27;/getTodo&#x27;,  (req, res) =&gt; &#123; //async\t\tconsole.log(&#x27;fields:&#x27;,req.query[0])\t\tpgclient.select(tableNme,&#123;owner:req.query[0]&#125;,[&#x27;title&#x27;,&#x27;completed&#x27;],function(result)&#123;res.json(result)&#125;)\t&#125;)\t.get(&#x27;/addTodo&#x27;, (req, res) =&gt; &#123;\t\tconsole.log(&#x27;addTodo&#x27;,req.query)\t\tpgclient.save(tableNme,&#123;title:req.query.title,completed:req.query.completed,owner:req.query.owner&#125;,function(res)&#123;console.log(res)&#125;)\t\tpgclient.query(&#x27;select * from todos&#x27;,&#x27;&#x27;,cb)\t\tres.json()\t&#125;)\t.get(&#x27;/toggleAll&#x27;, (req, res) =&gt; &#123;\t\tconsole.log(&#x27;toggleAll&#x27;,req.query)\t\tpgclient.update(tableNme,&#123;owner:req.query.owner&#125;,&#123;completed:req.query.completed&#125;,function(res)&#123;console.log(res)&#125;)\t\tpgclient.query(&#x27;select * from todos&#x27;,&#x27;&#x27;,cb)\t\tres.json()\t&#125;)\t.get(&#x27;/removeTodo&#x27;, (req, res) =&gt; &#123;\t\tconsole.log(&#x27;removeTodo:&#x27;,req.query)\t\tpgclient.remove(tableNme,&#123;title: req.query.title, completed: req.query.completed, owner: req.query.owner&#125;,function(res)&#123;console.log(res)&#125;)\t\tpgclient.query(&#x27;select * from todos&#x27;,&#x27;&#x27;,cb)\t\tres.json()\t&#125;)\t.get(&#x27;/saveEdit&#x27;, (req, res) =&gt; &#123;\t\tconsole.log(&#x27;saveEdit:&#x27;,req.query)\t\tpgclient.update(tableNme,\t\t\t&#123;\t\t\t\ttitle:req.query.title,\t\t\t\towner:req.query.owner,\t\t\t&#125;,&#123;\t\t\t\tcompleted:req.query.completed,\t\t\t&#125;,function(res)&#123;\t\t\t\tconsole.log(res)\t\t\t&#125;)\t\tpgclient.query(&#x27;select * from todos&#x27;,&#x27;&#x27;,cb)\t\tres.json()\t&#125;)\t.get(&#x27;/changeTodo&#x27;, (req, res) =&gt; &#123;\t\tconsole.log(&#x27;changeTodo.query:&#x27;,req.query)\t\tpgclient.update(tableNme, JSON.parse(req.query.filter), JSON.parse(req.query.data),\t\t\tfunction(res)&#123;\t\t\t\tconsole.log(res)\t\t\t&#125;)\t\tpgclient.query(&#x27;select * from todos&#x27;,&#x27;&#x27;,cb)\t\tres.json()\t&#125;)\t// 直接在地址栏输入，以添加数据表，createTable/deletTable 这两个操作比较危险，仅建议在开发时使用\t.get(&#x27;/createTable&#x27;, (req, res) =&gt; &#123;\t\tlet que = pgclient.query(&#x27;CREATE TABLE &quot;public&quot;.&quot;todos&quot; (  &quot;id&quot; serial4 ,  &quot;title&quot; varchar(255) NOT NULL,  &quot;completed&quot; bool NOT NULL,  &quot;owner&quot; varchar(255) NOT NULL,  PRIMARY KEY (&quot;id&quot;));&#x27;,null,cb)\t\tres.send(que)\t&#125;)\t.get(&#x27;/deletTable&#x27;, (req, res) =&gt; &#123;\t\tlet que = pgclient.query(&#x27;DROP TABLE todos;&#x27;,null,cb)\t\tres.send(que)\t&#125;)app.listen(PORT, () =&gt; console.log(`Listening on $&#123; PORT &#125;`))\r\n\r\n\r\n\r\n\r\nPG.js(折叠)\r\n\r\n\r\nindex.jsvar pg = require(&#x27;pg&#x27;);//  heroku pg:credentials DATABASE //查询数据库信息// heroku config -s | grep DATABASE_URLvar conString = &quot;postgres://UesrName:PassWord@Host:Port/DataBase&quot;;var client = new pg.Client(&#123;\tconnectionString: conString,\tssl: &#123;\t\trejectUnauthorized: false\t&#125;,&#125;);var PG = function()&#123;    console.log(&quot;准备向postgres数据库连接...&quot;);&#125;;PG.prototype.getConnection = function()&#123;    client.connect(function (err) &#123;        if (err) &#123;            return console.error(&#x27;could not connect to postgres&#x27;, err);        &#125;        client.query(&#x27;SELECT NOW() AS &quot;theTime&quot;&#x27;, function (err, result) &#123;            if (err) &#123;                return console.error(&#x27;error running query&#x27;, err);            &#125;            console.log(&quot;数据库连接成功...&quot;,result.rows[0].theTime);        &#125;);    &#125;);&#125;;// 执行者函数//@param str 查询语句//@param value 相关值//@param cb 回调函数var clientHelper = function(str,value,cb)&#123;    client.query(str,value,function(err,result)&#123;        if(err) &#123;            cb(&quot;err: &quot;,err);        &#125;else&#123;            if(result.rows != undefined)                cb(result.rows);            else                 cb();        &#125;    &#125;);&#125;//增//@param tablename 数据表名称//@param fields 更新的字段和值，json格式//@param cb 回调函数PG.prototype.save = function(tablename,fields,cb)&#123;    if(!tablename) return;    var str = &quot;insert into &quot;+tablename+&quot;(&quot;;    var field = [];    var value = [];    var num = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i);        value.push(fields[i]);        num.push(&quot;$&quot;+count);    &#125;    str += field.join(&quot;,&quot;) +&quot;) values(&quot;+num.join(&quot;,&quot;)+&quot;)&quot;;\t// str += &quot;;&quot;;\t// str= &quot;insert into todos (id,title,completed) values ($1::int, $2::varchar, $3::bool)&quot;\t// value = [1,&#x27;吃饭&#x27;,false]    clientHelper(str,value,cb);&#125;;//删除//@param tablename 数据表名称//@param fields 条件字段和值，json格式//@param cb 回调函数PG.prototype.remove = function(tablename,fields,cb)&#123;    if(!tablename) return;    var str = &quot;delete from &quot;+tablename+&quot; where &quot;;    var field = [];    var value = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i+&quot;=$&quot; +count);        value.push(fields[i]);    &#125;    str += field.join(&quot; and &quot;);    clientHelper(str,value,cb);&#125;//修改//@param tablename 数据表名称//@param mainfields 条件字段和值，json格式//@param fields 更新的字段和值，json格式//@param cb 回调函数PG.prototype.update = function(tablename,mainfields,fields,cb)&#123;    if(!tablename) return;    var str = &quot;update &quot;+tablename+&quot; set &quot;;    var field = [];    var value = [];    var count = 0;    for(var i in fields)&#123;        count++;        field.push(i+&quot;=$&quot;+count);        value.push(fields[i]);    &#125;    str += field.join(&quot;,&quot;) +&quot; where &quot;;    field = [];    for(var j in mainfields)&#123;        count++;        field.push(j+&quot;=$&quot;+count);        value.push(mainfields[j]);    &#125;    str += field.join(&quot; and &quot;);    clientHelper(str,value,cb);&#125;//查询//@param tablename 数据表名称//@param fields 条件字段和值，json格式 【筛选，例如：&#123;age:25&#125;,即仅查询age=25的数据】//@param returnfields 返回字段 数组格式【表中字段名】//@param cb 回调函数PG.prototype.select = function(tablename,fields,returnfields,cb)&#123;    if(!tablename) return;    var returnStr = &quot;&quot;;    if(returnfields.length == 0)        returnStr = &#x27;*&#x27;;    else        returnStr= returnfields.join(&quot;,&quot;);    var str = &quot;select &quot;+returnStr+ &quot; from &quot;+ tablename;\tif(fields)&#123;\t\tvar field = [];\t\tvar value = [];\t\tvar count = 0;\t\tfor(var i in fields)&#123;\t\t\tcount++;\t\t\tfield.push(i+&quot;=$&quot;+count);\t\t\tvalue.push(fields[i]);\t\t&#125;\t\tstr += &quot; where &quot;+field.join(&quot; and &quot;);\t&#125;\t//str = &quot;select * from todo;&quot;;//######\t//str = &quot;DELETE FROM todo;&quot;;//######    clientHelper(str,value,cb);&#125;;//自定义//@param str SQL语句//@param value //@param cb 回调函数PG.prototype.query = function(str,value,cb)&#123;\treturn clientHelper(str,value,cb);&#125;module.exports = new PG();\r\n\r\n\r\n\r\n\r\npackage.json(折叠)\r\n\r\n\r\npackage.json&#123;  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node index.js&quot;,    &quot;test&quot;: &quot;node test.js&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;axios&quot;: &quot;^0.19.2&quot;,    &quot;body-parser&quot;: &quot;^1.19.0&quot;,    &quot;ejs&quot;: &quot;^2.7.4&quot;,    &quot;express&quot;: &quot;^4.17.1&quot;,    &quot;express-session&quot;: &quot;^1.17.1&quot;,    &quot;http-server&quot;: &quot;^0.12.3&quot;,    &quot;node-postgres&quot;: &quot;^0.6.0&quot;,    &quot;pbkdf2-password&quot;: &quot;^1.2.1&quot;,    &quot;pg&quot;: &quot;^8.2.1&quot;,    &quot;todomvc-app-css&quot;: &quot;^2.0.0&quot;,    &quot;todomvc-common&quot;: &quot;^1.0.0&quot;,    &quot;vue&quot;: &quot;^2.6.11&quot;  &#125;&#125;\r\n\r\n\r\nX. 关于登录\r\n关于登录操作官网有个示例\r\n下载两个模块\r\nnpm install pbkdf2-passwordnpm install express-session\r\n参考资料\r\n\r\nTodomvc\r\n框架入门经典项目TodoMVC·澎湃_L·博客园\r\nvuejs示例\r\nNodejs对postgresql基本操作的封装·cheneypao·CSDN\r\nHeroku\r\n使用教程\r\n使用Node.js在Heroku上开始\r\n\r\n","categories":["未分类"]},{"title":"R 实现元素排列与组合","url":"/20211027/r-%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/","content":"R 实现元素排列与组合\r\n实现组合(combination)可以使用combn(x,n)，大多时候需要转置t(combn(x,n))，x可以是向量或数字。\r\n实现元素全排列(permutation)就自己参考一部分combn()函数写了一个permt。x可以是向量或数字。\r\n permt = function (x, m) &#123;  if (is.numeric(x) &amp;&amp; length(x) == 1L &amp;&amp; x &gt; 0 &amp;&amp; trunc(x) == x) x &lt;- seq_len(x)  y = data.frame(&#x27;v1&#x27; = x)  if (m == 1) return(y)  for (i in 2:m) &#123;    y = as.data.frame(      cbind(        colname = rep(x, each=nrow(y)),        y      )    )    names(y)[names(y) == &#x27;colname&#x27;] &lt;- paste0(&quot;v&quot;,i)  &#125;  y&#125;#  一个萝卜一个坑。萝卜白菜仨个坑：permt(c(&quot;a&quot;,&#x27;b&#x27;),3)permt(c(&quot;1&quot;,&#x27;2&#x27;),3)permt(2,3)\r\n","categories":["编程语言"],"tags":["R语言"]},{"title":"Python 程序统计时间的三种方式","url":"/20210902/python-%E7%A8%8B%E5%BA%8F%E7%BB%9F%E8%AE%A1%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","content":"统计程序执行时间有三种方式： 1. datetime.datetime.now()\r\n通过当前日期计算时间差； 2.\r\ntime.time()通过时间戳计算时间差； 3.\r\ntime.clock()获取CPU执行时间 （自python38\r\n中被移除，取而替代的是 time.perf_counter() 或\r\ntime.process_time()）\r\n\r\n# 方式一import datetimestarttime = datetime.datetime.now()# ...endtime = datetime.datetime.now()print(f&quot;&#123;(endtime - starttime).seconds&#125;s&quot;)# 方式二import timestart = time.time()# ...end = time.time()print(end-start)print(f&quot;&#123;int(end-start)&#125;s&quot;)# 方式三 time.clock()start = time.clock()time.perf_counter()# ...end = time.clock()print end-start# 方式三 time.perf_counter()\r\ntime.perf_counter()\r\n（以小数表示的秒为单位）返回一个性能计数器的值，即用于测量较短持续时间的具有最高有效精度的时钟。\r\n它会包括睡眠状态所消耗的时间并且作用于全系统范围。\r\n返回值的参考点未被定义，因此只有两次调用之间的差值才是有效的。相似的，time.perf_counter_ns()返回纳秒。\r\ntime.process_time()\r\n（以小数表示的秒为单位）返回当前进程的系统和用户 CPU 时间的总计值。\r\n它不包括睡眠状态所消耗的时间。 根据定义它只作用于进程范围。\r\n返回值的参考点未被定义，因此只有两次调用之间的差值才是有效的。相似的，time.process_time_ns()返回纳秒。\r\n","categories":["编程语言"],"tags":["python"]},{"title":"没有文件扩展名 Vbs","url":"/20211102/%E6%B2%A1%E6%9C%89%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D-vbs/","content":"方式一\r\n注册表中HKEY_CLASSES_ROOT\\.vbs 将数据设置为\r\nvbsfile  \r\n\r\n方式二\r\n创建文件tmp.reg Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.vbs]@=&quot;vbsfile&quot;[HKEY_CLASSES_ROOT\\.vbs\\PersistentHandler]@=&quot;&#123;5e941d80-bf96-11cd-b579-08002b30bfeb&#125;&quot;\r\n方式三\r\n找到文件: C:\\WINDOWS\\inf\\wsh.inf， 右键“安装”；\r\n开始→运行行里输入:\r\nregsvr32 urlmon.dll shdocvw.dll jscript.dll vbscript.dll /s \r\n","categories":["编程语言"],"tags":["Vbs"]},{"title":"快速判断7的倍数","url":"/20210903/%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD7%E7%9A%84%E5%80%8D%E6%95%B0/","content":"快速判断7的倍数\n\n如果一个数被7整除，那么它减去一个7的倍数所得的结果也能被7整除。\n\n\n 两种方法\n方法一：掐掉个位再减去掐掉数字的两倍\n例： 6615\n$$\\begin&#123;aligned&#125;661 - 2 * 5 &amp;= 651 \\\\65 - 2 * 1 &amp;= 63 \\\\6 - 2 * 3 &amp;= 0 \\\\\\end&#123;aligned&#125;$$\n当然，很明显 63=7*9 。所以当最后的数字是 0 或者是 7 的倍数时，该数可以判定为 7 的倍数；否则不是 7 的倍数。\n方法二：掐掉后三位再减去掐掉的数字\n例： 2222640\n$$\\begin&#123;aligned&#125;2222 - 640 &amp;= 1582 \\\\1 - 582 &amp;= -581 \\\\\\end&#123;aligned&#125;$$\n此时再用法一，判断 581 是否为 7 的倍数\n$$\\begin&#123;aligned&#125;58 - 2 * 1 &amp;= 56 \\\\5 - 2 * 6 &amp;= -7 \\\\\\end&#123;aligned&#125;$$\n很明显， 56=7*8 ，所以 2222640 是 7 的倍数。\n 简要分析\n方法一：假设 X=10k+a1X=10k+a_1X=10k+a1​ ， (a1a_1a1​ 为个位数)，则\n$$\\begin&#123;equation&#125;\\begin&#123;aligned&#125;X-21a_1 &amp;= (10k + a_1) - 21a_1 \\\\&amp;= 10k - 20a_1 \\\\&amp;= 10(k-2a_1) \\\\\\end&#123;aligned&#125;\\end&#123;equation&#125;$$\n若 XXX 可以被7整除，则必然有 $ X’=k-2a_1$ 可以被7整除\n方法二：假设 X=1000k+a3X=1000k + a_3X=1000k+a3​， (a3a_3a3​ 为后三位数)，则\n$$\\begin&#123;equation&#125;\\begin&#123;aligned&#125;X+k-k&amp;= (1000k + a_3) +k -k \\\\&amp;= 1001k + a_3 -k \\\\&amp;= (7*11*13)·k - (k -a_3) \\\\\\end&#123;aligned&#125;\\end&#123;equation&#125;$$\n若 XXX 可以被7整除，则必然有 $ X’=k -a_3$ 可以被7整除\n","categories":["未分类"]},{"title":"在博客中插入数学公式","url":"/20210903/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","content":"参考于：Next\r\n主题 \r\n\r\n首先，在主题配置文件中设置mathjax做为渲染引擎.\r\nnext/_config.ymlmath:  ...  mathjax:    enable: true\r\n然后你需要卸载原来的渲染器hexo-renderer-marked，然后安装hexo-renderer-pandoc：\r\nnpm un hexo-renderer-marked npm i hexo-renderer-pandoc\r\n\r\n","categories":["未分类"]},{"title":"使用Django创建站点(1)","url":"/20210907/%E4%BD%BF%E7%94%A8django%E5%88%9B%E5%BB%BA%E7%AB%99%E7%82%B9-1/","content":"快速建立站点\r\n# 创建新的conda环境conda create -n django python django# 创建新站点django-admin startproject locallibrarycd locallibrary# 运行web服务器python ./manage.py runserver\r\n\r\nconda(4.10.3) 虚拟环境 - python: 3.7 - Django: 2.2.5 - mysqlclient:\r\n1.3.14\r\nmysqlclient 是可选的，没有支持最高版本的\r\nPython 。 Django 默认使用的数据库是\r\nSqlit3。\r\n\r\n学习目标…\r\n\r\n运用Django的工具创建网站和应用的框架。\r\n启动和停止开发用的服务器。\r\n创建模型（models）用来代表应用里的数据。\r\n运用Django的admin站点填充网站数据。\r\n面对不同的网络请求，创建视图函数（views）取回相应的数据。并把数据用模板（templates\r\n）渲染成HTML展示在浏览器里。\r\n创建网络分发器，将不同的URL模式分发给特定的视图函数（views）。\r\n添加用户认证和会话（sessions）管理网站行为和进入权限。\r\n使用表单。\r\n为应用编写测试。\r\n有效运用Django的安全系统。\r\n把应用布置到生产环境中。\r\n\r\n建立新的应用\r\n框架搭建网站的过程： -\r\n使用django-admin工具创建工程的文件夹，基本的文件模板和工程管理脚本（manage.py）。\r\n- 用manage.py 创建一个或多个应用。 - 在工程里注册新的应用。\r\n- 为每个应用分配url。\r\nlocallibrary项目的子文件夹是整个网站的进入点： -\r\nsettings.py\r\n包含所有的网站设置。这是可以注册所有创建的应用的地方，也是静态文件，数据库配置的地方，等等。\r\n- urls.py\r\n定义了网站url到view的映射。虽然这里可以包含所有的url，但是更常见的做法是把应用相关的url包含在相关应用中，你可以在接下来的教程里看到。\r\n- wsgi.py\r\n帮助Django应用和网络服务器间的通讯。你可以把这个当作模板。 -\r\nmanage.py\r\n脚本可以创建应用，和数据库通讯，启动开发用网络服务器。\r\n# 创建catalog应用框架python manage.py startapp catalog\r\ncatalog应用框架需要后续的补充修改，以达到自己的预期 -\r\nviews.py 视图 - models.py 模型 -\r\ntests.py 测试 - admin.py 网站管理设置\r\n- apps.py 注册应用 - migration\r\n文件夹，用来存储“migrations”——当你修改你的数据模型时，这个文件会自动升级你的数据库。\r\n- 可能需要补充 url映射，网站模板，静态文件\r\n站点的setting.py文件配置\r\n\r\nALLOWED_HOSTS 域名白名单，ALLOWED_HOSTS =\r\n[‘127.0.0.1’]\r\nINSTALLED_APPS 注册应用。 INSTALLED_APPS = [    ...,    &#x27;catalog.apps.CatalogConfig&#x27;,]\r\nDATABASES 数据库，在Django文档里找到详细的配置数据库的方法\r\nTIME_ZONE 时区\r\nTIME_ZONE = 'Asia/Shanghai'\r\nSECRET_KEY 密钥\r\nDEBUG 日志，是否在网页显示错误信息\r\n\r\n站点的urls.py文件配置\r\nURL映射器\r\n\r\n将带有 catalog/ 的请求转发到模块\r\ncatalog.urls (使用相对路径 URL\r\n/catalog/urls.py)。 # Use include() to add paths from the catalog applicationfrom django.conf.urls import includefrom django.urls import pathurlpatterns += [    path(&#x27;catalog/&#x27;, include(&#x27;catalog.urls&#x27;)),]\r\n网站的根URL(例：127.0.0.1:8000)重定向到该URL：127.0.0.1:8000/catalog/\r\n#Add URL maps to redirect the base URL to our applicationfrom django.views.generic import RedirectViewurlpatterns += [    path(&#x27;&#x27;, RedirectView.as_view(url=&#x27;/catalog/&#x27;)),]\r\n在开发期间启用静态文件的服务 # Use static() to add url mapping to serve static files during development (only)from django.conf import settingsfrom django.conf.urls.static import staticurlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\r\n\r\n数据库迁移\r\nDjango\r\n使用对象关系映射器（ORM），会跟踪更改并创建数据库迁移脚本，运行以下命令来定义数据库中这些模型的表（确保你位于包含\r\nmanage.py 的目录中): python manage.py makemigrationspython manage.py migrate\r\n每当进行重大更改时，都应重新运行迁移并重新测试站点。\r\n\r\n自此站点的整体骨架构建完成并运行，是时候开始编写代码，让这个网站做它应该做的事情了。\r\n\r\n参考文献\r\n本文依据此教程所撰\r\n","categories":["编程语言"],"tags":["Python","Django"]},{"title":"简述从 Github 构建 Conda R包","url":"/20220119/%E7%AE%80%E8%BF%B0%E4%BB%8E-github-%E6%9E%84%E5%BB%BA-conda-r%E5%8C%85/","content":"\r\n示例/目的：安装R包 NMF 环境：CentOS 7 ,\r\nMiniconda3, R 4.1.2 .\r\n\r\n\r\n正文\r\n当前 conda 里最新的 r-nmf包版本是\r\n0.21，而Github中的版本是 0.30,\r\n我所安装的某R包需要依赖 nmf&gt;=0.23\r\n为了容易复现，将创建一个新的 conda\r\n环境，同时也建议单独把构建环境隔离出来。 conda create -n conda-build conda-build conda-verifyconda skeleton cran https://github.com/renozao/NMFconda build -c conda-forge -c bioconda --R 4.1.2 r-nmfconda install -n r-base -c $&#123;CONDA_PREFIX&#125;/conda-bld r-nmf\r\n\r\n在名为 conda-build 环境里安装\r\nconda-build 包 和conda-verify（可选）\r\nconda skeleton cran 将构建一个R包的骨架包（skeleton\r\npackage 1），会从 Github缓存裸存储库（bare\r\nrepository），并在家目录~/准备conda-build配方（conda\r\nrecipe2）\r\n准备完成就可以用conda build创建conda包，此处声明了依赖的源有conda-forge和bioconda，且使用4.1.2版本的R编译。\r\n最后用conda install安装就可以了。此处生成的conda包的路径是/opt/miniconda3/envs/conda-build/conda-bld，环境变量${CONDA_PREFIX}是当前所激活的虚拟环境的路径。\r\n\r\n备注\r\n详细信息可以查 conda的官方文档\r\n/Github/各种 issue 或者\r\nconda 命令 --help\r\n\r\nconda Github NMF Github r-nmf anaconda conda-build\r\n官方文档 我常用的\r\nconda 环境–.condarc的配置\r\n\r\n\r\n\r\n\r\n在官方文档中查看 skeleton\r\npackage↩︎\r\n此处conda recipe\r\n为~/r-nmf，目录下有bld.bat\r\nbuild.sh meta.yaml 三个文件↩︎\r\n\r\n\r\n","categories":["未分类"],"tags":["Github","Conda"]},{"title":"延长Pycharm的试用时间","url":"/20220714/%E5%BB%B6%E9%95%BFpycharm%E7%9A%84%E8%AF%95%E7%94%A8%E6%97%B6%E9%97%B4/","content":"本文参考自介绍一个”牛逼闪闪”开源库：ja-netfilter\r\n仅做使用说明\r\n 我下载的是热心大佬打好的压缩包，相信你会找到的。\r\n或者在此处下载，可能需要先执行里面的卸载脚本。\r\n操作指南\r\n\r\n为整个文件夹找个合适的位置（尽量不要放在桌面或者C盘根目录）\r\n\r\n在“许可证”窗口中注销 jb 帐户\r\n\r\n配置 vmoptions\r\n\r\n自动（推荐）\r\nmacOS 或 Linux：执行 scripts/install.sh 文件\r\nWindows：执行 scripts\\install-current-user.vbs\r\n（对于当前用户）或者\r\nscripts\\install-all-users.vbs（适用于所有用户）\r\n\r\n手动\r\n找到 *.vmoptions 文件并在文件内添加\r\n-javaagent:/path/to/ja-netfilter.jar=jetbrains（绝对路径）\r\n\r\n\r\n使用页面上的密钥\r\nhttps://jetbra.in/5d84466e31722979266057664941a71893322460\r\n\r\n插件 mymap 自 2022.1 版起已弃用。 或可查询 ja-netfilter-mymap-plugin\r\n不用关心激活时间，是 fallback license，不会过期\r\n\r\n尽情享受吧~\r\n\r\n其他的配置\r\n我没有去了解这个的作用\r\nJBR17：\r\n将这两行添加到您的 vmoptions\r\n文件中：（对于手动，没有任何空白字符）\r\n–add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED\r\n–add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\r\n最后的话：\r\n\r\n只做个人学习研究之用，不得用于商业用途！\r\n\r\n若资金允许，请点击链接购买正版，谢谢合作！\r\n\r\n学生凭学生证可免费申请正版授权！\r\n\r\n创业公司可5折购买正版授权！\r\n\r\n\r\n参考\r\n\r\nhttps://zhile.io/\r\n\r\nhttps://gitee.com/ja-netfilter/ja-netfilter\r\n\r\nhttps://gitee.com/ja-netfilter/ja-netfilter-sample-plugin\r\n\r\n"},{"title":"狼人杀双身份生成","url":"/20220707/%E7%8B%BC%E4%BA%BA%E6%9D%80%E5%8F%8C%E8%BA%AB%E4%BB%BD%E7%94%9F%E6%88%90/","content":"身份牌有： 预言家 女巫 猎人 白神 守卫 禁言长老 小狼 2 隐狼 盗贼\r\n村民 6\r\n玩家8人，每人两张，两牌皆有村民牌者为金宝宝，有狼人牌者为狼人，\r\n设计一个程序完成面杀发牌及游戏过程 \r\n&#x27;&#x27;&#x27;规则：    1 玩家8人，每人两张    2 两牌皆有村民牌者为金宝宝    3 有狼人牌者为狼人    4 两张牌不能同时为狼人和预言家    5 至少有一个金宝宝    6 盗贼作为复制牌，可以视作手中的另一张身份牌。当另一个身份是村民时，视为一个金宝宝狼3 贼1 民6 预1 其他&#x27;&#x27;&#x27;import randomfrom random import shuffleres = []# 基本身份（除盗贼外）p = [&#x27;预言家&#x27;,&#x27;女巫&#x27;,&#x27;猎人&#x27;,&#x27;白神&#x27;,&#x27;守卫&#x27;,&#x27;禁言长老&#x27;,&#x27;小狼&#x27;,&#x27;隐狼&#x27;,&#x27;村民&#x27;]# 盗贼 选择的另一张身份bad_guy = random.sample(p, 1)[0] res.append([bad_guy, &#x27;盗贼&#x27;])# 盗贼 为【狼 民 预 其他】if bad_guy == &#x27;预言家&#x27;:    p.remove(&#x27;预言家&#x27;)    p += [&#x27;小狼&#x27;] + [&#x27;村民&#x27;]*2    res.append([&#x27;村民&#x27;,&#x27;村民&#x27;]) else:     # 盗贼 为【狼 民 其他】    p.remove(&#x27;预言家&#x27;)    prophet = random.sample([ i for i in p if not &#x27;狼&#x27; in i], 1)[0]    res.append([prophet, &#x27;预言家&#x27;])    # 补充身份牌    if  bad_guy != &#x27;村民&#x27;:        res.append([&#x27;村民&#x27;,&#x27;村民&#x27;])        p += [&#x27;小狼&#x27;] + [&#x27;村民&#x27;]*3    else:        p += [&#x27;小狼&#x27;] + [&#x27;村民&#x27;]*5    # 删除盗贼和预言家的另一身份牌    p.remove(bad_guy)    p.remove(prophet)# 打乱身份牌random.shuffle(p)# 两两一组 作为将要发到玩家手中的牌res += [ [p[i], p[i+1] ] for i in range(0,len(p),2) ]# 随机发放#random.shuffle(res)print(res)\r\n"},{"title":"翻译CHM文件","url":"/20210314/%E7%BF%BB%E8%AF%91chm%E6%96%87%E4%BB%B6/","content":"CHM文件是 Windows\r\n系统下的帮助文档。而它的内容大多是英文，对于四级没过的小学生很不友好，所以在这里记下翻译CHM文件的历程。\r\n 在windows下，CHM文件是调用 C:\\windows\\hh.exe\r\n来打开的，它是HTML Help Workshop命令行工具\r\n同样的，他也可以做反编译！ HH.EXE -decompile &lt;输出路径&gt;  &lt;目标chm文件&gt;\r\n虽然hh.exe\r\n可以打开CHM文件，但这个程序并没有做主要的工作，而是把参数丢给另外一个程序，然如其名呵呵\r\n\r\n\r\n\r\n参数\r\n释义\r\n\r\n\r\n\r\n\r\n-800\r\n\r\n\r\n\r\n-title\r\n\r\n\r\n\r\n-register\r\n注册hh.exe，将其设为默认的chm文档的shell\r\n\r\n\r\n-decompile\r\n反编译chm文件\r\n\r\n\r\n-mapid\r\n定位htm\r\n\r\n\r\n-safe\r\n安全模式–快捷键失效\r\n\r\n\r\n\r\n\r\n参考链接： - 逆向了一下hh.exe\r\n- hh.exe的另类用法\r\n- hh.exe参数（全）\r\n","categories":["未分类"],"tags":["CHM"]},{"title":"收藏","url":"/20190609/%E6%94%B6%E8%97%8F/","content":"\r\n\r\n图标\r\n比特虫-在线制作ico图标\r\nHexo的Next主题详细配置\r\nGithub+Hexo一站式部署个人博客\r\n(原创)\r\nhexo的next主题个性化教程:打造炫酷网站\r\nhexo-tag-aplayer\r\n腾讯云COS图床制作\r\nhexo博客常用插件及教程\r\nNext主题\r\n禁用代码段.code pre滚动条以及自动换行\r\nHexo 美化 &gt;\r\n/layout/_partials/header/brand.swig &gt; /source/css/_custom/custom.styl\r\n&gt; /source/js/custom.js &gt;\r\n/layout/_script/commons.swig\r\n免费CDN：jsDelivr+Github\r\n使用方法\r\nTag\r\nPlugins\r\n为hexo博客添加基于gitment评论功能\r\nnpm.hexo-related-popular-posts.\r\nnpm.hexo-generator-feed\r\nnpm.hexo-generator-search\r\nnpm.hexo-symbols-count-time\r\n~~一篇文章玩转世界最强音乐Spotify\r\nAPI操作 或者看简书\r\n~~\r\n超炫的HTML5\r\n3D效果\r\nHexo-Tag\r\nPlugins\r\nNexT-Tag\r\nPlugins\r\nNexT-Note\r\n路过图床\r\n网易云音乐 API\r\n\r\n","categories":["收藏"],"tags":["hide"]},{"title":"常用的Conda配置和操作","url":"/20220119/%E5%B8%B8%E7%94%A8%E7%9A%84conda%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/","content":"使用的系统\r\n以 Linux 环境为标准，windows环境另作标记说明。 # 使用的软件 miniconda\r\n， 麻雀虽小，五脏俱全！  # 用户管理 创建 miniconda\r\n组，并将用户添加到附属组。 sudo groupadd minicondasudo usermod -a -G miniconda username # 下载安装\r\n更改/opt权限，安装包下载到/opt/download，安装到/opt/miniconda3\r\nsudo chown -R :miniconda /optsudo chmod 2775 -R /optmkdir -p /opt/downloadwget -P /opt/download/  -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.shbash /opt/download/miniconda3.sh# PATH: /opt/miniconda3# conda init : no\r\n修改镜像\r\n修改文件\r\n/opt/miniconda3/.condarc，末尾是代理设置，和一句更新命令\r\nssl_verify: falseshow_channel_urls: truereport_errors: falseauto_activate_base: truealways_yes: truechannels:  - bioconda  - conda-forge  - defaultsdefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud# proxy_servers:#     http: http://127.0.0.1:10808#     https: http://127.0.0.1:10808# conda clean -i &amp;&amp; conda update --all\r\n清理并更新 conda\r\n-a 所有/ -i 索引/ -p 没有在使用的包/ -t 缓存的.tar文件/ -q\r\n安静模式/-y 钝角√ conda clean -a &amp;&amp; conda update --all conda update -base conda\r\n","categories":["未分类"],"tags":["Conda"]},{"title":"标签和分类有什么区别？","url":"/20230223/%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/","content":"博客或网站上，标签和分类都是用来对文章进行分类和组织的方式，但它们有不同的用途和区别。\r\n\r\n目的不同：分类是用来将文章分成不同的主题或类别，让读者可以更轻松地找到他们感兴趣的内容；标签则是用来描述文章内容或主题的关键词，让读者可以更方便地通过搜索或浏览方式找到相关的文章。\r\n层次不同：分类是具有层次结构的，每个分类都可以有多个子分类，这样可以更好地组织和管理文章；而标签没有层次结构，每个标签都是独立的。\r\n使用频率不同：分类一般数量较少，使用频率也比较低，每个文章只能分到一个分类下；而标签数量较多，使用频率比较高，一个文章可以有多个标签。\r\n总体来说，分类用于对文章进行粗略的整理和归类，而标签则用于对文章进行更精细的描述和细致的归档，两者结合可以更好地组织和管理博客或网站的内容。\r\n"},{"title":"数据结构与算法","url":"/20190420/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"转载\r\n\r\n\r\n前言\r\n第一部分：数据结构\r\n\r\n一、线性表\r\n二、栈和队列\r\n三、树和二叉树\r\n\r\n1. 红黑树\r\n2. 二叉树\r\n\r\n二分查找法\r\n二叉树遍历\r\n\r\n3. 二分搜索树\r\n\r\n深度优先遍历（前序、中序、后序遍历）\r\n广度优先遍历（层序遍历）\r\n\r\n4. AVL树\r\n5. B和B+\r\n\r\n四、字符串和数组\r\n\r\n第二部分：算法思想\r\n\r\n一、排序\r\n\r\n1. 选择排序（Selection\r\nSort）\r\n2. 插入排序（Insertion\r\nSort）\r\n3. 冒泡排序（Bubble Sort）\r\n4. 希尔排序（Shell Sort）\r\n5. 归并排序（Merge Sort）\r\n6. 快速排序（Quick Sort）\r\n\r\n1. 普通快速排序\r\n2. 双路快速排序\r\n3. 三路快速排序\r\n\r\n7. 堆排序（Heap Sort）\r\n\r\n1. 堆\r\n2. 上浮和下沉\r\n3.插入元素\r\n4. 删除最大元素\r\n5. 堆排序\r\n6. 堆排序的应用——Top\r\nK问题\r\n\r\n8. 计数排序和流排序\r\n9. 排序算法总结\r\n\r\n二、递归和回溯法\r\n\r\n1. 例题\r\n2. 排列问题\r\n3. 组合问题\r\n4. 回溯法的剪枝\r\n5. 二维平面回溯法\r\n6. floodfill算法\r\n\r\n三、动态规划\r\n\r\n1. 斐波那契数列\r\n\r\n1.1 递归方式（自顶向下）\r\n1.2 记忆化搜索（自底向上）\r\n1.3 动态规划\r\n\r\n2. 背包问题\r\n\r\n（1）记忆化搜索\r\n（2）动态规划\r\n（3）动态规划优化思路1\r\n（4）动态规划优化思路2\r\n（5）背包问题更多变种\r\n\r\n3. 最长上升子序列\r\n4. 最长公共子序列\r\n\r\n四、贪心算法\r\n\r\n1. assign-cookies\r\n\r\n\r\n第三部分：面试指南\r\n\r\n1. 判单链表是否对称\r\n2.\r\n合并两个有序数组成一个有序数组\r\n3.\r\n求二叉树中值为x的结点的层号\r\n阿里面经OneNote\r\n\r\n第四部分：参考资料\r\n\r\n\r\n[TOC] # 前言\r\n本文将系统总结算法面试和经典数据结构相关知识点，在这里分成\r\n【数据结构】 和 【算法】\r\n两部分展开。这里将展示主要的核心知识点，关于代码面试的Leetcode习题请转向代码仓库：Interview-code\r\n\r\n阅读书籍\r\n\r\n《算法4》\r\n《程序员代码面试指南》\r\n《剑指Offer》\r\n\r\n学习课程\r\n\r\n刘宇波：玩转数据结构，从入门到进阶\r\n刘宇波：程序员的内功修炼，学好算法与数据结构\r\n刘宇波：玩转算法面试 leetcode题库分门别类详细解析\r\n\r\n在线OJ\r\n\r\nLeetcode中国版\r\n牛客网\r\n\r\n\r\n第一部分：数据结构\r\n一、线性表\r\n\r\n数组\r\n链表\r\n\r\n二、栈和队列\r\n三、树和二叉树\r\n1. 2-3树\r\n2. 红黑树\r\n红黑树的特性:\r\n（1）每个节点或者是黑色的，或者是红色的\r\n（2）根节点是黑色的\r\n（3）每个叶子节点（NIL，最后的空结点）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\r\n（4）如果一个节点是红色的，那么他的孩子结点都是黑色的\r\n（5）从任意一个节点到叶子节点，经过的黑色节点是一样的。[这里也就可以得到插入的节点必然为红色]\r\n红黑树(一)之 原理和算法详细介绍 - 如果天空不死 - 博客园\r\nhttp://www.cnblogs.com/skywang12345/p/3245399.html\r\nJCFInternals/5-TreeSet and TreeMap.md at\r\n049c84bb65a3114ba4b8355d83c490fb9b26c6af · CarpenterLee/JCFInternals\r\nhttps://github.com/CarpenterLee/JCFInternals/blob/049c84bb65a3114ba4b8355d83c490fb9b26c6af/markdown/5-TreeSet%20and%20TreeMap.md\r\n3. 二叉树\r\n二分查找法\r\n二叉树遍历\r\n4.. 二分搜索树\r\n深度优先遍历（前序、中序、后序遍历）\r\n广度优先遍历（层序遍历）\r\n5. AVL树\r\n6. B和B+\r\n四、字符串和数组\r\n第二部分：算法思想\r\n一、排序\r\n1. 选择排序（Selection Sort）\r\n选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。\r\n\r\n代码实现\r\npublic static void sort(int[] arr) &#123;    for (int i = 0; i &lt; arr.length; i++) &#123;        // 寻找[i, n)区间里的最小值的索引        int minIndex = i;        for (int j = i + 1; j &lt; arr.length; j++) &#123;            if(arr[minIndex] &gt; arr[j])&#123;                minIndex = j;            &#125;        &#125;        swap( arr , i , minIndex);    &#125;&#125;private static void swap(int[] arr, int i, int j) &#123;    int t = arr[i];    arr[i] = arr[j];    arr[j] = t;&#125;\r\n算法分析\r\n表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。\r\n2. 插入排序（Insertion Sort）\r\n插入排序从左到右进行，每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左部数组依然有序。\r\n第 j 元素是通过不断向左比较并交换来实现插入过程：当第 j 元素小于第 j\r\n- 1 元素，就将它们的位置交换，然后令 j\r\n指针向左移动一个位置，不断进行以上操作。\r\n\r\n代码实现\r\npublic static void sort(int[] arr) &#123;    for (int i = 0; i &lt; arr.length - 1; i++) &#123;        for (int j = i + 1; j &gt; 0; j--) &#123;            if (arr[j] &lt; arr[j - 1])                swap(arr, j, j - 1); // 大量的交换会消耗时间            else                break;        &#125;    &#125;&#125;// 改进版插入排序（减少了数组元素的操作次数）public static void better_sort(int[] arr) &#123;    for (int i = 0; i &lt; arr.length; i++) &#123;        int e = arr[i];        int j = i;        for (; j &gt; 0; j--) &#123;            if (e &lt; arr[j - 1])                arr[j] = arr[j - 1];            else                break;        &#125;        arr[j] = e;    &#125;&#125;private static void swap(int[] arr, int i, int j) &#123;    int t = arr[i];    arr[i] = arr[j];    arr[j] = t;&#125;\r\n算法分析\r\n插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\r\n3. 冒泡排序（Bubble Sort）\r\n通过从左到右不断交换相邻逆序的相邻元素，在一轮的交换之后，可以让未排序的元素上浮到右侧。\r\n在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。\r\n\r\n代码实现\r\nprivate static void sort(int[] arr) &#123;    for (int i = arr.length - 1; i &gt; 0; i--) &#123; // 从最后一位开始确定        boolean swapped = false;        for (int j = 0; j &lt; i; j++) &#123;            if(arr[j] &gt; arr[j+1])&#123;                swapped = true;                swap(arr,j,j+1);            &#125;        &#125;        if(!swapped)            return;    &#125;&#125;private static void swap(int[] arr, int i, int j) &#123;    int t = arr[i];    arr[i] = arr[j];    arr[j] = t;&#125;\r\n4. 希尔排序（Shell Sort）\r\n1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\r\n算法描述\r\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\r\n\r\n选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；\r\n按增量序列个数k，对序列进行k 趟排序；\r\n每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m\r\n的子序列，分别对各子表进行直接插入排序。仅增量因子为1\r\n时，整个序列作为一个表来处理，表长度即为整个序列的长度。\r\n\r\n\r\n代码实现\r\n// 希尔排序public static void sort(int[] arr) &#123;    int n = arr.length;    for (int h = n / 2; h &gt; 0; h = h / 2) &#123;        // 内部是一个插入排序        for (int i = 0; i &lt; n; i = i + h) &#123;            int e = arr[i];            int j = i;            for (; j &gt; 0; j = j - h) &#123;                if (e &lt; arr[j - h])                    arr[j] = arr[j - h];                else                    break;            &#125;            arr[j] = e;        &#125;    &#125;&#125;// 希尔排序2public static void sort2(int[] arr) &#123;    int n = arr.length;    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...    int h = 1;    while (h &lt; n / 3) h = 3 * h + 1;    System.out.println(h);    while (h &gt;= 1) &#123;        // h-sort the array        for (int i = h; i &lt; n; i++) &#123;                        // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序            int e = arr[i];            int j = i;            for (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)                arr[j] = arr[j - h];            arr[j] = e;        &#125;        h /= 3;    &#125;&#125;\r\n算法分析\r\n对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少\r\n1。\r\n希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于\r\n1。\r\n希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令\r\nh=1，就可以使得整个数组是有序的。\r\n5. 归并排序（Merge Sort）\r\n归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。\r\n\r\n代码实现\r\n\r\n1.归并方法\r\n归并方法将数组中两个已经排序的部分归并成一个。\r\n\r\nprivate static void sort(int[] arr) &#123;    __MergeSort(arr, 0, arr.length - 1);&#125;private static void __MergeSort(int[] arr, int l, int r) &#123;    if (l &gt;= r)        return;    int mid = (l + r) / 2;    __MergeSort(arr, l, mid);    __MergeSort(arr, mid + 1, r);    merge(arr, l, mid, r);&#125;// 将arr[l...mid]和arr[mid+1...r]两部分进行归并private static void merge(int[] arr, int l, int mid, int r) &#123;    int[] aux = Arrays.copyOfRange(arr, l, r + 1);    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1    int i = l, j = mid + 1;    for (int k = l; k &lt;= r; k++) &#123;        if (i &gt; mid) &#123;  // 如果左半部分元素已经全部处理完毕            arr[k] = aux[j - l];            j++;        &#125; else if (j &gt; r) &#123;   // 如果右半部分元素已经全部处理完毕            arr[k] = aux[i - l];            i++;        &#125; else if (aux[i - l] &lt; aux[j - l]) &#123;  // 左半部分所指元素 &lt; 右半部分所指元素            arr[k] = aux[i - l];            i++;        &#125; else &#123;  // 左半部分所指元素 &gt;= 右半部分所指元素            arr[k] = aux[j - l];            j++;        &#125;    &#125;&#125;\r\n\r\n2.自底向上归并排序\r\n\r\nprivate static void sort(int[] arr) &#123;    int N = arr.length;    int[] aux = new int[N];    for (int sz = 1; sz &lt; N; sz += sz)        for (int i = 0; i + sz &lt; N; i += sz + sz)            merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, N - 1));&#125;\r\n6. 快速排序（Quick Sort）\r\n快速排序可以说是20世纪最伟大的算法之一了。相信都有所耳闻，它的速度也正如它的名字那样，是一个非常快的算法了。当然它也后期经过了不断的改进和优化，才被公认为是一个值得信任的非常优秀的算法。\r\n\r\n代码实现\r\n1. 普通快速排序\r\n// 递归使用快速排序,对arr[l...r]的范围进行排序public static void QuickSort(int[] arr,int l,int r)&#123;    if(l&gt;=r)        return;    int p = partition(arr,l,r);    QuickSort(arr,l,p-1);    QuickSort(arr,p+1,r);&#125;// 将数组通过p分割成两部分// 对arr[l...r]部分进行partition操作// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]public static int partition(int[] arr, int l, int r) &#123;    swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);  // 加入这一行变成随机快速排序    int v = arr[l];    int j = l;    for(int i = j +1;i&lt;=r;i++)&#123;        if(arr[i] &lt; v)&#123;            j++;            swap(arr,i,j);        &#125;    &#125;    swap(arr,l,j);    return j;&#125;public static void swap(int[] arr,int i,int j) &#123;    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;\r\n快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。\r\n快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为\r\nCN=2CN/2+N，复杂度为 O(NlogN)。\r\n最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较\r\nN2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。\r\n2. 双路快速排序\r\n若果数组中含有大量重复的元素，则partition很可能把数组划分成两个及其不平衡的两部分，时间复杂度退化成O(n²)。这时候应该把小于v和大于v放在数组两端。\r\n\r\n// 双路快速排序的partition// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]private static int partition(int[] arr, int l, int r) &#123;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    // swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);    int v = arr[l];    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v    int i = l + 1, j = r;    while (true) &#123;        // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0        // 思考一下为什么?        while (i &lt;= r &amp;&amp; arr[i] &lt; v)            i++;        // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0        // 思考一下为什么?        while (j &gt;= l + 1 &amp;&amp; arr[j] &gt; v)            j--;        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html        if (i &gt; j)            break;                swap(arr, i, j);        i++;        j--;    &#125;    swap(arr, l, j);    return j;&#125;// 递归使用快速排序,对arr[l...r]的范围进行排序private static void QuickSort2Ways(int[] arr, int l, int r) &#123;    // 对于小规模数组, 使用插入排序    if (l &gt;= r) return;    int p = partition(arr, l, r);    QuickSort2Ways(arr, l, p - 1);    QuickSort2Ways(arr, p + 1, r);&#125;\r\n3. 三路快速排序\r\n数组分成三个部分，大于v 等于v 小于v\r\n在具有大量重复键值对的情况下使用三路快排\r\n\r\n// 递归使用快速排序,对arr[l...r]的范围进行排序private static void QuickSort3Ways(int[] arr, int l, int r)&#123;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr, l, (int)(Math.random()*(r-l+1)) + l );    int v = arr[l];    int lt = l;     // arr[l+1...lt] &lt; v    int gt = r + 1; // arr[gt...r] &gt; v    int i = l+1;    // arr[lt+1...i) == v    while( i &lt; gt )&#123;        if( arr[i] &lt; v)&#123;            swap( arr, i, lt+1);            i ++;            lt ++;        &#125;        else if( arr[i] &gt; v )&#123;            swap( arr, i, gt-1);            gt --;        &#125;        else&#123; // arr[i] == v            i ++;        &#125;    &#125;    swap( arr, l, lt );    QuickSort3Ways(arr, l, lt-1);    QuickSort3Ways(arr, gt, r);&#125;\r\n7. 堆排序（Heap Sort）\r\n1. 堆\r\n堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。\r\n堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置\r\nk 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和\r\n2k+1。这里不使用数组索引为 0\r\n的位置，是为了更清晰地描述节点的位置关系。\r\n\r\n2. 上浮和下沉\r\n在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮（ShiftUp）。\r\n\r\nprivate void shiftUp(int k)&#123;    while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k]))&#123;        swap(k, k/2);        k /= 2;    &#125;&#125;\r\n类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉（Shift\r\nDown）。一个节点如果有两个子节点，应当与两个子节点中最大那么节点进行交换。\r\n\r\nprivate void shiftDown(int k)&#123;    while( 2*k &lt;= count )&#123; // 当前结点有左孩子        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )            j ++;        // data[j] 是 data[2*k]和data[2*k+1]中的最大值        if( data[k] &gt;= data[j] )             break;        swap(k, j);        k = j;    &#125;&#125;\r\n3.插入元素\r\n将新元素放到数组末尾，然后上浮到合适的位置。\r\n// 向最大堆中插入一个新的元素 itempublic void insert(Item item)&#123;    assert count + 1 &lt;= capacity;    data[count+1] = item;    count ++;    shiftUp(count);&#125;\r\n4. 删除最大元素\r\n// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据public Item extractMax()&#123;    assert count &gt; 0;    Item ret = data[1];        swap( 1 , count );    count --;    shiftDown(1);    return ret;&#125;\r\n5. 堆排序\r\n由于堆可以很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列。因此很容易使用堆来进行排序。并且堆排序是原地排序，不占用额外空间。\r\n// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序public class HeapSort &#123;    // 对整个arr数组使用HeapSort1排序    // HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序    // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)    // 整个堆排序的整体时间复杂度为O(nlogn)    public static void sort1(Comparable[] arr)&#123;        int n = arr.length;        MaxHeap&lt;Comparable&gt; maxHeap = new MaxHeap&lt;Comparable&gt;(n);        for( int i = 0 ; i &lt; n ; i ++ )            maxHeap.insert(arr[i]);        for( int i = n-1 ; i &gt;= 0 ; i -- )            arr[i] = maxHeap.extractMax();    &#125;    // 只通过shiftDown操作进行排序    public static void sort2(Comparable[] arr)&#123;        int n = arr.length;        // 注意，此时我们的堆是从0开始索引的        // 从(最后一个元素的索引-1)/2开始        // 最后一个元素的索引 = n-1        for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )            shiftDown2(arr, n, i);        for( int i = n-1; i &gt; 0 ; i-- )&#123; // 这个的目的是让序列从小到大排序            swap( arr, 0, i);            shiftDown2(arr, i, 0);        &#125;    &#125;    // 交换堆中索引为i和j的两个元素    private static void swap(Object[] arr, int i, int j)&#123;        Object t = arr[i];        arr[i] = arr[j];        arr[j] = t;    &#125;    // 原始的shiftDown过程    private static void shiftDown(Comparable[] arr, int n, int k)&#123;        while( 2*k+1 &lt; n )&#123;            int j = 2*k+1;            if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )                j += 1;            if( arr[k].compareTo(arr[j]) &gt;= 0 )break;            swap( arr, k, j);            k = j;        &#125;    &#125;    // 优化的shiftDown过程, 使用赋值的方式取代不断的swap,    // 该优化思想和我们之前对插入排序进行优化的思路是一致的    private static void shiftDown2(Comparable[] arr, int n, int k)&#123;        Comparable e = arr[k];        while( 2*k+1 &lt; n )&#123;            int j = 2*k+1;            if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )                j += 1;            if( e.compareTo(arr[j]) &gt;= 0 )                break;            arr[k] = arr[j];            k = j;        &#125;        arr[k] = e;    &#125;    // 测试 HeapSort    public static void main(String[] args) &#123;        Integer[] arr = &#123;10, 91, 8, 7, 6, 5, 4, 3, 2, 1&#125;;        HeapSort.sort2(arr);        PrintHelper.printArray(arr);    &#125;&#125;\r\n6. 堆排序的应用——Top K问题\r\n例如，有1亿个浮点数，如何找出其中最大的10000个？（B326）\r\n8. 计数排序\r\nhttps://www.cnblogs.com/freedom314/p/5847092.html\r\n9. 排序算法总结\r\n\r\n\r\n\r\n\r\n平均时间复杂度\r\n原地排序\r\n额外空间\r\n稳定排序\r\n\r\n\r\n\r\n\r\n插入排序\r\nO(n^2)\r\n√\r\nO(1)\r\n√\r\n\r\n\r\n归并排序\r\nO(nlogn)\r\n×\r\nO(n)\r\n√\r\n\r\n\r\n快速排序\r\nO(nlogn)\r\n√\r\nO(logn)\r\n×\r\n\r\n\r\n堆排序\r\nO(nlogn)\r\n√\r\nO(1)\r\n×\r\n\r\n\r\n\r\n稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生变化。\r\n// 可以通过⾃自定义⽐比较函数，让排序算法不不存在稳定性的问题。bool operator&lt;(const Student&amp; otherStudent)&#123;    return score != otherStudent.score ?    score &gt; otherStudent.score :    name &lt; otherStudent.name;&#125;\r\n\r\n二、递归和回溯法\r\n1. 例题\r\n2. 排列问题\r\n3. 组合问题\r\n4. 回溯法的剪枝\r\n5. 二维平面回溯法\r\n6. floodfill算法\r\n三、动态规划\r\n递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。\r\n动态规划一般可分为4类：\r\n\r\n线性动规\r\n区域动规\r\n树形动规\r\n背包动规\r\n\r\n以198. House Robber为例，动态规划的状态定义和状态转移方程如下：\r\n注意其中对状态的定义：\r\n\r\n考虑偷取 [x…n-1] 范围⾥里里的房子 （函数的定义）\r\n\r\n根据对状态的定义，决定状态的转移：\r\n\r\nf(0) = max{ v(0) + f(2) , v(1) + f(3) , v(2) + f(4) , … ,v(n-3) +\r\nf(n-1) , v(n-2),v(n-1) }\r\n\r\n(状态转移方程)\r\n\r\n1. 斐波那契数列\r\n1.1 递归方式（自顶向下）\r\npublic int fib( int n )&#123;    if( n == 0 )        return 0;    if( n == 1 )        return 1;    return fib(n-1) + fib(n-2);&#125;//控制台输出fib(42) = 267914296time : 1949 msrun function fib() 866988873 times.\r\n1.2 记忆化搜索（自底向上）\r\npublic int fib(int n)&#123;    int[] memo = new int[n + 1];    Arrays.fill(memo, -1);    return fib(n, memo);&#125;private int fib(int n, int[] memo)&#123;    if(n == 0)        return 0;    if(n == 1)        return 1;    if(memo[n] == -1)        memo[n] = fib(n - 1, memo) + fib(n - 2, memo);    return memo[n];&#125;//控制台输出fib(1000) = 1556111435time : 1 msrun function fib() 1999 times.\r\n1.3 动态规划\r\npublic int fib(int n)&#123;    int[] memo = new int[n + 1];    Arrays.fill(memo, -1);    memo[0] = 0;    memo[1] = 1;    for(int i = 2 ; i &lt;= n ; i ++)        memo[i] = memo[i - 1] + memo[i - 2];    return memo[n];&#125;\r\n2. 背包问题\r\n先得到该问题的局部解然后扩展到全局问题解。\r\n我们可以假设一个B(k,C)\r\n方法，第k件物品，当前背包所剩下的容量C（初始则C=W）情况下，能够偷的最大价值量。\r\nB( i , c ) = max{ F( i - 1 , C ) , v(i) + F( i - 1, C - w[i] ) };\r\n（1）记忆化搜索\r\n/** * 记忆化搜索 * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积 * 空间复杂度: O(n * C) */public class Solution01 &#123;    private static int count = 0;    private static int[][] memo;    public int knapsack(int[] w, int[] v, int C) &#123;        int n = w.length;        memo = new int[n][C + 1];        for(int i = 0;i&lt;n;i++)            Arrays.fill(memo[i],-1);        return bestValue(w, v, n - 1, C);    &#125;    // 用 [0...index]的物品,填充容积为c的背包的最大价值    private int bestValue(int[] w, int[] v, int i, int C) &#123;        count++;        if (i &lt; 0 || C &lt;= 0)            return 0;        if (memo[i][C] != -1) // 记忆化搜索            return memo[i][C];        int res = 0;        res = bestValue(w, v, i - 1, C);        if (C &gt;= w[i])            res = max(res, v[i] + bestValue(w, v, i - 1, C - w[i]));        return memo[i][C] = res;    &#125;    private int max(int a, int b) &#123;        return a &gt; b ? a : b;    &#125;    public static void main(String[] args) &#123;        int[] w = &#123;5,4,6,3&#125;;        int[] v = &#123;10,40,30,50&#125;;        System.out.println(new Solution01().knapsack(w, v, 10));        System.out.println(&quot;count of bestValue() exec：&quot; + count);        PrintHelper.print2DArray(memo);    &#125;&#125;\r\n（2）动态规划\r\n\r\n\r\n\r\n\r\n/** * 动态规划 * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积 * 空间复杂度: O(n * C) */public class Solution02 &#123;    public int knapsack(int[] w, int[] v, int C) &#123;        int n = w.length;        int[][] memo = new int[n][C + 1];        if (n == 0 || C == 0)            return 0;        for (int j = 0; j &lt;= C; j++)            memo[0][j] = (j &gt;= w[0] ? v[0] : 0);        for (int i = 1; i &lt; n; i++) &#123;            for (int j = 0; j &lt;= C; j++) &#123;                memo[i][j] = memo[i - 1][j];                if (j &gt;= w[i]) &#123;                    memo[i][j] = max(memo[i][j], v[i] + memo[i - 1][j - w[i]]);                &#125;            &#125;        &#125;        return memo[n - 1][C];    &#125;    private int max(int a, int b) &#123;        return a &gt; b ? a : b;    &#125;    public static void main(String[] args) &#123;        int[] w = &#123;1, 2, 3&#125;;        int[] v = &#123;6, 10, 12&#125;;        int C = 5;        System.out.println(new Solution02().knapsack(w, v, C));    &#125;&#125;\r\n（3）动态规划优化思路1\r\n优化思路：第i行元素只依赖于第i-1行元素，理论上，只需要保持两行元素即可\r\n\r\n\r\n\r\n\r\n/// 动态规划改进: 滚动数组/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积/// 空间复杂度: O(C), 实际使用了2*C的额外空间public class Solution1 &#123;    public int knapsack01(int[] w, int[] v, int C)&#123;        if(w == null || v == null || w.length != v.length)            throw new IllegalArgumentException(&quot;Invalid w or v&quot;);        if(C &lt; 0)            throw new IllegalArgumentException(&quot;C must be greater or equal to zero.&quot;);        int n = w.length;        if(n == 0 || C == 0)            return 0;        int[][] memo = new int[2][C + 1];        for(int j = 0 ; j &lt;= C ; j ++)            memo[0][j] = (j &gt;= w[0] ? v[0] : 0);        for(int i = 1 ; i &lt; n ; i ++)            for(int j = 0 ; j &lt;= C ; j ++)&#123;                memo[i % 2][j] = memo[(i-1) % 2][j];                if(j &gt;= w[i])                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i-1) % 2][j - w[i]]);            &#125;        return memo[(n-1) % 2][C];    &#125;&#125;\r\n（4）动态规划优化思路2\r\n\r\n\r\n\r\n\r\n/// 动态规划改进/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积/// 空间复杂度: O(C), 只使用了C的额外空间public class Solution2 &#123;    public int knapsack01(int[] w, int[] v, int C)&#123;        if(w == null || v == null || w.length != v.length)            throw new IllegalArgumentException(&quot;Invalid w or v&quot;);        if(C &lt; 0)            throw new IllegalArgumentException(&quot;C must be greater or equal to zero.&quot;);        int n = w.length;        if(n == 0 || C == 0)            return 0;        int[] memo = new int[C+1];        for(int j = 0 ; j &lt;= C ; j ++)            memo[j] = (j &gt;= w[0] ? v[0] : 0);        for(int i = 1 ; i &lt; n ; i ++)            for(int j = C ; j &gt;= w[i] ; j --)                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);        return memo[C];    &#125;&#125;\r\n（5）背包问题更多变种\r\n\r\n多重背包问题：每个物品不不⽌止1个，有num(i)个\r\n完全背包问题：每个物品可以⽆无限使⽤用\r\n多维费⽤用背包问题：要考虑物品的体积和重量量两个维度？\r\n物品间加⼊入更更多约束：物品间可以互相排斥；也可以互相依赖\r\n\r\n3. 最长上升子序列\r\nLongest Increasing Subsequence (LIS)\r\n【Leetcode 300】最长上升子序列\r\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\r\n示例:\r\n输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\r\n说明:\r\n\r\n可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\r\n你算法的时间复杂度应该为 O(n2) 。\r\n\r\n进阶: 你能将算法的时间复杂度降低到 O(n log\r\nn) 吗?\r\nLIS( i ) 表示以第 i 个数字为结尾的最长上升子序列的长度\r\nLIS( i ) 表示 [0…i]\r\n的范围内，选择数字nums[i]可以获得的最长上升子序列的长度\r\nLIS ( i ) = maxj&lt;i( 1 + LIS( j ) if nums[i] &gt;\r\nnums[j] )\r\npublic class Solution &#123;    public int lengthOfLIS(int[] nums) &#123;        int n = nums.length;        if (n==0) &#123;            return 0;        &#125;        int res = 1;        int[] memo = new int[n];        Arrays.fill(memo, 1);        for (int i = 1; i &lt; n; i++) &#123;            for (int j = 0; j &lt; i; j++) &#123;                if (nums[j] &lt; nums[i])                    memo[i] = max(memo[i] , memo[j]+1);            &#125;        &#125;        for(int i = 0;i&lt;n;i++)&#123;            res = max(memo[i],res);        &#125;        return res;    &#125;    private int max(int a, int b) &#123;        return a &gt; b ? a : b;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;10, 9, 2, 5, 3, 7, 101, 18&#125;;        System.out.println(new Solution().lengthOfLIS(arr));    &#125;&#125;\r\n这里思考一个问题：在上面的代码中只求解出了上升子序列的长度，那么如何求出具体的上升子序列呢？\r\npublic class Solution2 &#123;    private static List&lt;Integer&gt; LISindex = new ArrayList&lt;&gt;(); // 记录一下有几个上升子序列    public List&lt;List&lt;Integer&gt;&gt; lengthOfLIS(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;();        int n = nums.length;        if (n == 0) &#123;            return null;        &#125;        int res = 1;        int[] memo = new int[n];        Arrays.fill(memo, 1);        for (int i = 1; i &lt; n; i++) &#123;            for (int j = 0; j &lt; i; j++) &#123;                if (nums[j] &lt; nums[i])                    memo[i] = max(memo[i], memo[j] + 1);            &#125;        &#125;        for (int i = 0; i &lt; n; i++) &#123;            res = max(memo[i], res);        &#125;        for (int i = 0; i &lt; n; i++) &#123;            if (memo[i] == res)                LISindex.add(i); // 遍历一下最长子序列最后一位是谁，统计一共有多少个子序列        &#125;        for (int lastIndex : LISindex) &#123;            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();            int nowMemoCount = memo[lastIndex];            for (int i = lastIndex; i &gt;= 0; i--) &#123;                if (nowMemoCount - memo[i] == 1 || nowMemoCount - memo[i] == 0) &#123;                    list.add(nums[i]);                    nowMemoCount--;                &#125;            &#125;            resList.add(reverseList(list));        &#125;        return resList;    &#125;    private int max(int a, int b) &#123;        return a &gt; b ? a : b;    &#125;    private List&lt;Integer&gt; reverseList(ArrayList&lt;Integer&gt; list) &#123;        List&lt;Integer&gt; newList = new ArrayList&lt;&gt;();        for (int i = list.size() - 1; i &gt;= 0; i--) &#123;            newList.add(list.get(i));        &#125;        return newList;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;10, 9, 2, 5, 3, 7, 101, 18&#125;;        System.out.println(new Solution2().lengthOfLIS(arr));    &#125;&#125;\r\n4. 最长公共子序列\r\nLongest Common Sequence\r\n(LCS)：给出两个字符串S1和S2，求这两个字符串的最长公共子序列的长度\r\nLCS( m , n ) S1[0…m] 和 S2[0…n] 的最长公共子序列的长度\r\nS1[m] == S2[n] :\r\nLCS(m,n) = 1 + LCS(m-1,n-1)\r\nS1[m] != S2[n] :\r\nLCS(m,n) = max( LCS(m-1,n) , LCS(m,n-1) )\r\n\r\n\r\n\r\n\r\n/** * 最长公共子序列 */public class Solution3 &#123;    public int LCS(String s1, String s2) &#123;        return bestLength(s1, s2, s1.length() - 1, s2.length() - 1);    &#125;    public int bestLength(String s1, String s2, int m, int n) &#123;        if (m &lt; 0 || n &lt; 0)            return 0;        int lcs = 0;        if (s1.charAt(m) == s2.charAt(n)) &#123;            lcs = 1 + bestLength(s1, s2, m - 1, n - 1);        &#125; else &#123;            lcs = max(bestLength(s1, s2, m - 1, n), bestLength(s1, s2, m, n - 1));        &#125;        return lcs;    &#125;    private int max(int a, int b) &#123;        return a &gt; b ? a : b;    &#125;    public static void main(String[] args) &#123;        System.out.println(new Solution3().LCS(&quot;ABCDEE&quot;, &quot;ABDCEE&quot;));    &#125;&#125;\r\n参考资料：\r\n\r\n动态规划解决01背包问题\r\n- Christal_R - 博客园\r\n【经典算法】01背包问题_土豆视频\r\n\r\n四、贪心算法\r\n1. assign-cookies\r\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子\r\ni ，都有一个胃口值 gi\r\n，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸\r\nsj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i\r\n，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\r\n注意：\r\n你可以假设胃口值为正。 一个小朋友最多只能拥有一块饼干。\r\n示例 1:\r\n输入: [1,2,3], [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。\r\n示例 2:\r\n输入: [1,2], [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.\r\npublic class Solution &#123;    public int findContentChildren(int[] g, int[] s) &#123;        int res = 0;        Arrays.sort(g);        Arrays.sort(s);        for (int i = g.length - 1; i &gt;= 0; i--) &#123;            for (int j = s.length - 1; j &gt;= 0; j--) &#123;                if(s[j] &gt;= g[i])&#123;                    res ++;                    s[j] = 0;                    break;                &#125;            &#125;        &#125;        return res;    &#125;    public static void main(String[] args) &#123;        int res =  new Solution().findContentChildren(new int[]&#123;1,2,3&#125;, new int[]&#123;3&#125;);        System.out.println(res);    &#125;&#125;\r\n第三部分：面试指南\r\n1. 判单链表是否对称\r\n\r\n网易有道面经\r\n\r\n原题：设单链表中存放着 n\r\n个字符，设计算法并判断字符是否中心对称，如 “xyzzyx” 是中心对称的。\r\n思路1：可先将字符串中的全部字符进栈，然后再将栈中的字符逐个与链表中的字符进行比较，如全部相等，则为中心对称。\r\n思路2：将单链表的前一半元素依次入栈，遍历到单链表的后一半元素的第一个元素时，便从栈中弹出一个元素，对它们俩开始比较。\r\n\r\n若相等，则将链表中的下一个元素与栈中再次弹出的元素进行比较，直至单链表到末尾，而且如果此时栈也为空栈，则可得出此单链表是中心对称的结论；\r\n若不相等，则单链表不是中心对称。\r\n\r\n2.\r\n合并两个有序数组成一个有序数组\r\n\r\n金山云面经\r\n\r\n有两种实现思路：\r\n\r\n定义一个新数组，长度为两个数组长度之和，将两个数组都 copy\r\n到新数组，然后排序。\r\n给两个数组分别定义一个下标，最大长度是数组长度减一，按位循环比较两个数组，较小元素的放入新数组，下标加一（注意，较大元素对应的下标不加一），直到某一个下标超过数组长度时退出循环，此时较短数组已经全部放入新数组，较长数组还有部分剩余，最后将剩下的部分元素放入新数组，大功告成。\r\n\r\n3. 求二叉树中值为x的结点的层号\r\n\r\n金山云面经\r\n\r\n思路：利用访问二叉树的路径过程求解（PS：这里不是说遍历过程，是访问过程，无论前中后序遍历，访问过程都是要经过通一结点三次），利用level变量记录访问过程中的层号，递归返回要减一；\r\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123;    ElementType Data;    BinTree Left;    BinTree Right;&#125;;BinTree CreatBinTree(); /* 实现细节忽略 */void level_in_x(BinTree BT,char x,int level);int main()&#123;    int level = 1;    BinTree BT = CreatBinTree();    level_in_x(BT,&#x27;H&#x27;,level);    return 0;&#125;//静态建树BinTree CreatBinTree()&#123;    BinTree pa = (BinTree)malloc(sizeof(struct TNode));    BinTree pb = (BinTree)malloc(sizeof(struct TNode));    BinTree pc = (BinTree)malloc(sizeof(struct TNode));    BinTree pd = (BinTree)malloc(sizeof(struct TNode));    BinTree pe = (BinTree)malloc(sizeof(struct TNode));    BinTree pf = (BinTree)malloc(sizeof(struct TNode));    BinTree pg = (BinTree)malloc(sizeof(struct TNode));    BinTree ph = (BinTree)malloc(sizeof(struct TNode));    BinTree pi = (BinTree)malloc(sizeof(struct TNode));    pa-&gt;Data = &#x27;A&#x27;;    pb-&gt;Data = &#x27;B&#x27;;    pc-&gt;Data = &#x27;C&#x27;;    pd-&gt;Data = &#x27;D&#x27;;    pe-&gt;Data = &#x27;E&#x27;;    pf-&gt;Data = &#x27;F&#x27;;    pg-&gt;Data = &#x27;G&#x27;;    ph-&gt;Data = &#x27;H&#x27;;    pi-&gt;Data = &#x27;I&#x27;;    pa-&gt;Left = pb; pa-&gt;Right = pc;    pb-&gt;Left = pd; pb-&gt;Right = pf;    pc-&gt;Left = pg; pc-&gt;Right = pi;    pd-&gt;Left = NULL; pd-&gt;Right = NULL;    pe-&gt;Left = NULL; pe-&gt;Right = NULL;    pf-&gt;Left = pe; pf-&gt;Right = NULL;    pg-&gt;Left = NULL; pg-&gt;Right = ph;    ph-&gt;Left = NULL; ph-&gt;Right = NULL;    pi-&gt;Left = NULL; pi-&gt;Right = NULL;    return pa;&#125;void level_in_x(BinTree BT,char x,int level)&#123;    if (BT == NULL)&#123;        return ;    &#125;    if(BT-&gt;Data == x)&#123;        printf(&quot;x in %d&quot;,level);    &#125;    level++;    level_in_x(BT-&gt;Left,x,level);    level_in_x(BT-&gt;Right,x,level);    level--;&#125;\r\n阿里面经OneNote\r\n\r\n如何判断一个单链表是否有环？ \r\n快速排序，过程，复杂度？什么情况下适用，什么情况下不适用？\r\n什么是二叉平衡树，如何插入节点，删除节点\r\n二分搜索的过程\r\n归并排序的过程？时间复杂度？空间复杂度？\r\n给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少\r\n给你一个数组，如何里面找到和为K的两个数\r\n100000个数找出最小或最大的10个？\r\n一堆数字里面继续去重，要怎么处理？阅读 RFC2616 文档，即 HTTP/1.1\r\n规范，输入某个网址，利用 Java 的 Socket 发送 HTTP请求，特别要求能够解码\r\nchunked\r\n编码，观察文档中的伪代码实现，自己用Java代码实现，将解析后的整个html文档输出到控制台上，不要求关注太多细节。(就是不允许用httpclient的jar包，自行实现这个jar包类似的功能)\r\n\r\n第四部分：参考资料\r\n\r\n数据结构与算法系列\r\n目录 - 如果天空不死 - 博客园\r\nInterview-Notebook/算法.md\r\nat master · CyC2018/Interview-Notebook\r\n十大经典排序算法\r\nVisuAlgo - visualising data\r\nstructures and algorithms through animation\r\nData\r\nStructure Visualization\r\n海量数据处理：十道面试题与十个海量数据处理方法总结\r\n- chenhuan001 - 博客园\r\n\r\n","categories":["收藏"],"tags":["hide"]},{"title":"Github 使用指南","url":"/20230223/github-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"一. 介绍\r\nGithub是一个全球最大的代码托管平台，也是一个开源软件开发社区，它为程序员、开发者和团队提供了一个基于互联网的集中式代码管理工具。它使用Git作为基础技术，并提供了一系列功能强大的协作和开发工具，例如问题跟踪、代码审核、版本控制、分支管理等等。\r\nGithub最初是由美国程序员Tom Preston-Werner和Chris Wanstrath以及P. J.\r\nHyett在2008年4月创建的，当时它只是一个简单的Web应用程序，用于管理和分享代码。随着开源软件的普及和互联网的发展，Github迅速成为全球最受欢迎的代码托管平台之一，目前拥有超过6000万的开发者和超过1.5亿个代码仓库。\r\n\r\n\r\n主要用途\r\n\r\n代码托管：开发者可以将代码存储在Github上，并通过Git进行版本控制和协作开发。\r\n项目管理：Github提供了强大的项目管理功能，包括任务分配、问题追踪和代码审核等。\r\n文档管理：开发者可以使用Github来存储和共享文档，如API文档、用户手册等。\r\n博客托管：开发者可以使用Github\r\nPages来搭建静态博客，将博客页面托管在Github上。\r\n开源社区：Github是一个开源社区，开发者可以通过贡献开源项目来提升自己的技能和声誉。\r\n\r\n优势\r\n\r\n分布式版本控制：Github使用Git进行版本控制，具有分布式版本控制的优势，可以避免单点故障和数据丢失。\r\n开放性和透明度：Github是一个开源社区，任何人都可以访问和查看公开的项目和代码，提高了透明度和开放性。\r\n协作和共享：Github提供了强大的协作和共享功能，开发者可以轻松地与团队成员、同行和其他开发者协作开发。\r\n社区和生态系统：Github是一个庞大的开源社区，包括众多开源项目和开发者，开发者可以从中受益，并提高\r\n自己的技能和经验。\r\n强大的工具和服务：Github提供了许多强大的工具和服务，如CI/CD、自动化部署、代码审核、问题追踪和Wiki等，可以帮助开发者提高效率和质量。\r\n\r\nGithub的基本概念\r\n仓库(repository)：指存储项目代码和文件的地方。一个仓库可以包含多个文件和文件夹，并记录项目历史和版本信息。\r\n分支(branch)：指在仓库中创建的一个代码版本。通过创建分支，可以在不影响主干代码的情况下进行实验和修改。\r\n提交(commit)：指将修改过的文件和文件夹保存到仓库中的操作。每个提交都会包含一条描述修改内容的信息。\r\n合并(merge)：指将一个分支的代码合并到另一个分支或主干代码中的操作。\r\n发布(Release)：指的是将特定版本的代码或文件打包并发布到\r\nGitHub，这些版本可以用来对外发布项目的稳定版本、发布更新等。\r\n发布(publish)：一般指将静态网站发布到 GitHub Pages。 拉取请求(pull\r\nrequest)：指在 Github\r\n上发起的一项合并请求，通常由分支的创建者向项目的维护者发起，请求合并分支代码到主干分支。\r\n问题(Issue)：指在 Github\r\n上的一个问题跟踪系统，可以用于报告软件缺陷、请求新功能或讨论项目问题等。\r\n派生(Fork)：指的是复制某个仓库到自己的 GitHub\r\n帐号下。在自己的帐号下进行修改、提交变更等操作不会影响到原始的项目。如果希望你所做的修改能够贡献给原始项目，你可以提交\r\nPull Request 给原作者，让他来评审并接受你的修改。 （发布） Github\r\nPages：是 GitHub 提供的一项免费的静态网站托管服务。\r\n二、准备工作\r\n\r\n注册Github账号。链接\r\n安装Git客户端。链接\r\n生成SSH密钥\r\n\r\ngit 客户端配置\r\n在命令行终端输入git --version命令，如果能够显示Git的版本号，则说明Git客户端已经成功安装。\r\n\r\n设置Git客户端的用户信息，包括用户名和电子邮件地址。\r\ngit config --global user.name &quot;your_name&quot;   # nsleepgit config --global user.email &quot;your_email&quot; # simoncq@163.com\r\n设置默认文本编辑器 如果没有设置默认的文本编辑器，Git\r\n会使用系统默认的文本编辑器，例如 Vim。 git config --global core.editor &quot;vim&quot;\r\n设置默认分支 将默认分支设置为其他分支，例如 main 分支。\r\ngit config --global init.defaultBranch main\r\n其他配置 还有一些其他的 Git 配置可以进行，例如设置颜色输出、配置 Git\r\n对换行符的处理等等。 可以使用以下命令来查看当前的 Git 配置\r\ngit config --list\r\n\r\n在安装Git客户端后，可以选择性的安装一个可视化图形软件辅助git使用，例如：\r\n1. Sourcetree 2. GitKraken 3. GitHub Desktop 4. Tower\r\n生成SSH密钥\r\n为了方便本地访问Github，创建ssh密钥，并将公钥[%USERPROFILE%/.ssh/id_rsa.pub]上传Github ssh keys\r\nssh-keygen -t rsa -b 4096 -C &quot;your_email&quot; \t# 创建密钥对ssh -T git@github.com # 测试添加ssh是否成功  -v 显示详细信息\t\r\n\r\n更多参见Github\r\nDocs\r\n\r\n三、Github 基本操作\r\n创建仓库(repository)\r\ngit init\r\n克隆(clone)仓库到本地\r\ngit clone https://github.com/&lt;YourName&gt;/YourRepoName.git\r\n在本地进行修改和提交\r\n# 暂存git add README.mdgit add .# 提交本地仓库git commit -m &quot;Update Messages&quot;\r\n将本地提交推送(push)到Github\r\n# 添加远程版本库git remote add origin https://github.com/&lt;YourName&gt;/YourRepoName.git# 推送git push -u origin main\r\n查看提交历史\r\n查看当前分支的提交历史\r\ngit log\r\n查看某个特定分支的提交历史\r\ngit log &lt;branch-name&gt;\r\n其中 &lt;branch-name&gt; 是要查看的分支的名称。\r\ngit log 命令支持许多选项和参数，例如使用\r\n--author 选项按作者筛选提交记录，使用 --since\r\n和 --until 选项按时间段筛选提交记录等等。可以通过运行\r\ngit log --help 命令来查看所有选项和参数的帮助信息。\r\n撤销提交\r\n撤销提交有两种情况：一种是撤销本地未推送到远程仓库的提交，另一种是撤销已经推送到远程仓库的提交。\r\n撤销本地未推送到远程仓库的提交\r\n如果你在本地提交了代码，但是还没有推送到远程仓库，可以使用以下两种方法撤销提交：\r\n\r\n使用 git reset\r\n命令。该命令会将当前分支指向指定的提交，并且将代码库重置为该提交的状态。如果不带参数，则默认将当前分支指向上一次提交。\r\ngit reset HEAD~1   # 撤销上一次提交\r\n使用 git revert\r\n命令。该命令会创建一个新的提交来撤销指定的提交。这种方法不会删除任何历史记录。\r\ngit revert HEAD   # 撤销上一次提交\r\n\r\n撤销已经推送到远程仓库的提交\r\n如果你已经将代码推送到远程仓库，并且其他人已经对该提交进行了修改，那么就需要使用\r\ngit revert 命令来创建一个新的提交来撤销之前的提交。\r\n\r\n首先使用 git log 命令查看要撤销的提交的哈希值。\r\n然后使用 git revert &lt;commit-hash&gt;\r\n命令创建一个新的提交。\r\n最后使用 git push 命令将新的提交推送到远程仓库。\r\n\r\n分支管理\r\n常用的分支管理命令包括：\r\n\r\ngit branch：列出所有分支，以及当前所在的分支。\r\ngit branch [branch name]：新建一个分支。\r\ngit checkout [branch name]：切换到指定分支。\r\ngit checkout -b [branch name]：新建一个分支，并切换到该分支。\r\ngit merge [branch name]：将指定分支合并到当前分支。\r\ngit branch -d [branch name]：删除指定分支。\r\ngit branch -D [branch name]：强制删除指定分支。\r\n\r\nGithub的相关工具和服务\r\nGithub Desktop Travis CI Codecov Coveralls\r\n常见问题解答\r\n如何解决冲突(conflict)\r\n在 Git\r\n中，冲突通常发生在两个分支上进行了相同文件的更改，并且尝试将这两个分支合并（merge）时发生。为了解决冲突，可以按照以下步骤进行：\r\n\r\n运行 git status 命令，查看冲突的文件。\r\n打开冲突的文件，查看冲突的位置。Git\r\n会在冲突的地方插入一些标记，标识出两个不同的更改。\r\n修改文件，解决冲突。根据实际情况选择保留、删除或修改其中一个或两个更改。\r\n保存文件。\r\n运行 git add 命令，将冲突文件标记为已解决。\r\n运行 git commit 命令，提交合并后的更改。\r\n如果需要，推送(push)到远程仓库。\r\n\r\n如何回退(commit revert)\r\n在 Git 中，要回退（revert）一个提交（commit），可以使用\r\ngit revert\r\n命令。该命令并不会删除之前的提交。因此，在回退一个提交之后，如果需要彻底删除这个提交，可以使用\r\ngit reset 命令或者 git rebase\r\n命令。但是，这样做会导致历史提交记录被修改，不建议在公共仓库中执行这样的操作。\r\n\r\n使用 git log 命令查看最近的提交历史，找到需要回退的提交的 SHA-1\r\n标识符。\r\n然后，可以使用 git revert 命令指定需要回退的提交的\r\nSHA-1 标识符。\r\n\r\n如何合并(merge)和推送(push)分支\r\n步骤如下： 1. 首先，切换到目标分支，例如主分支 main：\r\ngit checkout master 2. 将要合并的分支 feature 合并到当前分支\r\nmain 上： git merge feature\r\n如果出现冲突，需要解决冲突后再执行合并操作。 3.\r\n将合并后的更改推送到远程仓库： git push origin master 如果第一次推送，需要使用\r\n-u 参数设置上游分支： git push -u origin master\r\n如果推送过程中提示需要拉取最新代码，请先拉取最新代码：\r\ngit pull origin master git push origin master\r\n如何通过Pull\r\nRequest进行协作和代码审核\r\n一般步骤： 1.\r\nFork源代码仓库到自己的账户下，然后将代码仓库clone到本地。 2.\r\n创建一个新分支，基于最新的远程代码。 git checkout -b new-branch origin/master 3.\r\n在新分支上进行修改和提交。 git add .git commit -m &quot;commit message&quot; 4.\r\n将新分支推送到自己的远程仓库中。 git push origin new-branch 5.\r\n在Github上创建一个Pull\r\nRequest，选择要合并到的目标分支，写明详细的修改内容和描述，向目标分支的仓库管理员请求代码审核。代码审核人员检查代码，提出修改意见，或者在PR页面中进行评论讨论。如果代码审核通过，管理员就可以将该PR合并到目标分支。\r\n6. 删除本地分支。 git branch -d new-branch 7.\r\n更新自己的仓库到最新版本，以便下次开发。 git fetch upstreamgit merge upstream/mastergit push origin master 其中\r\nupstream 指的是一个远程仓库的地址\r\nCRLF 报错问题\r\n首先问题出在不同操作系统所使用的换行符是不一样的，下面罗列一下三大主流操作系统的换行符：\r\nUinx/Linux采用换行符 LF 表示下一行（LF：LineFeed，换行）；\r\nDos和Windows采用回车+换行CRLF表示下一行（CRLF:\r\nCarriageReturn LineFeed，中文意思是回车换行）；\r\nMac OS采用回车CR表示下一行（CR：CarriageReturn，回车）。\r\n当错误出现的时候，可以执行下面命令： git config --global core.autocrlf false\r\ncore.autocrlf 有三个值: 为 true 时，Git 会将你 add\r\n的所有文件视为文本文件，将结尾的 CRLF 转换为LF，而 checkout\r\n时会再将文件的LF格式转为 CRLF 格式。 为 false 时，line endings\r\n不做任何改变，文本文件保持其原来的样子。 为 input 时，add 时 Git 会把\r\nCRLF 转换为 LF，而 check 时仍旧为 LF，所以 Windows\r\n操作系统不建议设置此值。 \r\nSSL 证书错误\r\n当错误出现的时候，可以执行下面命令： git config --global http.sslVerify falsegit config --global https.sslVerify false\r\n如何手动验证证书并将其添加到\r\nGit 的信任列表中？\r\n\r\n在浏览器中打开网站，并单击地址栏中的锁形图标。\r\n选择“证书”或“证书信息”选项。\r\n在“证书”窗口中选择“详细信息”选项卡。\r\n在“详细信息”选项卡中，选择“证书颁发机构”/“证书层次结构”字段下的网址，点击“导出”，保存类型为“证书链”(.pem,.crt)。\r\n输入命令\r\ngit config --global http.sslCAInfo /path/to/github.crt\r\n\r\n","categories":["教程"],"tags":["Github"]}]