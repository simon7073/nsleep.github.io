<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="Sj57y850f1">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.simon7.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism-solarizedlight","dark":"prism-okaidia"},"copy_button":{"enable":true,"style":"flat","show_result":true},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":2,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="转载知乎  基础知识  1. 列出 5 个常用 Python 标准库？ time os sys glob timeit datetime calendar random math operator re urllib threading multiprocessing queue equests，virtualenv，selenium，scrapy，xadmin，celery，hashlib，m">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 面试准备">
<meta property="og:url" content="https://blog.simon7.top/20200408/python-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">
<meta property="og:site_name" content="Simon">
<meta property="og:description" content="转载知乎  基础知识  1. 列出 5 个常用 Python 标准库？ time os sys glob timeit datetime calendar random math operator re urllib threading multiprocessing queue equests，virtualenv，selenium，scrapy，xadmin，celery，hashlib，m">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f0c87fcad0839af06187a4def1706f51_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-3774e05a878688a01233e58eedd189a4_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-474f556cb8cd7d2ea7a47b0cba51c9cd_720w.jpg">
<meta property="article:published_time" content="2020-04-08T03:19:55.000Z">
<meta property="article:modified_time" content="2020-04-08T03:19:55.000Z">
<meta property="article:author" content="Simon">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-f0c87fcad0839af06187a4def1706f51_720w.jpg">


<link rel="canonical" href="https://blog.simon7.top/20200408/python-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.simon7.top/20200408/python-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","path":"20200408/python-面试准备/","title":"Python 面试准备"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Python 面试准备 | Simon</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?40fe1da0798212a31314b7ff6e3c58bb"></script>







  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"forest","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">
  <script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js","integrity":"sha256-Us54+rSGDSTvIhKKUs4kygE2ipA0RXpWWh0/zLqw3bs="}}</script>
  <script src="/js/third-party/math/katex.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Simon" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Simon</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">玄之又玄，众妙之门</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">24</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">50</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text"> 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%97%E5%87%BA-5-%E4%B8%AA%E5%B8%B8%E7%94%A8-python-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text"> 1. 列出 5 个常用 Python 标准库？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#os-%E6%A8%A1%E5%9D%97"><span class="nav-text"> os 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-%E6%A8%A1%E5%9D%97"><span class="nav-text"> sys 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#glob-%E6%A8%A1%E5%9D%97"><span class="nav-text"> glob 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#random-%E6%A8%A1%E5%9D%97"><span class="nav-text"> random 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#math-%E6%A8%A1%E5%9D%97"><span class="nav-text"> math 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#operator-%E6%A8%A1%E5%9D%97"><span class="nav-text"> operator 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-%E9%83%A8%E5%88%86"><span class="nav-text"> 内置函数 部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-python-%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text"> 2. Python 内建数据类型有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AE%80%E8%BF%B0-with-%E6%96%B9%E6%B3%95%E6%89%93%E5%BC%80%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%B8%AE%E6%88%91%E6%88%91%E4%BB%AC%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-text"> 3. 简述 with 方法打开处理文件帮我我们做了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%97%E5%87%BA-python-%E4%B8%AD%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text"> 4. 列出 Python 中可变数据类型和不可变数据类型，为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-python-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F"><span class="nav-text"> 5. Python 获取当前日期？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text"> 6. 统计字符串每个单词出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%94%A8-python-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E7%94%A8-linux-%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-text"> 7. 用 python 删除文件和用 linux 命令删除文件方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%86%99%E4%B8%80%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81"><span class="nav-text"> 8. 写一段自定义异常代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9D%97%E4%B8%AD-try-except-else-finally-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%84%8F%E4%B9%89"><span class="nav-text"> 9. 举例说明异常模块中 try except else finally 的相关意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E9%81%87%E5%88%B0-bug-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-text"> 10. 遇到 bug 如何处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-text"> 语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%B0%88%E8%B0%88%E5%AF%B9-python-%E5%92%8C%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 1. 谈谈对 Python 和其他语言的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AE%80%E8%BF%B0%E8%A7%A3%E9%87%8A%E5%9E%8B%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-text"> 2. 简述解释型和编译型编程语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-python-%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%89%B9%E7%82%B9"><span class="nav-text"> 3. Python 的解释器种类以及相关特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84python3-%E5%92%8C-python2-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 4. 说说你知道的Python3 和 Python2 之间的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-python3-%E5%92%8C-python2-%E4%B8%AD-int-%E5%92%8C-long-%E5%8C%BA%E5%88%AB"><span class="nav-text"> 5. Python3 和 Python2 中 int 和 long 区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-xrange-%E5%92%8C-range-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 6. xrange 和 range 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80-%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 7. 强类型语言、动态语言和脚本语言之间的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="nav-text"> 编码规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-pep8"><span class="nav-text"> 1. 什么是 PEP8?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%86%E8%A7%A3-python-%E4%B9%8B%E7%A6%85%E4%B9%88"><span class="nav-text"> 2. 了解 Python 之禅么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%86%E8%A7%A3-docstring-%E4%B9%88"><span class="nav-text"> 3. 了解 docstring 么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rest%E9%A3%8E%E6%A0%BC"><span class="nav-text"> reST风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#google%E9%A3%8E%E6%A0%BC"><span class="nav-text"> Google风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numpy%E9%A3%8E%E6%A0%BC"><span class="nav-text"> Numpy风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epytext%E9%A3%8E%E6%A0%BC"><span class="nav-text"> Epytext风格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BA%86%E8%A7%A3%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E4%B9%88"><span class="nav-text"> 4. 了解类型注解么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BE%8B%E4%B8%BE%E4%BD%A0%E7%9F%A5%E9%81%93-python-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E4%BE%8B%E5%A6%82%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E7%B1%BB%E7%AD%89"><span class="nav-text"> 5. 例举你知道 Python 对象的命名规范，例如方法或者类等</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#-%E5%8F%98%E9%87%8F"><span class="nav-text"> - 变量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-%E5%87%BD%E6%95%B0"><span class="nav-text"> - 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-%E7%B1%BB"><span class="nav-text"> - 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-%E5%B8%B8%E9%87%8F"><span class="nav-text"> - 常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-python-%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-text"> 6. Python 中的注释有几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="nav-text"> 7. 如何优雅的给一个函数加注释？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E7%BB%99%E5%8F%98%E9%87%8F%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="nav-text"> 8. 如何给变量加注释？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-python-%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E4%B8%AD%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-tab-%E9%94%AE%E5%92%8C%E7%A9%BA%E6%A0%BC%E6%B7%B7%E7%94%A8"><span class="nav-text"> 9. Python 代码缩进中是否支持 Tab 键和空格混用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%80%E5%8F%A5-import-%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%BA%93"><span class="nav-text"> 10. 是否可以在一句 import 中导入多个库?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%9C%A8%E7%BB%99-py-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-text"> 11. 在给 Py 文件命名的时候需要注意什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BE%8B%E4%B8%BE%E5%87%A0%E4%B8%AA%E8%A7%84%E8%8C%83-python-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-text"> 12. 例举几个规范 Python 代码风格的工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%97%E4%B8%BE-python-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 1. 列举 Python 中的基本数据类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 2. 如何区别可变数据类型和不可变数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B0%86hello-world%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99hello-world"><span class="nav-text"> 3. 将&quot;hello world&quot;转换为首字母大写&quot;Hello World&quot;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8F%AA%E5%90%AB%E6%9C%89%E6%95%B0%E5%AD%97"><span class="nav-text"> 4. 如何检测字符串中只含有数字?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2ilovechina%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC"><span class="nav-text"> 5. 将字符串&quot;ilovechina&quot;进行反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-python-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B"><span class="nav-text"> 6. Python 中的字符串格式化方式你知道哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%80%E5%A4%B4%E5%92%8C%E6%9C%AB%E5%B0%BE%E9%83%BD%E6%9C%89%E7%A9%BA%E6%A0%BC"><span class="nav-text"> 7. 把一个字符串开头和末尾都有空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2123456%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-text"> 8. 获取字符串&quot;123456&quot;最后的两个字符。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A0%81%E4%B8%BA-gbk-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-s%E8%A6%81%E5%B0%86%E5%85%B6%E8%BD%AC%E6%88%90-utf-8-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%94%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-text"> 9. 一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E6%AD%A3%E5%88%99%E5%88%87%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 10. 正则切分字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E7%A9%BA%E6%A0%BC%E5%8F%AA%E7%95%99%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC"><span class="nav-text"> 11. 去除多余空格只留一个空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E6%80%8E%E6%A0%B7%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B0%8F%E5%86%99"><span class="nav-text"> 12. 怎样将字符串转换为小写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E5%8D%95%E5%BC%95%E5%8F%B7-%E5%8F%8C%E5%BC%95%E5%8F%B7-%E4%B8%89%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 13. 单引号、双引号、三引号的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-text"> 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B7%B2%E7%9F%A5-alist-12312%E5%AF%B9-alist-%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%8E%BB%E9%87%8D%E5%86%99%E5%87%BA%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="nav-text"> 1. 已知 AList &#x3D; [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-123-%E5%8F%98%E6%88%90-123"><span class="nav-text"> 2. 如何实现 “1,2,3” 变成 [“1”,“2”,“3”]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA-lista-%E5%92%8C-b%E6%89%BE%E5%87%BA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0"><span class="nav-text"> 3. 给定两个 list，A 和 B，找出相同元素和不同元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-123456%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B1%95%E5%BC%80%E8%AF%A5%E5%88%97%E8%A1%A8%E5%BE%97%E5%87%BA123456"><span class="nav-text"> 4. [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%90%88%E5%B9%B6%E5%88%97%E8%A1%A81579%E5%92%8C2268"><span class="nav-text"> 5. 合并列表[1,5,7,9]和[2,2,6,8]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%A6%82%E4%BD%95%E6%89%93%E4%B9%B1%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text"> 6. 如何打乱一个列表的元素？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-text"> 字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AD%97%E5%85%B8%E6%93%8D%E4%BD%9C%E4%B8%AD-del-%E5%92%8C-pop-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text"> 1. 字典操作中 del 和 pop 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E7%9A%84%E5%86%85%E7%9A%84%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F"><span class="nav-text"> 2. 按照字典的内的年龄排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AF%B7%E5%90%88%E5%B9%B6%E4%B8%8B%E9%9D%A2%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8-a-a1b2b-c3d4"><span class="nav-text"> 3. 请合并下面两个字典 a &#x3D; {“A”:1,“B”:2},b &#x3D; {“C”:3,“D”:4}</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%BC%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E5%86%99%E4%B8%80%E6%AE%B5%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81"><span class="nav-text"> 4. 如何使用生成式的方式生成一个字典，写一段功能代码。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%A6%82%E4%BD%95%E6%8A%8A%E5%85%83%E7%BB%84ab%E5%92%8C%E5%85%83%E7%BB%8412%E5%8F%98%E4%B8%BA%E5%AD%97%E5%85%B8a1b2"><span class="nav-text"> 5. 如何把元组(“a”,“b”)和元组(1,2)，变为字典{“a”:1,“b”:2}</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E5%90%88"><span class="nav-text"> 综合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-python-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7"><span class="nav-text"> 1. Python 常用的数据结构的类型及其特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E5%AD%97%E5%85%B8-a1b2%E7%9A%84%E9%94%AE%E5%92%8C%E5%80%BC"><span class="nav-text"> 2. 如何交换字典 {“A”：1,“B”：2}的键和值？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-python-%E9%87%8C%E9%9D%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-tuple-%E5%92%8C-list-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text"> 3. Python 里面如何实现 tuple 和 list 的转换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E5%AF%B9%E4%BA%8E%E5%88%97%E8%A1%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E7%9A%84%E9%80%89%E6%8B%A9%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E5%AF%B9%E7%94%9F%E6%88%90%E5%99%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8A%9F%E8%83%BD%E5%91%A2"><span class="nav-text"> 4. 我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%AF%B7%E5%B0%86i-for-i-in-range3%E6%94%B9%E6%88%90%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text"> 5. 请将[i for i in range(3)]改成生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ahello%E5%92%8C-b%E4%BD%A0%E5%A5%BD%E7%BC%96%E7%A0%81%E6%88%90-bytes-%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 6. a&#x3D;&quot;hello&quot;和 b&#x3D;&quot;你好&quot;编码成 bytes 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text"> 7. 下面的代码输出结果是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text"> 8. 下面的代码输出的结果是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-python-%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="nav-text"> 9. Python 交换两个变量的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E5%9C%A8%E8%AF%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8-read-readline-%E6%88%96%E8%80%85-readlines%E7%AE%80%E8%BF%B0%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text"> 10. 在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%82%E4%BD%95%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81-datetime-%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 11. json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%BB%98%E8%AE%A4%E9%81%87%E5%88%B0%E4%B8%AD%E6%96%87%E4%BC%9A%E8%BD%AC%E6%8D%A2%E6%88%90-unicode%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%BF%9D%E7%95%99%E4%B8%AD%E6%96%87%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-text"> 12. json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6-a-%E5%92%8C-b%E5%90%84%E5%AD%98%E6%94%BE%E4%B8%80%E8%A1%8C%E5%AD%97%E6%AF%8D%E8%A6%81%E6%B1%82%E6%8A%8A%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%90%88%E5%B9%B6%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E8%BE%93%E5%87%BA%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6-c-%E4%B8%AD"><span class="nav-text"> 13. 有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E4%B8%BA-20210630%E8%A6%81%E6%B1%82%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA-n-%E5%A4%A9%E5%90%8E%E7%9A%84%E6%97%A5%E6%9C%9F%E6%AF%94%E5%A6%82-n-%E4%B8%BA-2%E5%88%99%E8%BE%93%E5%87%BA-20210702"><span class="nav-text"> 14. 如果当前的日期为 20210630，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20210702)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8E%A5%E6%94%B6%E6%95%B4%E6%95%B0%E5%8F%82%E6%95%B0-n%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E6%8A%8A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C-n-%E7%9B%B8%E4%B9%98%E5%B9%B6%E6%8A%8A%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E"><span class="nav-text"> 15. 写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B"><span class="nav-text"> 16. 下面代码会存在什么问题，如何改进？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA-1-100-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%89%80%E6%9C%89%E5%81%B6%E6%95%B0"><span class="nav-text"> 17. 一行代码输出 1-100 之间的所有偶数。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-with-%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81"><span class="nav-text"> 18. with 语句的作用，写一段代码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-python-%E5%AD%97%E5%85%B8%E5%92%8C-json-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-text"> 19. python 字典和 json 字符串相互转化方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E8%AF%B7%E5%86%99%E4%B8%80%E4%B8%AA-python-%E9%80%BB%E8%BE%91%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E6%95%B0%E9%87%8F"><span class="nav-text"> 20. 请写一个 Python 逻辑，计算一个文件中的大写字母数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E8%AF%B7%E5%86%99%E4%B8%80%E6%AE%B5-python%E8%BF%9E%E6%8E%A5-mongo-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%84%B6%E5%90%8E%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BB%A3%E7%A0%81"><span class="nav-text"> 21. 请写一段 Python连接 Mongo 数据库，然后的查询代码。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E8%AF%B4%E4%B8%80%E8%AF%B4-redis-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 22. 说一说 Redis 的基本类型。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E8%AF%B7%E5%86%99%E4%B8%80%E6%AE%B5-python%E8%BF%9E%E6%8E%A5-redis-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text"> 23. 请写一段 Python连接 Redis 数据库的代码。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E8%AF%B7%E5%86%99%E4%B8%80%E6%AE%B5-python-%E8%BF%9E%E6%8E%A5-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text"> 24. 请写一段 Python 连接 MySQL 数据库的代码。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-%E4%BA%86%E8%A7%A3-redis-%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B9%88"><span class="nav-text"> 25. 了解 Redis 的事务么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E4%B9%88"><span class="nav-text"> 26. 了解数据库的三范式么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B9%88"><span class="nav-text"> 27. 了解分布式锁么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-%E7%94%A8-python-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-reids-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text"> 28. 用 Python 实现一个 Reids 的分布式锁的功能。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-%E5%86%99%E4%B8%80%E6%AE%B5-python-%E4%BD%BF%E7%94%A8-mongo-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text"> 29. 写一段 Python 使用 Mongo 数据库创建索引的代码。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text"> 高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E8%AF%B7%E5%88%97%E4%B8%BE%E8%AF%B4%E6%98%8E"><span class="nav-text"> 1. 函数装饰器有什么作用？请列举说明？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text"> 2. Python 垃圾回收机制？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-text"> 整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text"> 引用计数：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0-__call__-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="nav-text"> 3. 魔法函数 __call__ 怎么使用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%96%B9%E6%B3%95"><span class="nav-text"> 4. 如何判断一个对象是函数还是方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-classmethod-%E5%92%8Cstaticmethod-%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-text"> 5. @classmethod 和@staticmethod 用法和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-python-%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 6. Python 中的接口如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-python-%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E4%BA%86%E8%A7%A3%E4%B9%88"><span class="nav-text"> 7. Python 中的反射了解么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-metaclass-%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="nav-text"> 8. metaclass 作用？以及应用场景？[重难点]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-hasattr-getattr-setattr%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text"> 9. hasattr() getattr() setattr()的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E8%AF%B7%E5%88%97%E4%B8%BE%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84-python-%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E5%8F%8A%E7%94%A8%E9%80%94"><span class="nav-text"> 10. 请列举你知道的 Python 的魔法方法及用途。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%B8%80%E4%B8%AA-python-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 11. 如何知道一个 Python 对象的类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-python-%E7%9A%84%E4%BC%A0%E5%8F%82%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%9D%80"><span class="nav-text"> 12. Python 的传参是传值还是传址？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-python-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BBmetaclass%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-text"> 13. Python 中的元类(metaclass)使用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%AE%80%E8%BF%B0-any%E5%92%8C-all%E6%96%B9%E6%B3%95"><span class="nav-text"> 14. 简述 any()和 all()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-filter-%E6%96%B9%E6%B3%95%E6%B1%82%E5%87%BA%E5%88%97%E8%A1%A8%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E5%B9%B6%E6%9E%84%E9%80%A0%E6%96%B0%E5%88%97%E8%A1%A8a-1-2-3-4-5-6-7-8-9-10"><span class="nav-text"> 15. filter 方法求出列表所有奇数并构造新列表，a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81"><span class="nav-text"> 16. 什么是猴子补丁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E5%9C%A8-python-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84"><span class="nav-text"> 17. 在 Python 中是如何管理内存的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%BD%93%E9%80%80%E5%87%BA-python-%E6%97%B6%E6%98%AF%E5%90%A6%E9%87%8A%E6%94%BE%E6%89%80%E6%9C%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text"> 18. 当退出 Python 时是否释放所有内存分配？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%87%BA%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80-a%E5%BC%A0%E6%98%8E-98-%E5%88%86%E7%94%A8-resub%E5%B0%86-98-%E6%9B%BF%E6%8D%A2%E4%B8%BA-100"><span class="nav-text"> 1. 使用正则表达式匹配出中的地址 a&#x3D;“张明 98 分”，用 re.sub，将 98 替换为 100</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E4%B8%AD%E5%92%8C%E5%8C%B9%E9%85%8D%E5%8C%BA%E5%88%AB"><span class="nav-text"> 2. 正则表达式匹配中(.*)和(.*?)匹配区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%86%99%E4%B8%80%E6%AE%B5%E5%8C%B9%E9%85%8D%E9%82%AE%E7%AE%B1%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> 3. 写一段匹配邮箱的正则表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9"><span class="nav-text"> 其他内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-python-%E4%B8%AD-pass-%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text"> 1. 解释一下 python 中 pass 语句的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AE%80%E8%BF%B0%E4%BD%A0%E5%AF%B9-input%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text"> 2. 简述你对 input()函数的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-python-%E4%B8%AD%E7%9A%84-is-%E5%92%8C"><span class="nav-text"> 3. python 中的 is 和&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-python-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text"> 4. Python 中的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E5%86%99%E6%B3%95%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text"> 5. 三元运算写法和应用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BA%86%E8%A7%A3-enumerate-%E4%B9%88"><span class="nav-text"> 6. 了解 enumerate 么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%88%97%E4%B8%BE-5-%E4%B8%AA-python-%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97"><span class="nav-text"> 7. 列举 5 个 Python 中的标准模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text"> 8. 如何在函数中设置一个全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-pathlib-%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="nav-text"> 9. pathlib 的用法举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-python-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text"> 10. Python 中的异常处理，写一个简单的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-python-%E4%B8%AD%E9%80%92%E5%BD%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0%E9%82%A3%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4%E5%91%A2"><span class="nav-text"> 11. Python 中递归的最大次数，那如何突破呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84-mro"><span class="nav-text"> 12. 什么是面向对象的 mro</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-isinstance-%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text"> 13. isinstance 作用以及应用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%AD%E8%A8%80%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text"> 14. 什么是断言？应用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text"> 15. lambda 表达式格式以及应用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%96%B0%E5%BC%8F%E7%B1%BB%E5%92%8C%E6%97%A7%E5%BC%8F%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 16. 新式类和旧式类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-dir%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="nav-text"> 17. dir()是干什么用的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E4%B8%80%E4%B8%AA%E5%8C%85%E9%87%8C%E6%9C%89%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%9D%97demo1py-demo2py-demo3py%E4%BD%86%E4%BD%BF%E7%94%A8-from-tools-import-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AA%E6%9C%89-demo1-demo3-%E8%A2%AB%E5%AF%BC%E5%85%A5%E4%BA%86"><span class="nav-text"> 18. 一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%88%97%E4%B8%BE-5-%E4%B8%AA-python-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><span class="nav-text"> 19. 列举 5 个 Python 中的异常类型以及其含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-copy-%E5%92%8C-deepcopy-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text"> 20. copy 和 deepcopy 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84args-kwargs-%E5%90%AB%E4%B9%89%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="nav-text"> 21. 代码中经常遇到的*args, **kwargs 含义及用法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-python-%E4%B8%AD%E4%BC%9A%E6%9C%89%E5%87%BD%E6%95%B0%E6%88%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8C%85%E5%90%AB%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF%E5%89%8D%E7%BC%80%E5%92%8C%E7%BB%93%E5%B0%BE%E5%92%8C%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E5%89%8D%E7%BC%80%E7%BB%93%E5%B0%BE%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text"> 22. Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-w-a-wb-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 23. w、a+、wb 文件写入模式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E4%B8%BE%E4%BE%8B-sort-%E5%92%8C-sorted-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 24. 举例 sort 和 sorted 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9F%E7%B4%A2%E5%BC%95"><span class="nav-text"> 25. 什么是负索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-pprint-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="nav-text"> 26. pprint 模块是干什么的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"> 27. 解释一下 Python 中的赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-python-%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"> 28. 解释一下 Python 中的逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E8%AE%B2%E8%AE%B2-python-%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"> 29. 讲讲 Python 中的位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-%E5%9C%A8-python-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97"><span class="nav-text"> 30. 在 Python 中如何使用多进制数字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E6%80%8E%E6%A0%B7%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%B9%B6%E8%B5%8B%E5%80%BC"><span class="nav-text"> 31. 怎样声明多个变量并赋值？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text"> 算法和数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B7%B2%E7%9F%A5"><span class="nav-text"> 1. 已知：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%94%A8-python-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text"> 2. 用 Python 实现一个二分查找的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-python-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text"> 3. python 单例模式的实现方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8-python-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text"> 4. 使用 Python 实现一个斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%89%BE%E5%87%BA%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="nav-text"> 5. 找出列表中的重复数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%89%BE%E5%87%BA%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-text"> 6. 找出列表中的单个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%86%99%E4%B8%80%E4%B8%AA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text"> 7. 写一个冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text"> 8. 写一个快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%86%99%E4%B8%80%E4%B8%AA%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text"> 9. 写一个拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-python-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97"><span class="nav-text"> 11. python 实现一个二进制计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%9C%89%E4%B8%80%E7%BB%84%E5%92%8C-%E7%AC%A6%E5%8F%B7%E8%A6%81%E6%B1%82%E5%B0%86%E6%8E%92%E5%88%B0%E5%B7%A6%E8%BE%B9-%E6%8E%92%E5%88%B0%E5%8F%B3%E8%BE%B9%E5%86%99%E5%87%BA%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text"> 12. 有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="nav-text"> 13. 单链表反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E4%BA%A4%E5%8F%89%E9%93%BE%E8%A1%A8%E6%B1%82%E4%BA%A4%E7%82%B9"><span class="nav-text"> 14. 交叉链表求交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-text"> 15. 用队列实现栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%89%BE%E5%87%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text"> 16. 找出数据流的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text"> 17. 二叉搜索树中第 K 小的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3"><span class="nav-text"> 爬虫相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8-requests-%E6%A8%A1%E5%9D%97%E4%B8%ADrequestscontent-%E5%92%8C-requeststext-%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text"> 1. 在 requests 模块中，requests.content 和 requests.text 什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AE%80%E8%A6%81%E5%86%99%E4%B8%80%E4%B8%8B-lxml-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-text"> 2. 简要写一下 lxml 模块的使用方法框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AF%B4%E4%B8%80%E8%AF%B4-scrapy-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text"> 3. 说一说 scrapy 的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-scrapy-%E7%9A%84%E5%8E%BB%E9%87%8D%E5%8E%9F%E7%90%86"><span class="nav-text"> 4. scrapy 的去重原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-scrapy-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text"> 5. scrapy 中间件有几种类，你用过哪些中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BD%A0%E5%86%99%E7%88%AC%E8%99%AB%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E9%81%87%E5%88%B0%E8%BF%87%E4%BB%80%E4%B9%88%E5%8F%8D%E7%88%AC%E8%99%AB%E6%8E%AA%E6%96%BD%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="nav-text"> 6. 你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E7%94%A8%E5%88%B0%E4%BB%A3%E7%90%86"><span class="nav-text"> 7. 为什么会用到代理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BB%A3%E7%90%86%E5%A4%B1%E6%95%88%E4%BA%86%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-text"> 8. 代理失效了怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%88%97%E5%87%BA%E4%BD%A0%E7%9F%A5%E9%81%93-header-%E7%9A%84%E5%86%85%E5%AE%B9%E4%BB%A5%E5%8F%8A%E4%BF%A1%E6%81%AF"><span class="nav-text"> 9. 列出你知道 header 的内容以及信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE-%E7%99%BE%E5%BA%A6%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%B0%B1%E7%9F%A5%E9%81%93-%E8%8E%B7%E5%8F%96%E5%88%B0%E7%BB%93%E6%9E%9C%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="nav-text"> 10. 说一说打开浏览器访问 百度一下，你就知道 获取到结果，整个流程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%88%AC%E5%8F%96%E9%80%9F%E5%BA%A6%E8%BF%87%E5%BF%AB%E5%87%BA%E7%8E%B0%E4%BA%86%E9%AA%8C%E8%AF%81%E7%A0%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-text"> 11. 爬取速度过快出现了验证码怎么处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-scrapy-%E5%92%8C-scrapy-redis-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-redis-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text"> 12. scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-text"> 13. 分布式爬虫主要解决什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%86%99%E7%88%AC%E8%99%AB%E6%98%AF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A5%BD%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A5%BD-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text"> 14. 写爬虫是用多进程好？还是多线程好？ 为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8%E6%9C%80%E5%A4%9A%E7%9A%84%E6%98%AF%E5%93%AA%E5%87%A0%E4%B8%AA"><span class="nav-text"> 15. 解析网页的解析器使用最多的是哪几个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%E7%9A%84%E7%BD%91%E9%A1%B5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%90%8C%E6%97%B6%E9%99%90%E5%88%B6-ipcookiesession%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E4%BA%9B%E6%98%AF%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E7%88%AC%E5%8F%96%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B"><span class="nav-text"> 16. 需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E7%AE%80%E5%8D%95%E7%9A%84%E5%AF%B9%E5%9B%BE%E5%83%8F%E5%81%9A%E5%A4%84%E7%90%86%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E6%98%AF%E7%82%B9%E5%87%BB%E6%8B%96%E5%8A%A8%E7%AD%89%E5%8A%A8%E6%80%81%E8%BF%9B%E8%A1%8C%E7%9A%84"><span class="nav-text"> 17. 验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93mysqlmongodbredis-%E7%AD%89%E5%AF%B9%E4%BB%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text"> 18. 使用最多的数据库（mysql，mongodb，redis 等），对他的理解？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text"> 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-tcp-%E5%92%8C-udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 1. TCP 和 UDP 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text"> 2. 简要介绍三次握手和四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85-socket-%E4%B8%AD%E9%80%A0%E6%88%90%E7%B2%98%E5%8C%85%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="nav-text"> 3. 什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Simon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Simon</p>
  <div class="site-description" itemprop="description">Simon's blog</div>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/nsleep" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nsleep" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:simoncq@163.com" title="E-Mail → mailto:simoncq@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="rss → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.simon7.top/20200408/python-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Simon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simon">
      <meta itemprop="description" content="Simon's blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Python 面试准备 | Simon">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python 面试准备
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-08 11:19:55" itemprop="dateCreated datePublished" datetime="2020-04-08T11:19:55+08:00">2020-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>
<p><a href="https://www.zhihu.com/question/54513391/answer/139710121">转载知乎</a></p>
<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2>
<h3 id="1-列出-5-个常用-python-标准库"><a class="markdownIt-Anchor" href="#1-列出-5-个常用-python-标准库"></a> 1. 列出 5 个常用 Python 标准库？</h3>
<p>time os sys glob timeit datetime calendar random math operator</p>
<p>re urllib threading multiprocessing queue equests，virtualenv，selenium，scrapy，xadmin，celery，hashlib，md5。<br />
<a href="https://www.cnblogs.com/jiangchunsheng/p/9275881.html">20个必不可少的Python库也是基本的第三方库</a><br />
Numpy，Scipy，Pandas<br />
<a href="https://blog.csdn.net/bbwangj/article/details/90750780">queue</a></p>
<h4 id="os-模块"><a class="markdownIt-Anchor" href="#os-模块"></a> os 模块</h4>
<figure class="highlight python"><figcaption><span>os 模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># os 模块 处理文件和目录</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. os.getcwd</span></span><br><span class="line">os.getcwd()   <span class="comment"># 返回当前的工作目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. os.listdir</span></span><br><span class="line">os.listdir(<span class="string">&#x27;d:&#x27;</span>) <span class="comment">#　目录下的所有文件（夹）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. os.path.exists</span></span><br><span class="line">os.path.exists(filepath) <span class="comment"># 判断文件是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. os.remove</span></span><br><span class="line">os.remove(filepath) <span class="comment"># 删除文件</span></span><br></pre></td></tr></table></figure>
<h4 id="sys-模块"><a class="markdownIt-Anchor" href="#sys-模块"></a> sys 模块</h4>
<figure class="highlight python"><figcaption><span>sys 模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># sys 模块 提供对解释器使用或维护的一些变量的访问，以及与解释器强烈交互的函数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. sys.argv </span></span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">1</span>]) <span class="comment"># 脚本执行参数列表，0为文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. sys.exit(n)</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.exit(<span class="number">1</span>) <span class="comment"># 异常退出程序</span></span><br><span class="line"><span class="keyword">except</span> SystemExit,value:</span><br><span class="line">    exitfunc(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. sys.modules</span></span><br><span class="line"><span class="built_in">print</span>(sys.modules.keys()) <span class="comment"># sys.modules 全局字典 自动记录模块</span></span><br><span class="line"><span class="built_in">print</span>(sys.modules.values())</span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;os&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. sys.stdin\stdout\stderr</span></span><br><span class="line"><span class="comment"># 与解释器的标准输入，输出和错误流相对应的文件对象 支持read()、write()和flush()等操作</span></span><br></pre></td></tr></table></figure>
<h4 id="glob-模块"><a class="markdownIt-Anchor" href="#glob-模块"></a> glob 模块</h4>
<figure class="highlight python"><figcaption><span>glob 模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># glob 模块 提供了一个函数用于从目录通配符搜索中生成文件列表</span></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. glob.glob</span></span><br><span class="line">glob.glob(<span class="string">&#x27;*.py&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="random-模块"><a class="markdownIt-Anchor" href="#random-模块"></a> random 模块</h4>
<figure class="highlight python"><figcaption><span>random 模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># random 模块 随机数</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( random.randint(<span class="number">1</span>,<span class="number">10</span>) ) <span class="comment"># 返回 1 到 10 的一个整数型随机数</span></span><br><span class="line"><span class="built_in">print</span>( random.random() ) <span class="comment"># 返回 0 到 1 之间的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>( random.uniform(<span class="number">1</span>, <span class="number">10</span>) ) <span class="comment"># 返回 1 到 10 之间的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>( random.uniform(<span class="number">1.1</span>,<span class="number">5.4</span>) ) <span class="comment"># 返回  1.1 到 5.4 之间的随机浮点数，区间可以不是整数</span></span><br><span class="line"><span class="built_in">print</span>( random.choice(<span class="string">&#x27;abcdefg&#x27;</span>) ) <span class="comment"># 从序列中随机选取一个元素</span></span><br><span class="line"><span class="built_in">print</span>( random.sample(<span class="string">&#x27;zyxwvutsrqponmlkjihgfedcba&#x27;</span>,<span class="number">5</span>)) <span class="comment"># 多个字符中生成指定数量的随机字符</span></span><br><span class="line"><span class="built_in">print</span>( random.randrange(<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>) ) <span class="comment"># 返回 从1到100的间隔为2的随机整数</span></span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] <span class="comment"># 将序列a中的元素顺序打乱</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="math-模块"><a class="markdownIt-Anchor" href="#math-模块"></a> math 模块</h4>
<figure class="highlight python"><figcaption><span>math 模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># math 模块</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">math.ceil(x) 上入整数</span><br><span class="line">math.exp(x) e的x次幂</span><br><span class="line">math.fabs(x) 绝对值 浮点数</span><br><span class="line">math.floor(x) 下舍整数</span><br><span class="line">math.log(x[,y]) 以e[y]为基数的x的对数</span><br><span class="line">math.log2(x) 以<span class="number">2</span>为基数的x的对数</span><br><span class="line">math.log10(x) 以<span class="number">10</span>为基数的x的对数</span><br><span class="line">math.modf(x) 整数部分与小数部分</span><br><span class="line">math.sqrt(x) x的平方根</span><br><span class="line"></span><br><span class="line">math.atan2(y,x) 返回给定的 X 及 Y 坐标值的反正切值。</span><br><span class="line">math.hypot(x,y) 返回给定的 X 及 Y 坐标值的反正切值。</span><br><span class="line">math.degress(x) 将弧度转换为角度,如degrees(math.pi/<span class="number">2</span>) ， 返回<span class="number">90.0</span></span><br><span class="line">math.radians(x) 将角度转换为弧度</span><br><span class="line"></span><br><span class="line">math.copysign(x,y) 把y的正负号加到x前面</span><br><span class="line">math.factorial(x) x的阶乘</span><br><span class="line">math.fmod(x,y) 得到x/y的余数，其值是一个浮点数</span><br><span class="line">math.frexp(x) 返回一个元组(m,n),x = m * (<span class="number">2</span> ** n),m的绝对值属于(<span class="number">0.5</span>,<span class="number">1</span>)</span><br><span class="line">math.ldexp(x,i) 返回 x * (<span class="number">2</span> ** i) 的值</span><br><span class="line">math.fsum(iterable) 对迭代器里的每个元素进行求和操作</span><br><span class="line">math.gcd(x,y) 返回x和y的最大公约数</span><br><span class="line">math.hypot(x,y) 用勾股定理求斜边的长</span><br><span class="line">math.isfinite(x) 判定x不是无穷大 <span class="built_in">bool</span></span><br><span class="line">math.isinf(x) 判定x是无穷大 <span class="built_in">bool</span></span><br><span class="line">math.isnan(x) 判定x不是数字 <span class="built_in">bool</span></span><br><span class="line">math.modf(x) 返回由x的小数部分和整数部分组成的元组</span><br><span class="line">math.trunc(x) 返回x的整数部分</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="operator-模块"><a class="markdownIt-Anchor" href="#operator-模块"></a> operator 模块</h4>
<figure class="highlight python"><figcaption><span>operator 模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># operator 模块</span></span><br><span class="line"><span class="comment"># operator模块是用c实现的，所以执行速度比python代码快</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">operator.lt(a, b) <span class="comment"># a &lt; b</span></span><br><span class="line">operator.le(a, b) <span class="comment"># a &lt;= b</span></span><br><span class="line">operator.eq(a, b) <span class="comment"># a = b</span></span><br><span class="line">operator.ne(a, b) <span class="comment"># a != b</span></span><br><span class="line">operator.ge(a, b) <span class="comment"># a &gt;= b</span></span><br><span class="line">operator.gt(a, b) <span class="comment"># a &gt; b</span></span><br><span class="line"></span><br><span class="line">operator.not_(obj)</span><br><span class="line">operator.truth(obj) 如果 obj 为真值则返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。 这等价于使用 <span class="built_in">bool</span> 构造器。</span><br><span class="line">operator.is_(a, b)  返回 a <span class="keyword">is</span> b. 测试对象标识</span><br><span class="line">operator.is_not(a, b) 返回 a <span class="keyword">is</span> <span class="keyword">not</span> b. 测试对象标识。</span><br><span class="line"></span><br><span class="line">operator.add(a, b) <span class="comment"># 返回 a + b</span></span><br><span class="line">operator.sub(a, b) <span class="comment"># 返回 a - b.</span></span><br><span class="line">operator.mul(a, b) <span class="comment"># 返回 a * b。</span></span><br><span class="line">operator.truediv(a, b) <span class="comment"># 返回 a / b </span></span><br><span class="line">operator.floordiv(a, b) <span class="comment"># 返回 a // b. 取整</span></span><br><span class="line">operator.mod(a, b) <span class="comment"># 返回 a % b. 字符串格式化</span></span><br><span class="line">operator.matmul(a, b) <span class="comment"># 返回 a @ b 矩阵相乘</span></span><br><span class="line">operator.<span class="built_in">pow</span>(a, b) ＃ 对于数字 a 和 b，返回 a ** b。</span><br><span class="line"></span><br><span class="line">operator.<span class="built_in">abs</span>(obj) 返回 obj 的绝对值。</span><br><span class="line">operator.neg(obj) 返回 obj 的负值 (-obj)</span><br><span class="line">operator.pos(obj) 返回 obj 取正的结果 (+obj)</span><br><span class="line">operator.index(a) 返回 a 转换为整数的结果。 等价于 a.__index__()。</span><br><span class="line"></span><br><span class="line">operator.and_(a, b) 返回 x 和 y 按位与</span><br><span class="line">operator.or_(a, b) 返回 a 和 b 按位或的结果。</span><br><span class="line">operator.inv(obj) 返回数字 obj 按位取反的结果。 这等价于 ~obj。</span><br><span class="line">operator.invert(obj) 返回数字 obj 按位取反的结果。 这等价于 ~obj。</span><br><span class="line">operator.xor(a, b) 返回 a 和 b 按位异或的结果。</span><br><span class="line"></span><br><span class="line">operator.lshift(a, b) 返回 a 左移 b 位的结果。</span><br><span class="line">operator.rshift(a, b) 返回 a 右移 b 位的结果。</span><br><span class="line"></span><br><span class="line">适用于序列的操作（其中一些也适用于映射）包括：</span><br><span class="line">operator.concat(a, b) 对于序列 a 和 b，返回 a + b。</span><br><span class="line">operator.contains(a, b) 返回 b <span class="keyword">in</span> a 检测的结果。 请注意操作数是反序的。</span><br><span class="line">operator.countOf(a, b) 返回 b 在 a 中的出现次数。</span><br><span class="line">operator.setitem(obj, k, v) 将索引号 b 上的值 a 设为 c。</span><br><span class="line">operator.getitem(obj, k) 返回索引号 b 上的值 a。</span><br><span class="line">operator.delitem(obj, k) 移除索引号 b 上的值 a。</span><br><span class="line">operator.indexOf(obj, k) 返回 b 在 a 中首次出现所在的索引号。</span><br><span class="line">operator.length_hint(obj, default=<span class="number">0</span>) 返回对象 o 的估计长度。 首先尝试返回其实际长度，再使用 <span class="built_in">object</span>.__length_hint__() 得出估计值，最后返回默认值。</span><br><span class="line"></span><br><span class="line">operator.attrgetter(attr)</span><br><span class="line">operator.attrgetter(*attrs)</span><br><span class="line"><span class="comment"># 返回一个可从操作数中获取 attr 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。</span></span><br><span class="line"><span class="comment"># 在 f = attrgetter(&#x27;name&#x27;) 之后，调用 f(b) 将返回 b.name。</span></span><br><span class="line"><span class="comment"># 在 f = attrgetter(&#x27;name.first&#x27;, &#x27;name.last&#x27;) 之后，调用 f(b) 将返回 (b.name.first, b.name.last)</span></span><br><span class="line"></span><br><span class="line">operator.itemgetter(item)</span><br><span class="line">operator.itemgetter(*items)</span><br><span class="line"><span class="comment"># 返回一个使用操作数的 __getitem__() 方法从操作数中获取 item 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。</span></span><br><span class="line"><span class="comment"># 在 f = itemgetter(2) 之后，调用 f(r) 将返回 r[2]。</span></span><br><span class="line"><span class="comment"># 在 g = itemgetter(2, 5, 3) 之后，调用 g(r) 将返回 (r[2], r[5], r[3])。</span></span><br><span class="line"></span><br><span class="line">operator.methodcaller(name[, args...])</span><br><span class="line"><span class="comment"># 返回一个在操作数上调用 name 方法的可调用对象。 如果给出额外的参数和/或关键字参数，它们也将被传给该方法。 例如：</span></span><br><span class="line"><span class="comment"># 在 f = methodcaller(&#x27;name&#x27;) 之后，调用 f(b) 将返回 b.name()。</span></span><br><span class="line"><span class="comment"># 在 f = methodcaller(&#x27;name&#x27;, &#x27;foo&#x27;, bar=1) 之后，调用 f(b) 将返回 b.name(&#x27;foo&#x27;, bar=1)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment">## 原地操作 ##</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># 不可变的目标例如字符串、数字和元组,需要再次赋值</span></span><br><span class="line"><span class="comment"># 可变的目标例如列表和字典，原地方法将执行更新，因此不需要后续赋值操作	</span></span><br><span class="line">operator.iadd(a, b) <span class="comment"># a = iadd(a, b) 等价于 a += b。</span></span><br><span class="line">operator.iand(a, b) <span class="comment"># a = iand(a, b) 等价于 a &amp;= b。</span></span><br><span class="line">operator.iconcat(a, b) <span class="comment"># a = iconcat(a, b) 等价于 a += b 其中 a 和 b 为序列。</span></span><br><span class="line">operator.ifloordiv(a, b) <span class="comment"># a = ifloordiv(a, b) 等价于 a //= b.</span></span><br><span class="line">operator.ilshift(a, b) <span class="comment"># a = ilshift(a, b) 等价于 a &lt;&lt;= b。</span></span><br><span class="line">operator.imod(a, b) <span class="comment"># a = imod(a, b) 等价于 a %= b。</span></span><br><span class="line">operator.imul(a, b) <span class="comment"># a = imul(a, b) 等价于 a *= b。</span></span><br><span class="line">operator.imatmul(a, b) <span class="comment"># a = imatmul(a, b) 等价于 a @= b</span></span><br><span class="line">operator.ior(a, b) <span class="comment"># a = ior(a, b) 等价于 a |= b。</span></span><br><span class="line">operator.ipow(a, b) <span class="comment"># a = ipow(a, b) 等价于 a **= b。</span></span><br><span class="line">operator.irshift(a, b) <span class="comment"># a = irshift(a, b) 等价于 a &gt;&gt;= b。</span></span><br><span class="line">operator.isub(a, b) <span class="comment"># a = isub(a, b) 等价于 a -= b。</span></span><br><span class="line">operator.itruediv(a, b) <span class="comment"># a = itruediv(a, b) 等价于 a /= b。</span></span><br><span class="line">operator.ixor(a, b) <span class="comment"># a = ixor(a, b) 等价于 a ^= b。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加法</td>
<td style="text-align:left">a + b</td>
<td style="text-align:left">add(a, b)</td>
</tr>
<tr>
<td style="text-align:left">字符串拼接</td>
<td style="text-align:left">seq1 + seq2</td>
<td style="text-align:left">concat(seq1, seq2)</td>
</tr>
<tr>
<td style="text-align:left">包含测试</td>
<td style="text-align:left">obj in seq</td>
<td style="text-align:left">contains(seq, obj)</td>
</tr>
<tr>
<td style="text-align:left">除法</td>
<td style="text-align:left">a / b</td>
<td style="text-align:left">truediv(a, b)</td>
</tr>
<tr>
<td style="text-align:left">除法</td>
<td style="text-align:left">a // b</td>
<td style="text-align:left">floordiv(a, b)</td>
</tr>
<tr>
<td style="text-align:left">按位与</td>
<td style="text-align:left">a &amp; b</td>
<td style="text-align:left">and_(a, b)</td>
</tr>
<tr>
<td style="text-align:left">按位异或</td>
<td style="text-align:left">a ^ b</td>
<td style="text-align:left">xor(a, b)</td>
</tr>
<tr>
<td style="text-align:left">按位取反</td>
<td style="text-align:left">~ a</td>
<td style="text-align:left">invert(a)</td>
</tr>
<tr>
<td style="text-align:left">按位或</td>
<td style="text-align:left">a | b</td>
<td style="text-align:left">or_(a, b)</td>
</tr>
<tr>
<td style="text-align:left">取幂</td>
<td style="text-align:left">a ** b</td>
<td style="text-align:left">pow(a, b)</td>
</tr>
<tr>
<td style="text-align:left">一致</td>
<td style="text-align:left">a is b</td>
<td style="text-align:left">is_(a, b)</td>
</tr>
<tr>
<td style="text-align:left">一致</td>
<td style="text-align:left">a is not b</td>
<td style="text-align:left">is_not(a, b)</td>
</tr>
<tr>
<td style="text-align:left">索引赋值</td>
<td style="text-align:left">obj[k] = v</td>
<td style="text-align:left">setitem(obj, k, v)</td>
</tr>
<tr>
<td style="text-align:left">索引删除</td>
<td style="text-align:left">del obj[k]</td>
<td style="text-align:left">delitem(obj, k)</td>
</tr>
<tr>
<td style="text-align:left">索引取值</td>
<td style="text-align:left">obj[k]</td>
<td style="text-align:left">getitem(obj, k)</td>
</tr>
<tr>
<td style="text-align:left">左移</td>
<td style="text-align:left">a &lt;&lt; b</td>
<td style="text-align:left">lshift(a, b)</td>
</tr>
<tr>
<td style="text-align:left">取模</td>
<td style="text-align:left">a % b</td>
<td style="text-align:left">mod(a, b)</td>
</tr>
<tr>
<td style="text-align:left">乘法</td>
<td style="text-align:left">a * b</td>
<td style="text-align:left">mul(a, b)</td>
</tr>
<tr>
<td style="text-align:left">矩阵乘法</td>
<td style="text-align:left">a @ b</td>
<td style="text-align:left">matmul(a, b)</td>
</tr>
<tr>
<td style="text-align:left">否定（算术）</td>
<td style="text-align:left">- a</td>
<td style="text-align:left">neg(a)</td>
</tr>
<tr>
<td style="text-align:left">否定（逻辑）</td>
<td style="text-align:left">not a</td>
<td style="text-align:left">not_(a)</td>
</tr>
<tr>
<td style="text-align:left">正数</td>
<td style="text-align:left">+ a</td>
<td style="text-align:left">pos(a)</td>
</tr>
<tr>
<td style="text-align:left">右移</td>
<td style="text-align:left">a &gt;&gt; b</td>
<td style="text-align:left">rshift(a, b)</td>
</tr>
<tr>
<td style="text-align:left">切片赋值</td>
<td style="text-align:left">seq[i:j] = values</td>
<td style="text-align:left">setitem(seq, slice(i, j), values)</td>
</tr>
<tr>
<td style="text-align:left">切片删除</td>
<td style="text-align:left">del seq[i:j]</td>
<td style="text-align:left">delitem(seq, slice(i, j))</td>
</tr>
<tr>
<td style="text-align:left">切片取值</td>
<td style="text-align:left">seq[i:j]</td>
<td style="text-align:left">getitem(seq, slice(i, j))</td>
</tr>
<tr>
<td style="text-align:left">字符串格式化</td>
<td style="text-align:left">s % obj</td>
<td style="text-align:left">mod(s, obj)</td>
</tr>
<tr>
<td style="text-align:left">减法</td>
<td style="text-align:left">a - b</td>
<td style="text-align:left">sub(a, b)</td>
</tr>
<tr>
<td style="text-align:left">真值测试</td>
<td style="text-align:left">obj</td>
<td style="text-align:left">truth(obj)</td>
</tr>
<tr>
<td style="text-align:left">比较</td>
<td style="text-align:left">a &lt; b</td>
<td style="text-align:left">lt(a, b)</td>
</tr>
<tr>
<td style="text-align:left">比较</td>
<td style="text-align:left">a &lt;= b</td>
<td style="text-align:left">le(a, b)</td>
</tr>
<tr>
<td style="text-align:left">相等</td>
<td style="text-align:left">a == b</td>
<td style="text-align:left">eq(a, b)</td>
</tr>
<tr>
<td style="text-align:left">不等</td>
<td style="text-align:left">a != b</td>
<td style="text-align:left">ne(a, b)</td>
</tr>
<tr>
<td style="text-align:left">比较</td>
<td style="text-align:left">a &gt;= b</td>
<td style="text-align:left">ge(a, b)</td>
</tr>
<tr>
<td style="text-align:left">比较</td>
<td style="text-align:left">a &gt; b</td>
<td style="text-align:left">gt(a, b)</td>
</tr>
</tbody>
</table>
<h4 id="内置函数-部分"><a class="markdownIt-Anchor" href="#内置函数-部分"></a> 内置函数 部分</h4>
<figure class="highlight python"><figcaption><span>内置函数 部分</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. input([prompt]) 返回为 string 类型</span></span><br><span class="line"><span class="comment"># 2. print(*objects, sep=&#x27; &#x27;, end=&#x27;\n&#x27;, file=sys.stdout, flush=False) 打印输出；flush = True，Loading 的效果</span></span><br><span class="line"><span class="comment"># 3. format 格式化字符串</span></span><br><span class="line"><span class="comment"># 4. help([object]) 返回对象帮助信息。</span></span><br><span class="line"><span class="comment"># 5. dir 返回当前范围内的变量、方法和定义的类型列表。带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。</span></span><br><span class="line"><span class="comment"># 6. open(file, mode=&#x27;r&#x27;) 打开一个文件，并返回文件对象;如果该文件无法被打开，会抛出 OSError;关闭文件对象，即调用 close() </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. type(name, bases, dict) 只有第一个参数则返回对象的类型，三个参数返回新的类型对象。</span></span><br><span class="line"><span class="comment"># 8. all(iterable) 判定容器内的元素全部都有意义</span></span><br><span class="line"><span class="comment"># 9. any(iterable) 判定容器内的元素存在一个有意义</span></span><br><span class="line"><span class="comment"># 10. bool([x]) 返回一个布尔值</span></span><br><span class="line"><span class="comment"># 12. str 返回一个对象的string格式。</span></span><br><span class="line"><span class="comment"># 13. repr(object) 返回一个对象的 string 格式</span></span><br><span class="line"><span class="comment"># 14. tuple( iterable ) 返回元组 将集合转换为元组时，只保留键！</span></span><br><span class="line"><span class="comment"># 15. list() 返回列表</span></span><br><span class="line"><span class="comment"># 16. dict 返回一个字典</span></span><br><span class="line"><span class="comment"># 17. set([iterable]) 创建一个无序不重复元素集-集合， &amp; 交集、 | 并集、 - 差集</span></span><br><span class="line"><span class="comment"># 18. frozenset([iterable]) 返回一个冻结的集合-不可变集合</span></span><br><span class="line"><span class="comment"># 19. map(function, iterable, ...) 返回迭代器，根据提供的函数对指定序列做映射</span></span><br><span class="line"><span class="comment"># 20. hash(object) 返回对象的哈希值。</span></span><br><span class="line"><span class="comment"># 21. zip([iterable, ...]) 返回一个对象。</span></span><br><span class="line"><span class="comment"># 22. id([object]) 返回对象的唯一标识符，CPython 中获取对象的内存地址</span></span><br><span class="line"><span class="comment"># 23. enumerate(sequence, [start=0]) 返回 enumerate(枚举) 对象，list中元素加入下标成元组类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24. iter(object[, sentinel]) 生成迭代器</span></span><br><span class="line"><span class="comment"># 25. reversed(seq) 返回一个反转的迭代器，使逆序</span></span><br><span class="line"><span class="comment"># 26. next() 返回迭代器的下一个项目</span></span><br><span class="line"><span class="comment"># 27. filter(function, iterable) 返回一个迭代器对象,使用 list() 来转换为列表</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>( [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>] , start=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 28. range(start, stop[, step]) 返回的结果是一个整数序列的对象</span></span><br><span class="line"><span class="comment"># 29. len() 返回对象长度。</span></span><br><span class="line"><span class="comment"># 30. slice(start, stop[, step]) 实现切片对象</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>)[<span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">25</span>,<span class="number">3</span>)]) <span class="comment"># [slice(2,25,3)]等同[2:25:3]</span></span><br><span class="line"><span class="comment"># 31. sorted(iterable, key=None, reverse=False) 返回重新排序的列表，对所有可迭代的对象进行排序操作；list.sort()会修改原始的 list</span></span><br><span class="line">d1 = [&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;score&#x27;</span>:<span class="number">38</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;score&#x27;</span>:<span class="number">18</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;darl&#x27;</span>, <span class="string">&#x27;score&#x27;</span>:<span class="number">28</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;christ&#x27;</span>, <span class="string">&#x27;score&#x27;</span>:<span class="number">28</span>&#125;]</span><br><span class="line"><span class="built_in">sorted</span>(d1, key=<span class="keyword">lambda</span> x:(-x[<span class="string">&#x27;score&#x27;</span>], x[<span class="string">&#x27;name&#x27;</span>])) <span class="comment"># 先按照成绩降序排序，相同成绩的按照名字升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 32. globals() 返回全局变量的字典</span></span><br><span class="line"><span class="comment"># 33. locals() 返回字典类型的局部变量。</span></span><br><span class="line"><span class="comment"># 34. vars([object]) 返回对象object的属性和属性值的字典对象，如果没有参数，就打印当前调用位置的属性和属性值 类似 locals()</span></span><br><span class="line"><span class="comment"># 35. memoryview(obj) 返回给定参数的内存查看对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 36. abs(x) 绝对值</span></span><br><span class="line"><span class="comment"># 37. max(x1, x2, ...) 最大值</span></span><br><span class="line"><span class="comment"># 38. min(x1, x2, ...) 最小值</span></span><br><span class="line"><span class="comment"># 39. pow(x,y) x**y</span></span><br><span class="line"><span class="comment"># 40. sum(iterable[, start]) 返回计算结果</span></span><br><span class="line"><span class="comment"># 41. round( x [, n]  ) 返回浮点数 x 的五舍六入的值</span></span><br><span class="line"><span class="comment"># 42. divmod 返回一个包含商和余数的元组</span></span><br><span class="line"><span class="comment"># 43. complex 返回一个复数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 44. ascii(object) 返回一个对象可打印的字符串</span></span><br><span class="line"><span class="comment"># 45. bytearray 返回一个新字节数组</span></span><br><span class="line"><span class="comment"># 46. chr 返回值对应的 ASCII 字符. chr(0x30) == chr(48) == 0</span></span><br><span class="line"><span class="comment"># 47. ord(c) 返回值是对应的十进制整数，与 chr() 函数相对</span></span><br><span class="line"><span class="comment"># 48. bin(x) 返回二进制字符串</span></span><br><span class="line"><span class="comment"># 49. oct(x) 返回一个8 进制字符串，以 0o 开头</span></span><br><span class="line"><span class="comment"># 50. int(x[, base=10]) 返回整型数据</span></span><br><span class="line"><span class="comment"># 51. hex([x]) 返回一个16 进制字符串，以 0x 开头。</span></span><br><span class="line"><span class="comment"># 52. float([x]) 返回浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 53. eval(expression[, globals[, locals]]) 执行一个字符串表达式，并返回表达式的值</span></span><br><span class="line"><span class="comment"># 54. exec(object[, globals[, locals]]) 返回表达式的值，支持动态执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 55. __import__(name[, globals[, locals[, fromlist[, level]]]]) 用于动态加载类和函数</span></span><br><span class="line"><span class="comment"># 56. isinstance(object, classinfo) 判断obj是否和某类有关系</span></span><br><span class="line"><span class="comment"># 57. issubclass(class, classinfo) 判断class 是否是 classinfo 的子类。</span></span><br><span class="line"><span class="comment"># 58. super(type[, object-or-type]) 用于调用父类(超类)的一个方法，解决多重继承问题——查找顺序（MRO）、重复调用（钻石继承）等</span></span><br><span class="line"><span class="comment"># 59. staticmethod 修饰符，声明一个静态方法，不强制要求传递参数，</span></span><br><span class="line"><span class="comment"># 60. classmethod 修饰符, 对象不需要实例化，函数不需要 self 参数。但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等</span></span><br><span class="line"><span class="comment"># 61. compile(source, filename, mode[, flags[, dont_inherit]]) 返回表达式执行结果。</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="built_in">compile</span>(<span class="string">&quot;for i in range(0,10): print(i)&quot;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>))</span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">compile</span>(<span class="string">&quot;3 * 4 + 5&quot;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 62. setattr 用于[创建]设置属性值</span></span><br><span class="line"><span class="comment"># 63. getattr(object, name[, default]) 返回一个对象属性值</span></span><br><span class="line"><span class="comment"># 64. hasattr(object, name) 判断对象是否包含对应的属性</span></span><br><span class="line"><span class="comment"># 65. delattr(object, name) 删除对象属性</span></span><br><span class="line"><span class="built_in">dict</span>(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>, t=<span class="string">&#x27;t&#x27;</span>)   <span class="comment"># 传入关键字</span></span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   <span class="comment"># 映射函数方式来构造字典</span></span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])    <span class="comment"># 可迭代对象方式来构造字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 66. property([fget[, fset[, fdel[, doc]]]]) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setx</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._x = value</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"> </span><br><span class="line">    x = <span class="built_in">property</span>(getx, setx, delx, <span class="string">&quot;I&#x27;m the &#x27;x&#x27; property.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 c 是 C 的实例化, c.x 将触发 getter,c.x = value 将触发 setter ， del c.x 触发 deleter。如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 property 函数用作装饰器可以很方便的创建只读属性</span></span><br><span class="line"><span class="comment"># 下面的代码将 voltage() 方法转化成同名只读属性的 getter 方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._voltage = <span class="number">100000</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">voltage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._voltage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># property 的 getter,setter 和 deleter 方法同样可以用作装饰器，这个代码和第一个例子完全相同：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._x = value</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._x</span><br></pre></td></tr></table></figure>
<h3 id="2-python-内建数据类型有哪些"><a class="markdownIt-Anchor" href="#2-python-内建数据类型有哪些"></a> 2. Python 内建数据类型有哪些？</h3>
<p>六个标准的数据类型：</p>
<ul>
<li>Number（数字类别）: int、float、bool、complex</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br />
可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>
<p>字典中的键是不可变类型，可变类型<code>list</code>和<code>dict</code>不能作为字典键<br />
一个对象能不能作为字典的key，就取决于其有没有<code>__hash__</code>方法</p>
<blockquote>
<p>另：映射 map、类 class、实例 、异常 BaseException</p>
</blockquote>
<h3 id="3-简述-with-方法打开处理文件帮我我们做了什么"><a class="markdownIt-Anchor" href="#3-简述-with-方法打开处理文件帮我我们做了什么"></a> 3. 简述 with 方法打开处理文件帮我我们做了什么？</h3>
<p><code>with</code>语句是“上下文管理器”，用于资源访问的场合，作用是资源释放和异常处理。<br />
如果按照常规的 <code>f.open</code> 写法，我们需要 <code>try</code>,<code>except</code>,<code>finally</code>，做异常判断，并且文件最终不管遇到什么情况，都要在<code>finally</code>里执行<code>f.close()</code>关闭文件，而<code>with</code>方法帮我们实现了<code>finally</code>中<code>f.close</code>。</p>
<p><code>with</code>语句支持通过上下文管理器所定义的运行时上下文</p>
<ul>
<li>object.<strong>enter</strong>（自我）<br />
输入与此对象相关的运行时上下文。该with语句会将此方法的返回值绑定到as该语句的子句中指定的目标（ 如果有）。</li>
<li>object.<strong>exit</strong>（self，exc_type，exc_value，traceback ）<br />
退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 None。</li>
</ul>
<blockquote>
<p>如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。<br />
请注意 <strong>exit</strong>() 方法不应该重新引发被传入的异常，这是调用者的责任。</p>
</blockquote>
<h3 id="4-列出-python-中可变数据类型和不可变数据类型为什么"><a class="markdownIt-Anchor" href="#4-列出-python-中可变数据类型和不可变数据类型为什么"></a> 4. 列出 Python 中可变数据类型和不可变数据类型，为什么？</h3>
<p>变量更改后地址（<code>id()</code>）是否发生改变<br />
不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br />
可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。<br />
()</p>
<h3 id="5-python-获取当前日期"><a class="markdownIt-Anchor" href="#5-python-获取当前日期"></a> 5. Python 获取当前日期？</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime.now()</span><br><span class="line"><span class="comment"># &gt;: 2021-06-20 02:12:37</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.ctime()</span><br><span class="line"><span class="comment"># &gt;: Sun Jun 20 02:12:37 2021</span></span><br><span class="line"></span><br><span class="line">time.time() <span class="comment"># 返回当前时间戳</span></span><br><span class="line"><span class="comment"># &gt;: 1624126357</span></span><br><span class="line"></span><br><span class="line">time.localtime() <span class="comment">#  返回当前时间结构元组</span></span><br><span class="line"><span class="comment"># &gt;: time.struct_time(tm_year=2021, tm_mon=6, tm_mday=20, tm_hour=2, tm_min=12, tm_sec=37, tm_wday=6, tm_yday=171, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,) <span class="comment"># 格式化输出当前时间</span></span><br></pre></td></tr></table></figure>
<h3 id="6-统计字符串每个单词出现的次数"><a class="markdownIt-Anchor" href="#6-统计字符串每个单词出现的次数"></a> 6. 统计字符串每个单词出现的次数</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;I can because i think i can&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">result = Counter(s.split())</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">result = &#123;word: s.split().count(word) <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">set</span>(s.split())&#125;</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h3 id="7-用-python-删除文件和用-linux-命令删除文件方法"><a class="markdownIt-Anchor" href="#7-用-python-删除文件和用-linux-命令删除文件方法"></a> 7. 用 python 删除文件和用 linux 命令删除文件方法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(filepath) <span class="comment"># 删除文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 文件名</span><br><span class="line">rm -rf *文件名关键字*</span><br></pre></td></tr></table></figure>
<h3 id="8-写一段自定义异常代码"><a class="markdownIt-Anchor" href="#8-写一段自定义异常代码"></a> 8. 写一段自定义异常代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,*args</span>):</span><br><span class="line">        self.args = args</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumErorr</span>(<span class="title class_ inherited__">MyException</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,numA,numB</span>):</span><br><span class="line">        self.numA=numA</span><br><span class="line">        self.numB=numB</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;本计算器只接收整数!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyException(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">    <span class="keyword">raise</span> NumErorr(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> NumErorr <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">except</span> MyException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<h3 id="9-举例说明异常模块中-try-except-else-finally-的相关意义"><a class="markdownIt-Anchor" href="#9-举例说明异常模块中-try-except-else-finally-的相关意义"></a> 9. 举例说明异常模块中 try except else finally 的相关意义</h3>
<ul>
<li>try…except…else没有捕获到异常，执行else语句</li>
<li>try…except…finally不管是否捕获到异常，都执行finally语句</li>
</ul>
<h3 id="10-遇到-bug-如何处理"><a class="markdownIt-Anchor" href="#10-遇到-bug-如何处理"></a> 10. 遇到 bug 如何处理</h3>
<ul>
<li>细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log</li>
<li>assert / try-except / IDE单步调式</li>
<li>如果涉及一些第三方框架，会去查官方文档或者一些技术博客。</li>
<li>issue中查询是否有相似bug</li>
</ul>
<h2 id="语言特性"><a class="markdownIt-Anchor" href="#语言特性"></a> 语言特性</h2>
<h3 id="1-谈谈对-python-和其他语言的区别"><a class="markdownIt-Anchor" href="#1-谈谈对-python-和其他语言的区别"></a> 1. 谈谈对 Python 和其他语言的区别</h3>
<p>语言特点：简洁、优雅，省略了各种大括号和分号，还有一些关键字，类型说明；<br />
语言类型：解释型语言，运行的时候是一行一行的解释，并运行，所以调试代码很方便，开发效率很高；<br />
第三方库：python是开源的，并且python的定位是任由其发展。Python具有非常完备的第三方库；标准库与第三方库都非常强大，而且应用领域也非常广，比如Web，运维，自动化测试，爬虫，数据分析，人工智能。</p>
<p>和Java相比：在很多方面，Python比Java要简单，比如java中所有变量必须声明才能使用，而Python不需要声明,用少量的代码构建出很多功能;（高效的高级数据结构）</p>
<p>和C相比：类库齐全并且使用简洁，很少代码实现的功能用C可能要很复杂。运行速度相较于C，绝对是很慢了，Python和CPython解释器都是C语言编写的</p>
<h3 id="2-简述解释型和编译型编程语言"><a class="markdownIt-Anchor" href="#2-简述解释型和编译型编程语言"></a> 2. 简述解释型和编译型编程语言</h3>
<p>解释型：就是边解释边执行；<br />
编译性：编译后再执行</p>
<h3 id="3-python-的解释器种类以及相关特点"><a class="markdownIt-Anchor" href="#3-python-的解释器种类以及相关特点"></a> 3. Python 的解释器种类以及相关特点？</h3>
<p>CPython：c语言开发的 使用最广的解释器<br />
IPython：基于cpython之上的一个交互式计时器 交互方式增强 功能和cpython一样<br />
PyPy：目标是执行效率 采用JIT技术 对python代码进行动态编译，提高执行效率<br />
Jython/JPython：运行在Java上的解释器 直接把python代码编译成Java字节码执行<br />
IronPython：运行在微软 .NET 平台上的解释器，把python编译成. NET 的字节码</p>
<h3 id="4-说说你知道的python3-和-python2-之间的区别"><a class="markdownIt-Anchor" href="#4-说说你知道的python3-和-python2-之间的区别"></a> 4. 说说你知道的Python3 和 Python2 之间的区别？</h3>
<p>python3 和 python2 是不兼容的，而且差异比较大。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python2</th>
<th style="text-align:left">Python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python2 打印内容可以不用带小括号</td>
<td style="text-align:left">Python3 中必须带；</td>
</tr>
<tr>
<td style="text-align:left">Python2 <code>range(1,10)</code>返回列表</td>
<td style="text-align:left">Python3 返回迭代器，节约内存；</td>
</tr>
<tr>
<td style="text-align:left">Python2 中使用ascii编码</td>
<td style="text-align:left">Python3 中使用utf-8编码；</td>
</tr>
<tr>
<td style="text-align:left">python2中unicode表示字符串序列，str表示字节序列</td>
<td style="text-align:left">python3中 str表示字符串序列，byte表示字节序列；</td>
</tr>
<tr>
<td style="text-align:left">python2中为正常显示中文，引入coding声明</td>
<td style="text-align:left">python3中 不需要</td>
</tr>
<tr>
<td style="text-align:left">python2中在使用<code>super()</code>必须在参数中写上基类</td>
<td style="text-align:left">python3中 不需要，直接无参数调用即可</td>
</tr>
<tr>
<td style="text-align:left">python2中True 和 <code>False</code> 是两个全局变量</td>
<td style="text-align:left">python3中 True或False不可变</td>
</tr>
<tr>
<td style="text-align:left">python2中range,字典对象的 <code>dict.keys()</code>、<code>dict.values()</code> 方法, <code>map</code>、<code>filter</code>、<code>zip</code>等返回列表，迭代器必须实现next方法</td>
<td style="text-align:left">python3中 将返回列表的方法改为了返回迭代器对象，内置了__next__，不用特意去实现next，<code>rang()</code>相当于python2中 <code>xrang()</code></td>
</tr>
<tr>
<td style="text-align:left">python2中 没有办法在嵌套函数中将变量声明为一个非局部变量，只能在函数中声明全局变量</td>
<td style="text-align:left">python3中 <code>nonlocal</code>方法实现声明全局变量</td>
</tr>
<tr>
<td style="text-align:left">python2中函数定义不可以用中文定义</td>
<td style="text-align:left">python3中可以用中文</td>
</tr>
</tbody>
</table>
<h3 id="5-python3-和-python2-中-int-和-long-区别"><a class="markdownIt-Anchor" href="#5-python3-和-python2-中-int-和-long-区别"></a> 5. Python3 和 Python2 中 int 和 long 区别？</h3>
<p>python3 中 <code>int</code> 整合了 python2 重中的 <code>int</code> 和 <code>long</code><br />
python3 中 <code>int</code> 类型的范围是动态长度的，正整数或者负整数，用<code>sys.getsizeof()</code>可以看int占了几位.<br />
Python2中<code>long</code>类型的范围是无限大小</p>
<h3 id="6-xrange-和-range-的区别"><a class="markdownIt-Anchor" href="#6-xrange-和-range-的区别"></a> 6. xrange 和 range 的区别？</h3>
<p>python2 中<code>xrang()</code>返回到的是迭代器对象，<code>rang()</code>返回的是list列表类型<br />
python3 中弃用了<code>xrang()</code>，<code>rang()</code>返回到的是迭代器对象</p>
<h3 id="7-强类型语言-动态语言和脚本语言之间的区别"><a class="markdownIt-Anchor" href="#7-强类型语言-动态语言和脚本语言之间的区别"></a> 7. 强类型语言、动态语言和脚本语言之间的区别？</h3>
<p>强类型：不允许不同类型相加。例如：整形+字符串会报类型错误。<br />
动态：不使用显示数据类型声明，且确定一个变量的类型是在第一次给它赋值的时候。<br />
脚本语言：一般是解释性语言，运行代码只需要一个解释器，不需要编辑。</p>
<h2 id="编码规范"><a class="markdownIt-Anchor" href="#编码规范"></a> 编码规范</h2>
<h3 id="1-什么是-pep8"><a class="markdownIt-Anchor" href="#1-什么是-pep8"></a> 1. 什么是 PEP8?</h3>
<p><a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a>(Python Enhancement Proposal 8)，是 Python 第8号增强提案，针对Python语言编订的代码风格指南、编码约定。</p>
<ul>
<li>缩进。4个空格的缩进，不使用Tap，更不能混合使用Tap和空格</li>
<li>每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。</li>
<li>类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。</li>
<li>模块导入的顺序：按标准、三方和自己编写顺序依次导入，之间空一行。</li>
<li>不要在一句中import多个库</li>
<li>避免不必要的空格</li>
<li>注释必须要有</li>
<li>函数命名要遵循规范</li>
<li>尽可能使用’is’‘is not’取代’=='，比如if x is not None 要优于if x</li>
<li>异常中try的代码尽可能少</li>
</ul>
<h3 id="2-了解-python-之禅么"><a class="markdownIt-Anchor" href="#2-了解-python-之禅么"></a> 2. 了解 Python 之禅么？</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">#(优美胜于丑陋)</span></span><br><span class="line"><span class="string"># Python 以编写优美的代码为目标</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">#(明了胜于晦涩)</span></span><br><span class="line"><span class="string"># 优美的代码应当是明了的，命名规范，风格相似</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">#(简洁胜于复杂)</span></span><br><span class="line"><span class="string"># 优美的代码应当是简洁的，不要有复杂的内部实现</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">#(复杂胜于凌乱)</span></span><br><span class="line"><span class="string"># 如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">#(扁平胜于嵌套)</span></span><br><span class="line"><span class="string"># 优美的代码应当是扁平的，不能有太多的嵌套</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">#(间隔胜于紧凑)</span></span><br><span class="line"><span class="string"># 优美的代码有适当的间隔，不要奢望一行代码解决问题</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">#(可读性很重要)</span></span><br><span class="line"><span class="string"># 优美的代码是可读的</span></span><br><span class="line"><span class="string">Special cases aren&#x27;t special enough to break the rules.</span></span><br><span class="line"><span class="string">#(即便假借特例的实用性之名，也不可违背这些规则)</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string"># 这些规则至高无上</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">#(不要包容所有错误，除非你确定需要这样做)</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string"># 精准地捕获异常，不写 except:pass 风格的代码</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">#(当存在多种可能，不要尝试去猜测)</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">#(而是尽量找一种，最好是唯一一种明显的解决方案)</span></span><br><span class="line"><span class="string"># 如果不确定，就用穷举法</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you&#x27;re Dutch.</span></span><br><span class="line"><span class="string">#(虽然这并不容易，因为你不是 Dutch )</span></span><br><span class="line"><span class="string">#  Dutch 是指 Guido -- Python 之父</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">#(做也许好过不做)</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">#(但不假思索就动手还不如不做)</span></span><br><span class="line"><span class="string"># 动手之前要细思量</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it&#x27;s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">#(如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然)</span></span><br><span class="line"><span class="string"># 方案测评标准</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let&#x27;s do more of those!</span></span><br><span class="line"><span class="string">#(命名空间是一种绝妙的理念，我们应当多加利用)</span></span><br><span class="line"><span class="string"># 倡导与号召</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-了解-docstring-么"><a class="markdownIt-Anchor" href="#3-了解-docstring-么"></a> 3. 了解 docstring 么？</h3>
<p>Python 文档字符串(<code>DocStrings</code>)是一个用于解释文档程序，生成帮助文档的重要工具。通过<code>Docstring</code>建立的文档不仅对人来说有更好的可读性，也能够让IDE等工具自动识别使用函数、类、变量等的一些限制，从而帮助我们更好地理解程序。<br />
<code>PEP0257</code>里的约定使用三个双引号（“”&quot;）来定义文档字符串，也可以但不建议使用三个单引号 ‘’'，<code>docstring</code>可以写在三个地方：模块或包，对象，函数。<br />
使用惯例：首行简述函数功能，第二行空行，第三行为函数的具体描述。</p>
<p>通过<code>__doc__</code>（注意双下划线）调用函数中的文档字符串属性。<br />
通过<code>help</code>函数直接输出一份有格式的文档，主要是在交互模式下使用</p>
<p>Python Docstring有三种主要风格，分别是<code>reST</code>风格、<code>Google</code>风格、<code>Numpy</code>风格和<code>Epytext</code>风格等：</p>
<h4 id="rest风格"><a class="markdownIt-Anchor" href="#rest风格"></a> <code>reST</code>风格</h4>
<ul>
<li><code>reST</code>的全称是<code>reStructredText</code>。通过以冒号开头的几个关键字来说明类、函数中的参数、返回值、异常等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:param &lt;类属性名称&gt;: &lt;描述&gt;</span><br><span class="line">:type &lt;类属性名称&gt;: &lt;类型&gt;</span><br><span class="line">:return: &lt;对返回值的描述&gt;</span><br><span class="line">:rtype: &lt;返回值类型&gt;</span><br><span class="line">:raises: &lt;可能抛出的异常列表&gt;</span><br></pre></td></tr></table></figure>
<h4 id="google风格"><a class="markdownIt-Anchor" href="#google风格"></a> <code>Google</code>风格</h4>
<ul>
<li><code>Google</code> 风格将所有的参数写在<code>Args</code>标签下，而所有的返回值写在<code>Returns</code>标签下。我个人认为比起<code>reST</code>风格，<code>Google</code> 风格的可读性要更好一些。在<code>Args</code>标签下，可以在参数名称后面加 <code>(类型)</code>来确定参数的类型，同样可以起到对参数类型的限制作用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Args:</span><br><span class="line">  &lt;参数&gt; : &lt;描述&gt;</span><br><span class="line">  &lt;参数&gt; (&lt;类型&gt;): &lt;描述&gt;</span><br><span class="line">Returns:</span><br><span class="line">  &lt;类型&gt;: &lt;描述&gt;</span><br></pre></td></tr></table></figure>
<h4 id="numpy风格"><a class="markdownIt-Anchor" href="#numpy风格"></a> <code>Numpy</code>风格</h4>
<ul>
<li><code>Numpy</code>是矩阵分析、科学计算、机器学习中都会用到的常见Python程序库。<code>Numpy</code>也有自己独特的Python Docstring风格。<code>Numpy</code>风格的<code>docstring</code>似乎不能用<code>sphinx</code>来生成<code>html</code>形式的文档。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Parameters</span><br><span class="line">----------</span><br><span class="line">参数 : [类型]</span><br><span class="line">    参数的描述</span><br><span class="line">    </span><br><span class="line">Attributes</span><br><span class="line">----------</span><br><span class="line">属性 : [类型]</span><br><span class="line">    属性的描述</span><br></pre></td></tr></table></figure>
<h4 id="epytext风格"><a class="markdownIt-Anchor" href="#epytext风格"></a> <code>Epytext</code>风格</h4>
<ul>
<li><code>Epytext</code>类似于<code>javadoc</code>的风格</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@param a:</span><br><span class="line">@param b:</span><br><span class="line">@return:</span><br></pre></td></tr></table></figure>
<h3 id="4-了解类型注解么"><a class="markdownIt-Anchor" href="#4-了解类型注解么"></a> 4. 了解类型注解么？</h3>
<p>类型注解是从 Python 3.5 开始引入，提高代码的可读性，可以通过第三方工具测试代码里的类型注解正确性。<br />
变量类型注解需要 Python 3.6 以上版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 注解前</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"># 加注解</span><br><span class="line">def add(x: int, y: int) -&gt; int:</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"># 查看参数和返回值类型的注解</span><br><span class="line">print(add.__annotations__)</span><br><span class="line"></span><br><span class="line"># inspect 模块提供了一些有用的函数帮助获取对象的信息，例如模块、类、方法、函数、回溯、帧对象以及代码对象。例如它可以帮助你检查类的内容，获取某个方法的源代码，取得并格式化某个函数的参数列表，或者获取你需要显示的回溯的详细信息。</span><br><span class="line"># 该模块提供了4种主要的功能：类型检查、获取源代码、检查类与函数、检查解释器的调用堆栈。</span><br><span class="line"># 文档: https://docs.python.org/zh-cn/3.7/library/inspect.html</span><br><span class="line"></span><br><span class="line">import inspect</span><br><span class="line"></span><br><span class="line">print(sig = inspect.signature(add))</span><br><span class="line">print(sig)</span><br><span class="line">print(sig.parameters)</span><br><span class="line">print(sig.return_annotation)</span><br><span class="line">print(sig.parameters[&#x27;x&#x27;])</span><br></pre></td></tr></table></figure>
<p>使用第三方包<code>mypy</code>测试注解的正确性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">pip install mypy</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">mypy filename.py</span><br></pre></td></tr></table></figure>
<h3 id="5-例举你知道-python-对象的命名规范例如方法或者类等"><a class="markdownIt-Anchor" href="#5-例举你知道-python-对象的命名规范例如方法或者类等"></a> 5. 例举你知道 Python 对象的命名规范，例如方法或者类等</h3>
<h4 id="-变量"><a class="markdownIt-Anchor" href="#-变量"></a> - 变量：</h4>
<ol>
<li>单下划线开头(_xx): protected</li>
<li>双下划线开头(__xx): private</li>
<li>双下划线开头结尾(<strong>xx</strong>): 系统内置变量</li>
</ol>
<h4 id="-函数"><a class="markdownIt-Anchor" href="#-函数"></a> - 函数</h4>
<ol>
<li>私有方法(_func): 小写和一个前导下划线</li>
<li>特殊方法(魔术方法)(<strong>func</strong>): 小写和两个前导下划线，两个后置下划线</li>
<li>一般方法(func): 方法<br />
备注: 函数参数: 小写和下划线，缺省值等号两边无空格 <code>def func(self, user=None)</code>:</li>
</ol>
<h4 id="-类"><a class="markdownIt-Anchor" href="#-类"></a> - 类</h4>
<ol>
<li>驼峰格式命名(CamelClass): 所有单词首字母大写其余字母小写</li>
<li>基类而言，可以使用一个Base或者Abstract前缀(CamelBase)</li>
<li>不要滥用*args和**kwargs，可能会破坏函数的健壮性</li>
</ol>
<h4 id="-常量"><a class="markdownIt-Anchor" href="#-常量"></a> - 常量</h4>
<p>大写，单词间用下划线</p>
<h3 id="6-python-中的注释有几种"><a class="markdownIt-Anchor" href="#6-python-中的注释有几种"></a> 6. Python 中的注释有几种？</h3>
<p>单行注释：#<br />
多行注释：一对’''或者一对&quot;“”</p>
<h3 id="7-如何优雅的给一个函数加注释"><a class="markdownIt-Anchor" href="#7-如何优雅的给一个函数加注释"></a> 7. 如何优雅的给一个函数加注释？</h3>
<p><a href="#3-%E4%BA%86%E8%A7%A3-docstring-%E4%B9%88%EF%BC%9F"><em>Docstring</em></a> 上文有提到。<br />
另，注释的种类：</p>
<ol>
<li>复述代码——这种把代码复述一遍的注释最无聊</li>
<li>解释代码——解释代码的思路，这种代码可以有，但是大部分时候是因为代码写得不好</li>
<li>标记——可能用的到标注，如 TODO、FIXME</li>
<li>概述代码——一句话告诉别人代码做了什么，很好的注释代码</li>
<li>意图说明——指出代码要解决的问题</li>
<li>传达代码无法表述的信息——非常重要</li>
</ol>
<h3 id="8-如何给变量加注释"><a class="markdownIt-Anchor" href="#8-如何给变量加注释"></a> 8. 如何给变量加注释？</h3>
<p><a href="#3-%E4%BA%86%E8%A7%A3-docstring-%E4%B9%88%EF%BC%9F"><em>Docstring</em></a> 上文有提到</p>
<h3 id="9-python-代码缩进中是否支持-tab-键和空格混用"><a class="markdownIt-Anchor" href="#9-python-代码缩进中是否支持-tab-键和空格混用"></a> 9. Python 代码缩进中是否支持 Tab 键和空格混用。</h3>
<p>支持但不建议，如果混用的话，tab按8个空格算</p>
<h3 id="10-是否可以在一句-import-中导入多个库"><a class="markdownIt-Anchor" href="#10-是否可以在一句-import-中导入多个库"></a> 10. 是否可以在一句 import 中导入多个库?</h3>
<p>可以但不建议</p>
<h3 id="11-在给-py-文件命名的时候需要注意什么"><a class="markdownIt-Anchor" href="#11-在给-py-文件命名的时候需要注意什么"></a> 11. 在给 Py 文件命名的时候需要注意什么?</h3>
<p>全小写，可使用下划线，不可与第三方库、内建模块等重名。</p>
<h3 id="12-例举几个规范-python-代码风格的工具"><a class="markdownIt-Anchor" href="#12-例举几个规范-python-代码风格的工具"></a> 12. 例举几个规范 Python 代码风格的工具</h3>
<p><a href="#3-%E4%BA%86%E8%A7%A3-docstring-%E4%B9%88%EF%BC%9F"><em>Docstring</em></a> 上文有提到</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3>
<h4 id="1-列举-python-中的基本数据类型"><a class="markdownIt-Anchor" href="#1-列举-python-中的基本数据类型"></a> 1. 列举 Python 中的基本数据类型？</h4>
<p><a href="./#2-Python-%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><em>基本数据类型</em></a>上文有提到</p>
<h4 id="2-如何区别可变数据类型和不可变数据类型"><a class="markdownIt-Anchor" href="#2-如何区别可变数据类型和不可变数据类型"></a> 2. 如何区别可变数据类型和不可变数据类型</h4>
<p><a href="./#4-%E5%88%97%E5%87%BA-Python-%E4%B8%AD%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><em>可变数据类型&amp;不可变数据类型</em></a>上文有提到</p>
<h4 id="3-将hello-world转换为首字母大写hello-world"><a class="markdownIt-Anchor" href="#3-将hello-world转换为首字母大写hello-world"></a> 3. 将&quot;hello world&quot;转换为首字母大写&quot;Hello World&quot;</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成标题</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># capitalize() 将字符串的第一个字母变成大写，其他字母变小写</span></span><br><span class="line"><span class="comment"># upper() 将字符串的所有字母变成大写</span></span><br><span class="line">words = <span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>([word.capitalize() <span class="keyword">for</span> word <span class="keyword">in</span> words])</span><br><span class="line"><span class="built_in">print</span>([word[<span class="number">0</span>].upper()+word[<span class="number">1</span>:] <span class="keyword">for</span> word <span class="keyword">in</span> words])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-如何检测字符串中只含有数字"><a class="markdownIt-Anchor" href="#4-如何检测字符串中只含有数字"></a> 4. 如何检测字符串中只含有数字?</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">str</span>.isdigit()</span><br><span class="line"><span class="built_in">str</span>.isnumeric() <span class="comment"># 只是针对Unicode对象</span></span><br></pre></td></tr></table></figure>
<h4 id="5-将字符串ilovechina进行反转"><a class="markdownIt-Anchor" href="#5-将字符串ilovechina进行反转"></a> 5. 将字符串&quot;ilovechina&quot;进行反转</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;ilovechina&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行</span></span><br><span class="line">newStr = <span class="built_in">str</span>[::-<span class="number">1</span>]</span><br><span class="line">newStr = <span class="string">&#x27;&#x27;</span>.join(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>[::-<span class="number">1</span>])</span><br><span class="line">newStr = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">str</span>)))</span><br><span class="line">newStr = <span class="string">&#x27;&#x27;</span>.join(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两行</span></span><br><span class="line">str_list = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">newStr = <span class="string">&#x27;&#x27;</span>.join( ( str_list, str_list.reverse() )[<span class="number">0</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表倒序(按 “ASCII 字符顺序” 进行排序)</span></span><br><span class="line">str_list = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">str_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">newStr = <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累积相加法</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>) :</span><br><span class="line">    <span class="keyword">return</span> y + x</span><br><span class="line">newStr = reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累积相加法 进阶</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">newStr = reduce(<span class="keyword">lambda</span> x,y:y+x, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累积相加法 高阶</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">newStr = reduce(<span class="keyword">lambda</span> x,y:y+x, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒序切片法</span></span><br><span class="line">newStr = <span class="built_in">str</span>[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(newStr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表弹出</span></span><br><span class="line">newStr= <span class="string">&quot;&quot;</span></span><br><span class="line">str_list = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(str_list) &gt; <span class="number">0</span>:</span><br><span class="line">    newStr = newStr + str_list.pop()</span><br><span class="line"><span class="built_in">print</span>(newStr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环反向迭代法</span></span><br><span class="line">newStr= <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    newStr = i + newStr</span><br><span class="line"><span class="built_in">print</span>(newStr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表反转</span></span><br><span class="line">str_list = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">str_list.reverse()</span><br><span class="line">newStr = <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br><span class="line"><span class="built_in">print</span>(newStr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 善用递归</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> s[-<span class="number">1</span>] + func(s[:-<span class="number">1</span>])</span><br><span class="line">newStr = func(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(newStr)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h4 id="6-python-中的字符串格式化方式你知道哪些"><a class="markdownIt-Anchor" href="#6-python-中的字符串格式化方式你知道哪些"></a> 6. Python 中的字符串格式化方式你知道哪些？</h4>
<p>由双引号包围的是格式化字符串，可以理解为一个字符串模板。特别地，由三引号包围的字符串更为直观，之间的所有字符，包括换行、TAB，都属于字符串的内容。Python的字符串格式化有两种方式:<code>%</code>格式符方式，<code>format</code>方式、<code>f-string</code>方式。</p>
<ol>
<li><code>%</code>格式符方式: <code>%[(name)][flags][width].[precision]typecode</code><br />
|  | 解释 |<br />
| :----- | :----- |<br />
| (name) | 指定变量 |<br />
| flags| 默认右对齐，正数前无符号，负数前加负号，用空格填充空白处<br>转为浮点数同时默认以0补充至小数点后6位，第7位开始用空格补充<br> 可选值: <br>  <code>+</code>:正数前加正号<br>  <code>-</code>:左对齐<br>  <code>0</code>:用0填充空白处 |<br />
| width | 最小占有宽度 |<br />
| .precision | 小数点后保留的位数|<br />
| typecode | 转换符号 <br>%d、%i	转换为带符号的十进制整数<br>%o 转换为带符号的八进制整数<br>%x、%X 转换为带符号的十六进制整数<br>%e 转化为科学计数法表示的浮点数（e 小写）<br>%E 转化为科学计数法表示的浮点数（E 大写）<br>%f、%F	转化为十进制浮点数<br>%g 智能选择使用 %f 或 %e 格式<br>%G 智能选择使用 %F 或 %E 格式<br>%c 格式化字符及其 ASCII 码<br>%r 使用 repr() 函数将表达式转换为字符串<br>%s 使用 str() 函数将表达式转换为字符串|</li>
</ol>
<div class="note info"><p>几点说明：</p>
<ul>
<li>对于整数，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。</li>
<li>对于小数，以上三个标志可以同时存在。如果没有要求小数位，则默认以0补充至小数点后6位，第7位开始用空格补充。</li>
<li>对于字符串，只能使用-标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。</li>
<li>当字符串中存在格式化标志时，需要用 %%表示一个百分号</li>
</ul>
</div>
<ol start="2">
<li>format<br />
数字格式的定义以 ‘:’ 号开始。碰到了’: '字符就知道要定义一个数字的显示格式了。格式的定义顺序为 <code>[[fill]align][sign][#][0][width][,][.precision][type]</code><br />
||解释|<br />
|:–|:–|<br />
| fill | 【可选】空白处填充的字符 |<br />
| align| 【可选】对齐方式（需配合width使用）<br>&lt;，内容左对齐<br>&gt;，内容右对齐(默认)<br>＝，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号+填充物+数字<br>^，内容居中 |<br />
| sign | 【可选】有无符号数字<br>+，正号加正，负号加负；<br>-，正号不变，负号加负；<br>空格 ，正号空格，负号加负； |<br />
| # | 【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示|<br />
| , |【可选】为数字添加分隔符，如：1,000,000 |<br />
| width | 【可选】格式化位所占宽度 |<br />
| .precision |【可选】小数位保留精度 |<br />
| type | 【可选】格式化类型<br>s，格式化字符串类型数据<br>空白，未指定类型，则默认是None，同s<br>b，将10进制整数自动转换成2进制表示然后格式化<br>c，将10进制整数自动转换为其对应的unicode字符<br>d，十进制整数<br>o，将10进制整数自动转换成8进制表示然后格式化；<br>x，将10进制整数自动转换成16进制表示然后格式化（小写x）<br>X，将10进制整数自动转换成16进制表示然后格式化（大写X）<br>e， 转换为科学计数法（小写e）表示，然后格式化；<br>E， 转换为科学计数法（大写E）表示，然后格式化;<br>f ， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；<br>F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；<br>g， 自动在e和f中切换<br>G， 自动在E和F中切换<br>%，显示百分比（默认显示小数点后6位） |</li>
<li>f-string<br />
<code>f-string</code>就是在<code>format</code>格式化的基础之上做了一些变动，核心使用思想和<code>format</code>一样。在这个方式中，大括号{ }里放被替换字段\变量，在<code>:</code>前可以填入表达式或调用函数或匿名函数。</li>
</ol>
<h4 id="7-把一个字符串开头和末尾都有空格"><a class="markdownIt-Anchor" href="#7-把一个字符串开头和末尾都有空格"></a> 7. 把一个字符串开头和末尾都有空格</h4>
<p>比如&quot; adabdw &quot;,要求写一个函数把这个字符串的前后空格都去掉。</p>
<ol>
<li>strip()：把头和尾的空格去掉</li>
<li>lstrip()：把左边的空格去掉</li>
<li>rstrip()：把右边的空格去掉</li>
<li>replace(‘c1’,‘c2’)：把字符串里的c1替换成c2。故可以用replace(’ ‘,’')来去掉字符串里的所有空格</li>
<li>split()：通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串</li>
<li>用正则匹配：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.sub 表示替换; \s 表示空白字符</span></span><br><span class="line"></span><br><span class="line">re.sub(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>) <span class="comment"># 把str中的空格全部清除</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trim</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 如果两端存在空格，则清除两端的空格，并返回结果 &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    <span class="keyword">if</span> s.startswith(<span class="string">&#x27; &#x27;</span>) <span class="keyword">or</span> s.endswith(<span class="string">&#x27; &#x27;</span>): <span class="comment"># 如果两端存在空格</span></span><br><span class="line">      <span class="keyword">return</span> re.sub(<span class="string">r&quot;^(\s+)|(\s+)$&quot;</span>, <span class="string">&quot;&quot;</span>, s) <span class="comment"># 仅清除两端的空格</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>使用递归：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trim</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> trim(s[<span class="number">1</span>:])   <span class="comment"># 如果开首有多个空格的话，递归去除多个空格</span></span><br><span class="line">    <span class="keyword">elif</span> s[-<span class="number">1</span>] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> trim(s[:-<span class="number">1</span>])  <span class="comment"># 如果末尾有多个空格的话，递归去除多个空格</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h4 id="8-获取字符串123456最后的两个字符"><a class="markdownIt-Anchor" href="#8-获取字符串123456最后的两个字符"></a> 8. 获取字符串&quot;123456&quot;最后的两个字符。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123456&quot;</span>[-<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
<h4 id="9-一个编码为-gbk-的字符串-s要将其转成-utf-8-编码的字符串应如何操作"><a class="markdownIt-Anchor" href="#9-一个编码为-gbk-的字符串-s要将其转成-utf-8-编码的字符串应如何操作"></a> 9. 一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;人生苦短，我用Python&quot;</span></span><br><span class="line">S = str1.encode(<span class="string">&#x27;GBK&#x27;</span>) <span class="comment"># 编码 GBK</span></span><br><span class="line">result = S.decode(<span class="string">&#x27;GBK&#x27;</span>).encode(<span class="string">&#x27;UTF-8&#x27;</span>) <span class="comment"># 解码 GBK 后，编码 UTF-8</span></span><br></pre></td></tr></table></figure>
<h4 id="10-正则切分字符串"><a class="markdownIt-Anchor" href="#10-正则切分字符串"></a> 10. 正则切分字符串</h4>
<p>s=“info：xiaoZhang 33 shandong”，用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">&quot;info：xiaoZhang 33 shandong&quot;</span></span><br><span class="line"><span class="comment"># compile 预编译正则表达式</span></span><br><span class="line"><span class="comment"># \W 匹配任何不是单词字符的字符</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\W&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pattern.split(s))</span><br><span class="line"><span class="comment"># 同下</span></span><br><span class="line">re.split(<span class="string">r&#x27;\W&#x27;</span>, s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="11-去除多余空格只留一个空格"><a class="markdownIt-Anchor" href="#11-去除多余空格只留一个空格"></a> 11. 去除多余空格只留一个空格</h4>
<p>a = &quot;你好 中国 &quot;，去除多余空格只留一个空格。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;你好 中国 &quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.rstrip()) <span class="comment"># rstrip 去除右边空格</span></span><br></pre></td></tr></table></figure>
<h4 id="12-怎样将字符串转换为小写"><a class="markdownIt-Anchor" href="#12-怎样将字符串转换为小写"></a> 12. 怎样将字符串转换为小写</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo_str = <span class="string">&quot;HELLO WORLD&quot;</span></span><br><span class="line">demo_str.lower() <span class="comment"># 转小写使用lower() 转大写使用upper()</span></span><br></pre></td></tr></table></figure>
<h4 id="13-单引号-双引号-三引号的区别"><a class="markdownIt-Anchor" href="#13-单引号-双引号-三引号的区别"></a> 13. 单引号、双引号、三引号的区别？</h4>
<p>单引号和双引号都可以用来表示一个字符串，区别不大，遇到需要转义字符的情况需要注意。<br />
三个单引号和三个双引号一般用于多行注释，也可以用来表示字符串：输出多行文本</p>
<h3 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h3>
<h4 id="1-已知-alist-12312对-alist-列表元素去重写出具体过程"><a class="markdownIt-Anchor" href="#1-已知-alist-12312对-alist-列表元素去重写出具体过程"></a> 1. 已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方法，使用set集合，先转为集合再转回列表</span></span><br><span class="line">result_list = <span class="built_in">list</span>(<span class="built_in">set</span>(AList))</span><br><span class="line"><span class="built_in">print</span>(result_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种，使用dict.fromkeys，该函数有两个参数，第一个是字典的键，第二个是对应值(默认为空str)，用于创建一个字典类型</span></span><br><span class="line">result_list = <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(AList))</span><br><span class="line"><span class="built_in">print</span>(result_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种，遍历列表进行判断</span></span><br><span class="line">result_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> AList:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> result_list:</span><br><span class="line">        result_list.append(i)</span><br><span class="line"><span class="built_in">print</span>(result_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四种，使用pandas.unique()方法，</span></span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">result_list = pandas.unique(AList).tolist()</span><br><span class="line"><span class="built_in">print</span>(result_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有一种不简单的简单行码</span></span><br><span class="line">[(this,this.append(i)) <span class="keyword">for</span> this <span class="keyword">in</span> ([],) <span class="keyword">for</span> i <span class="keyword">in</span> AList <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> this ][<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-如何实现-123-变成-123"><a class="markdownIt-Anchor" href="#2-如何实现-123-变成-123"></a> 2. 如何实现 “1,2,3” 变成 [“1”,“2”,“3”]</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo_str = <span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">result_list = demo_str.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result_list)</span><br></pre></td></tr></table></figure>
<h4 id="3-给定两个-lista-和-b找出相同元素和不同元素"><a class="markdownIt-Anchor" href="#3-给定两个-lista-和-b找出相同元素和不同元素"></a> 3. 给定两个 list，A 和 B，找出相同元素和不同元素</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找相同</span></span><br><span class="line">same_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> list_A <span class="keyword">if</span> i <span class="keyword">in</span> list_B]</span><br><span class="line"><span class="comment"># 找不同 在A不在B + 在B不在A</span></span><br><span class="line">different_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> list_A <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list_B] + [i <span class="keyword">for</span> i <span class="keyword">in</span> list_B <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list_A]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过集合</span></span><br><span class="line"><span class="comment"># # 找相同</span></span><br><span class="line"><span class="built_in">set</span>(list_A) &amp; <span class="built_in">set</span>(list_B)</span><br><span class="line"><span class="comment"># 找不同 对称差分是集合的XOR 又称&quot;异或&quot; 等价的方法：symmetric_difference()</span></span><br><span class="line"><span class="built_in">set</span>(list_A) ^ <span class="built_in">set</span>(list_B)</span><br></pre></td></tr></table></figure>
<h4 id="4-123456一行代码展开该列表得出123456"><a class="markdownIt-Anchor" href="#4-123456一行代码展开该列表得出123456"></a> 4. [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q_list = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">a_list = [ i <span class="keyword">for</span> item <span class="keyword">in</span> q_list <span class="keyword">for</span> i <span class="keyword">in</span> item]</span><br></pre></td></tr></table></figure>
<h4 id="5-合并列表1579和2268"><a class="markdownIt-Anchor" href="#5-合并列表1579和2268"></a> 5. 合并列表[1,5,7,9]和[2,2,6,8]</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">b_list = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方法：使用运算符“+”</span></span><br><span class="line">a_list = a_list + b_list</span><br><span class="line"><span class="built_in">print</span>(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方法：使用运算符extend()方法</span></span><br><span class="line">a_list.extend(b_list)</span><br><span class="line"><span class="built_in">print</span>(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种方法：使用append</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b_list:</span><br><span class="line">    a_list.append(i)</span><br><span class="line"><span class="built_in">print</span>(a_list)</span><br><span class="line">[ a_list.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> b_list]</span><br></pre></td></tr></table></figure>
<h4 id="6-如何打乱一个列表的元素"><a class="markdownIt-Anchor" href="#6-如何打乱一个列表的元素"></a> 6. 如何打乱一个列表的元素？</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">q_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用random.shuffle打乱一个list数组</span></span><br><span class="line">random.shuffle(q_list)</span><br><span class="line"><span class="built_in">print</span>(q_list)</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h3>
<h4 id="1-字典操作中-del-和-pop-有什么区别"><a class="markdownIt-Anchor" href="#1-字典操作中-del-和-pop-有什么区别"></a> 1. 字典操作中 del 和 pop 有什么区别</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">q_dic = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># pop方法删除指定的键值对，并返回删除的值</span></span><br><span class="line">pop_str = q_dic.pop(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q_dic,<span class="string">&#x27;\n&#x27;</span>,pop_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># del不会返回相应的值，只是将其删除</span></span><br><span class="line"><span class="keyword">del</span> q_dic[<span class="string">&quot;b&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(q_dic)</span><br></pre></td></tr></table></figure>
<h4 id="2-按照字典的内的年龄排序"><a class="markdownIt-Anchor" href="#2-按照字典的内的年龄排序"></a> 2. 按照字典的内的年龄排序</h4>
<p><img src="https://pic2.zhimg.com/80/v2-f0c87fcad0839af06187a4def1706f51_720w.jpg" alt="" /><br />
d1=[<br />
{‘name’:‘alice’,‘age’:38},<br />
{‘name’:‘bob’,‘age’:16},<br />
{‘name’:‘carl’,‘age’:18},</p>
<p>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d1=[</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">38</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bob&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;carl&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;,</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"><span class="comment"># 强大的sort方法，满足大多数排序算法，列表排序优先考虑sort！</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">list.sort( key=None, reverse=False)</span></span><br><span class="line"><span class="string">key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span></span><br><span class="line"><span class="string">reverse --排序规则，reverse = True降序，reverse = False升序（默认）。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">d1.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br></pre></td></tr></table></figure>
<h4 id="3-请合并下面两个字典-a-a1b2b-c3d4"><a class="markdownIt-Anchor" href="#3-请合并下面两个字典-a-a1b2b-c3d4"></a> 3. 请合并下面两个字典 a = {“A”:1,“B”:2},b = {“C”:3,“D”:4}</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;A&quot;</span>:<span class="number">1</span>,<span class="string">&quot;B&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;C&quot;</span>:<span class="number">3</span>,<span class="string">&quot;D&quot;</span>:<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典拆分 pyhton 3.5+</span></span><br><span class="line">d = &#123;**a, **b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用update方法</span></span><br><span class="line">a.update(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">d = &#123;k:v <span class="keyword">for</span> d <span class="keyword">in</span> [a, b] <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表拼接</span></span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">list</span>(a.items()) + <span class="built_in">list</span>(b.items())) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素并集</span></span><br><span class="line"><span class="comment"># items() 返回的是一个类似集合的对象，并不准确，集合是无序的，键重复时不能保证谁覆盖谁。</span></span><br><span class="line"><span class="comment"># 只适合字典中的值可以保证是唯一的可哈希的</span></span><br><span class="line">d = <span class="built_in">dict</span>(a.items() | b.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数</span></span><br><span class="line"><span class="comment"># 只适合字典的键是字符串时才有效</span></span><br><span class="line">d = <span class="built_in">dict</span>(a , **b) </span><br><span class="line"></span><br><span class="line"><span class="comment"># chain items</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">d = <span class="built_in">dict</span>(chain(a.items(), b.items()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ChainMap</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">d = <span class="built_in">dict</span>(ChainMap(a, b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-如何使用生成式的方式生成一个字典写一段功能代码"><a class="markdownIt-Anchor" href="#4-如何使用生成式的方式生成一个字典写一段功能代码"></a> 4. 如何使用生成式的方式生成一个字典，写一段功能代码。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">10</span>))&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-如何把元组ab和元组12变为字典a1b2"><a class="markdownIt-Anchor" href="#5-如何把元组ab和元组12变为字典a1b2"></a> 5. 如何把元组(“a”,“b”)和元组(1,2)，变为字典{“a”:1,“b”:2}</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple_key = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">tuple_val = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">result_dic = <span class="built_in">dict</span>(<span class="built_in">zip</span>(tuple_key,tuple_val))</span><br><span class="line"><span class="built_in">print</span>(result_dic)</span><br></pre></td></tr></table></figure>
<h3 id="综合"><a class="markdownIt-Anchor" href="#综合"></a> 综合</h3>
<h4 id="1-python-常用的数据结构的类型及其特性"><a class="markdownIt-Anchor" href="#1-python-常用的数据结构的类型及其特性"></a> 1. Python 常用的数据结构的类型及其特性？</h4>
<p><img src="https://pic4.zhimg.com/80/v2-3774e05a878688a01233e58eedd189a4_720w.jpg" alt="" /><br />
<a href="./#2-Python-%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><em>数据类型</em></a> 上文有提到</p>
<h4 id="2-如何交换字典-a1b2的键和值"><a class="markdownIt-Anchor" href="#2-如何交换字典-a1b2的键和值"></a> 2. 如何交换字典 {“A”：1,“B”：2}的键和值？</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo_dic = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1</span>, <span class="string">&quot;B&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典推导式交换位置</span></span><br><span class="line">result_dic = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> demo_dic.items()&#125;</span><br><span class="line"><span class="built_in">print</span>(result_dic)</span><br></pre></td></tr></table></figure>
<h4 id="3-python-里面如何实现-tuple-和-list-的转换"><a class="markdownIt-Anchor" href="#3-python-里面如何实现-tuple-和-list-的转换"></a> 3. Python 里面如何实现 tuple 和 list 的转换？</h4>
<p>强制类型转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span>(demo_list)</span><br><span class="line"><span class="built_in">list</span>(demo_tup)</span><br></pre></td></tr></table></figure>
<h4 id="4-我们知道对于列表可以使用切片操作进行部分元素的选择那么如何对生成器类型的对象实现相同的功能呢"><a class="markdownIt-Anchor" href="#4-我们知道对于列表可以使用切片操作进行部分元素的选择那么如何对生成器类型的对象实现相同的功能呢"></a> 4. 我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">gener = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">gener_clip = islice(gener, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gener_clip:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h4 id="5-请将i-for-i-in-range3改成生成器"><a class="markdownIt-Anchor" href="#5-请将i-for-i-in-range3改成生成器"></a> 5. 请将[i for i in range(3)]改成生成器</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))  <span class="comment"># 方括号改为圆括号即可</span></span><br></pre></td></tr></table></figure>
<h4 id="6-ahello和-b你好编码成-bytes-类型"><a class="markdownIt-Anchor" href="#6-ahello和-b你好编码成-bytes-类型"></a> 6. a=&quot;hello&quot;和 b=&quot;你好&quot;编码成 bytes 类型</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.encode()</span><br><span class="line">b.encode()</span><br></pre></td></tr></table></figure>
<h4 id="7-下面的代码输出结果是什么"><a class="markdownIt-Anchor" href="#7-下面的代码输出结果是什么"></a> 7. 下面的代码输出结果是什么？</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>)</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出: TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br><span class="line"><span class="comment"># 原因: 元祖是不可变类型，因此不能修改元祖内的值</span></span><br></pre></td></tr></table></figure>
<h4 id="8-下面的代码输出的结果是什么"><a class="markdownIt-Anchor" href="#8-下面的代码输出的结果是什么"></a> 8. 下面的代码输出的结果是什么?</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>)</span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment"># 输出: (1, 2, 3, [2, 5, 6, 7], 8)</span></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
<h4 id="9-python-交换两个变量的值"><a class="markdownIt-Anchor" href="#9-python-交换两个变量的值"></a> 9. Python 交换两个变量的值</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<h4 id="10-在读文件操作的时候会使用-read-readline-或者-readlines简述它们各自的作用"><a class="markdownIt-Anchor" href="#10-在读文件操作的时候会使用-read-readline-或者-readlines简述它们各自的作用"></a> 10. 在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用</h4>
<ul>
<li>read:读取整个文件。</li>
<li>readline：读取下一行，使用生成器方法。</li>
<li>readlines：读取整个文件到一个迭代器以供我们遍历</li>
</ul>
<h4 id="11-json-序列化时可以处理的数据类型有哪些如何定制支持-datetime-类型"><a class="markdownIt-Anchor" href="#11-json-序列化时可以处理的数据类型有哪些如何定制支持-datetime-类型"></a> 11. json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？</h4>
<ul>
<li>json序列化时，可以处理列表、字典、字符、数值、布尔和None</li>
<li>定制datetime类型↓</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> JSONEncoder</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatetimeEncoder</span>(<span class="title class_ inherited__">JSONEncoder</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;扩展JSONEncoder类中的default方法</span></span><br><span class="line"><span class="string">    判断传入的类型是否是datetime类型，如果是则转为str字符，否则不是返回父类的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default</span>(<span class="params">self, o</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(o, datetime):</span><br><span class="line">            <span class="keyword">return</span> o.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>(DatetimeEncoder, self).default(o)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dict_demo = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;alex&#x27;</span>, <span class="string">&#x27;data&#x27;</span>: datetime.now()&#125;</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(dict_demo, cls=DatetimeEncoder))</span><br></pre></td></tr></table></figure>
<h4 id="12-json-序列化时默认遇到中文会转换成-unicode如果想要保留中文怎么办"><a class="markdownIt-Anchor" href="#12-json-序列化时默认遇到中文会转换成-unicode如果想要保留中文怎么办"></a> 12. json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dict_demo = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;中文&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 使用dumps的默认参数ensure_ascii</span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(dict_demo, ensure_ascii=<span class="literal">False</span>).encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="13-有两个磁盘文件-a-和-b各存放一行字母要求把这两个文件中的信息合并按字母顺序排列输出到一个新文件-c-中"><a class="markdownIt-Anchor" href="#13-有两个磁盘文件-a-和-b各存放一行字母要求把这两个文件中的信息合并按字母顺序排列输出到一个新文件-c-中"></a> 13. 有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data_A = data_B =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 读文件A B，将AB内容合并</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(A, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> F:</span><br><span class="line">    data_A = F.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(B, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> F:</span><br><span class="line">    data_B = F.read()</span><br><span class="line">data = data_A + data_B</span><br><span class="line"><span class="comment"># 按字母顺序排列</span></span><br><span class="line">new_data = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(data))</span><br><span class="line"><span class="comment"># 输出到一个新文件 C </span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> F:</span><br><span class="line">    F.write(new_data) </span><br></pre></td></tr></table></figure>
<h4 id="14-如果当前的日期为-20210630要求写一个函数输出-n-天后的日期比如-n-为-2则输出-20210702"><a class="markdownIt-Anchor" href="#14-如果当前的日期为-20210630要求写一个函数输出-n-天后的日期比如-n-为-2则输出-20210702"></a> 14. 如果当前的日期为 20210630，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20210702)。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;20210630&#x27;</span></span><br><span class="line">N = <span class="number">2</span></span><br><span class="line">dt = datetime(<span class="built_in">int</span>(s[<span class="number">0</span>:<span class="number">4</span>]),<span class="built_in">int</span>(s[<span class="number">4</span>:<span class="number">6</span>]),<span class="built_in">int</span>(s[<span class="number">6</span>:<span class="number">8</span>]))</span><br><span class="line">dt = datetime.strptime(s, <span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">dt = dt + timedelta(days=N)</span><br><span class="line">dt.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="15-写一个函数接收整数参数-n返回一个函数函数的功能是把函数的参数和-n-相乘并把结果返回"><a class="markdownIt-Anchor" href="#15-写一个函数接收整数参数-n返回一个函数函数的功能是把函数的参数和-n-相乘并把结果返回"></a> 15. 写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。</h4>
<ul>
<li>闭包是一种特殊的函数，这种函数由多个函数的嵌套组成，且称之为外函数和内函数，外函数返回值是内函数的引用，此时就构成了闭包；</li>
<li>闭包函数必须返回一个函数对象；</li>
<li>闭包函数返回的那个函数必须引用外部变量；</li>
<li>闭包可以保存运行环境，即在闭包内的变量是不能被轻易修改的；</li>
<li>闭包的好处：提高代码的可复用性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">out_func</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_func</span>(<span class="params">num</span>):</span><br><span class="line">        <span class="keyword">return</span> n*num</span><br><span class="line">    <span class="keyword">return</span> in_func</span><br><span class="line"></span><br><span class="line">demo = out_func(<span class="number">3</span>)</span><br><span class="line">res = demo(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h4 id="16-下面代码会存在什么问题如何改进"><a class="markdownIt-Anchor" href="#16-下面代码会存在什么问题如何改进"></a> 16. 下面代码会存在什么问题，如何改进？</h4>
<p><img src="https://pic2.zhimg.com/80/v2-474f556cb8cd7d2ea7a47b0cba51c9cd_720w.jpg" alt="" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strappend</span>(<span class="params">num</span>):        <span class="comment"># 函数作用、参数意义不明，需要加注释</span></span><br><span class="line">    <span class="built_in">str</span>=<span class="string">&#x27;frist&#x27;</span>            <span class="comment"># 不能使用关键字&quot;str&quot;作为变量名</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):   <span class="comment"># 遍历得到的元素&quot;i&quot;意义不明，无注释</span></span><br><span class="line">        <span class="built_in">str</span>+=<span class="built_in">str</span>(i)        <span class="comment"># 变量名和关键字在这个时候重名，必定报错，没有了str()方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_append</span>(<span class="params">append_cound: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;字符串修改</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    遍历append_cound，将遍历的值转为str类型并添加到字符串中</span></span><br><span class="line"><span class="string">    :param append_cound: 遍历次数</span></span><br><span class="line"><span class="string">    :return: 最终修改得到的新字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    append_str = <span class="string">&quot;frist&quot;</span></span><br><span class="line">    <span class="comment"># 遍历获取到&quot;times&quot;次数int类型</span></span><br><span class="line">    <span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(append_cound):</span><br><span class="line">        append_str += <span class="built_in">str</span>(times)</span><br><span class="line">    <span class="keyword">return</span> append_str</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str_append(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="17-一行代码输出-1-100-之间的所有偶数"><a class="markdownIt-Anchor" href="#17-一行代码输出-1-100-之间的所有偶数"></a> 17. 一行代码输出 1-100 之间的所有偶数。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([ num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">101</span>) <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>([ num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">2</span>)])</span><br></pre></td></tr></table></figure>
<h4 id="18-with-语句的作用写一段代码"><a class="markdownIt-Anchor" href="#18-with-语句的作用写一段代码"></a> 18. with 语句的作用，写一段代码？</h4>
<p><a href="./#3-%E7%AE%80%E8%BF%B0-with-%E6%96%B9%E6%B3%95%E6%89%93%E5%BC%80%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%B8%AE%E6%88%91%E6%88%91%E4%BB%AC%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><em>with 语句</em></a>上文有提到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 来一个用于线程锁的with使用</span></span><br><span class="line">num = <span class="number">0</span>  <span class="comment"># 全局变量多个线程可以读写，传递数据</span></span><br><span class="line">thread_lock = threading.Lock()  <span class="comment"># 创建一个锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">with</span> thread_lock:               <span class="comment"># with Lock的作用相当于自动获取和释放锁(资源)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):    <span class="comment"># 锁定期间，其他线程不可以运行</span></span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>
<h4 id="19-python-字典和-json-字符串相互转化方法"><a class="markdownIt-Anchor" href="#19-python-字典和-json-字符串相互转化方法"></a> 19. python 字典和 json 字符串相互转化方法</h4>
<p>json.dumps 用于将 Python 对象编码成 JSON 字符串。</p>
<pre><code>json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)
</code></pre>
<p>json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。</p>
<pre><code>json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dict_demo = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化：使用json.dumps()将python类型转为json字符串</span></span><br><span class="line">json_demo = json.dumps(dict_demo)</span><br><span class="line"><span class="built_in">print</span>(json_demo)</span><br><span class="line"><span class="comment"># 输出：&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 使用其他参数</span></span><br><span class="line">json_demo = json.dumps(dict_demo,sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;: &#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(json_demo)</span><br><span class="line"><span class="string">&quot;&quot;&quot;输出：</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;a&quot;: 1,</span></span><br><span class="line"><span class="string">    &quot;b&quot;: 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化：json.loads 用于解码 JSON 数据</span></span><br><span class="line">dict_demo = json.loads(json_demo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="20-请写一个-python-逻辑计算一个文件中的大写字母数量"><a class="markdownIt-Anchor" href="#20-请写一个-python-逻辑计算一个文件中的大写字母数量"></a> 20. 请写一个 Python 逻辑，计算一个文件中的大写字母数量</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">captial_count</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算文件中的大写字母数量</span></span><br><span class="line"><span class="string">    读取文件并计算文件数据的大写字母数量，返回大写字母数量</span></span><br><span class="line"><span class="string">    :param file_name: 文件名</span></span><br><span class="line"><span class="string">    :return: 文件中的大写字母数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_data = f.read()</span><br><span class="line">    <span class="comment"># 删除掉除大写字母之外的所有字符</span></span><br><span class="line">    file_data = re.sub(<span class="string">&quot;[^A-Z]&quot;</span>, <span class="string">&quot;&quot;</span>, file_data)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(file_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(capital_count(<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="21-请写一段-python连接-mongo-数据库然后的查询代码"><a class="markdownIt-Anchor" href="#21-请写一段-python连接-mongo-数据库然后的查询代码"></a> 21. 请写一段 Python连接 Mongo 数据库，然后的查询代码。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接本地数据库</span></span><br><span class="line">db_client = MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 testdb 测试数据库</span></span><br><span class="line">test_db = db_client[<span class="string">&quot;testdb&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 sites 文档</span></span><br><span class="line">sites_obj = test_db[<span class="string">&quot;sites&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># find_one() 方法来查询集合中的一条数据</span></span><br><span class="line">first_data = sites_obj.find_one()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(first_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="22-说一说-redis-的基本类型"><a class="markdownIt-Anchor" href="#22-说一说-redis-的基本类型"></a> 22. 说一说 Redis 的基本类型。</h4>
<p>string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<h4 id="23-请写一段-python连接-redis-数据库的代码"><a class="markdownIt-Anchor" href="#23-请写一段-python连接-redis-数据库的代码"></a> 23. 请写一段 Python连接 Redis 数据库的代码。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connec_obj = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个键值</span></span><br><span class="line">connec_obj.<span class="built_in">set</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一个键值</span></span><br><span class="line">connec_obj.get(<span class="string">&#x27;test&#x27;</span>)   <span class="comment"># -&gt;&gt; &#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="24-请写一段-python-连接-mysql-数据库的代码"><a class="markdownIt-Anchor" href="#24-请写一段-python-连接-mysql-数据库的代码"></a> 24. 请写一段 Python 连接 MySQL 数据库的代码。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="comment"># 打开数据库连接</span></span><br><span class="line">db = pymysql.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;testuser&quot;</span>, <span class="string">&quot;test123&quot;</span>, <span class="string">&quot;TESTDB&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用execute方法执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fetchone() 方法获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<h4 id="25-了解-redis-的事务么"><a class="markdownIt-Anchor" href="#25-了解-redis-的事务么"></a> 25. 了解 Redis 的事务么？</h4>
<ul>
<li>Redis 事务可以一次执行多个命令，即将多个命令打包，一次性提交并按顺序执行</li>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>Redis 事务的执行并不是原子性的：在事务执行过程，其他命令不会插入到事务执行命令序列中，中间某条指令的失败不会导致中断也不会导致回滚</li>
<li>事务提供了一种&quot;将多个命令打包，一次性提交并按顺序执行&quot;的机制，提交后在事务执行中不会中断。只有在执行完所有命令后才会继续执行来自其他客户的消息。</li>
</ul>
<blockquote>
<p>Redis通过multi，exec，discard，watch实现事务功能。</p>
<ol>
<li>multi：开始事务</li>
<li>exec：提交事务并执行</li>
<li>discard：取消事务</li>
<li>watch：事务开始之前监视任意数量的键</li>
<li>unwatch：取消WATCH命令对多有key的监控，所有监控锁将会被取消。<br />
关于ACID：</li>
<li>单独的隔离操作：事务中的所有命令会被序列化、按顺序执行，在执行的过程中不会被其他客户端发送来的命令打断</li>
<li>没有隔离级别的概念：队列中的命令在事务没有被提交之前不会被实际执行</li>
<li>不保证原子性：redis中的一个事务中如果存在命令执行失败，那么其他命令依然会被执行，没有回滚机制。</li>
</ol>
</blockquote>
<h4 id="26-了解数据库的三范式么"><a class="markdownIt-Anchor" href="#26-了解数据库的三范式么"></a> 26. 了解数据库的三范式么？</h4>
<ul>
<li>1NF：字段不可分割，每个字段是原子级别</li>
<li>2NF：有主键，非主键字段依赖主键</li>
<li>3NF：非主键字段不能相互依赖，即消除传递依赖</li>
<li>BCNF：非主键字段不能对主键的子集依赖，即消除了对主码子集的依赖</li>
<li>4NF：</li>
</ul>
<blockquote>
<p>多值依赖的概念:<br />
多值依赖即属性之间的一对多关系，记为K→→A。<br />
函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。<br />
平凡的多值依赖：全集U=K+A，一个K可以对应于多个A，即K→→A。此时整个表就是一组一对多关系。<br />
非平凡的多值依赖：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B互相独立，即K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。<br />
第四范式即在满足巴斯-科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表内的多对多关系删除）。</p>
</blockquote>
<ul>
<li>5NF：</li>
</ul>
<blockquote>
<p>即在满足第四范式（4NF）的基础上，消除不是由候选码所蕴含的连接依赖。如果关系模式R中的每一个连接依赖均由R的候选码所隐含，则称此关系模式符合第五范式。<br />
函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p>
</blockquote>
<h4 id="27-了解分布式锁么"><a class="markdownIt-Anchor" href="#27-了解分布式锁么"></a> 27. 了解分布式锁么？</h4>
<p>多线程和多进程在抢占同一资源时可能会导致数据不一致，为了保证线程或者进程安全，引入线程锁和进程锁，保证了数据的一致性和完整性。同样的，在分布式系统中对共享资源进行操作时，使用分布式锁来解决这一问题。<br />
分布式锁的实现有很多种，常见的有redis、zookeeper和数据库mysql等。<br />
<a href="https://www.jianshu.com/p/a1ebab8ce78a">详解</a></p>
<h4 id="28-用-python-实现一个-reids-的分布式锁的功能"><a class="markdownIt-Anchor" href="#28-用-python-实现一个-reids-的分布式锁的功能"></a> 28. 用 Python 实现一个 Reids 的分布式锁的功能。</h4>
<p>引自：<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/junli_chen/article/details/79228282">junli_chen</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisLock</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 连接数据库，创建连接对象</span></span><br><span class="line">        self.rdcon = redis.Redis(host=<span class="string">&#x27;&#x27;</span>, port=<span class="number">6379</span>, password=<span class="string">&quot;&quot;</span>, db=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 设置锁的值</span></span><br><span class="line">        self._lock = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 分布式锁的键</span></span><br><span class="line">        self.lock_key = <span class="string">&quot;%s_dynamic_test&quot;</span> % key</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_lock</span>(<span class="params">cls, timeout=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取redis分布式锁</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        设置分布式锁，判断锁是否超时</span></span><br><span class="line"><span class="string">        :param cls: 锁的类对象</span></span><br><span class="line"><span class="string">        :param timeout: 锁超时时间</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> cls._lock != <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 设置锁的过期时间</span></span><br><span class="line">            timestamp = time.time() + timeout + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 设置redis分布式锁键值</span></span><br><span class="line">            cls._lock = cls.rdcon.setnx(cls.lock_key, timestamp)</span><br><span class="line">            <span class="comment"># 判断锁的值是否为1，或者当前时间大于锁预期释放的时间，如果成立则退出循环，释放锁</span></span><br><span class="line">            <span class="keyword">if</span> cls._lock == <span class="number">1</span> <span class="keyword">or</span> (</span><br><span class="line">                    time.time() &gt; cls.rdcon.get(cls.lock_key) <span class="keyword">and</span></span><br><span class="line">                    time.time() &gt; cls.rdcon.getset(cls.lock_key, timestamp)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;get lock&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time.sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;释放锁</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param cls: 锁的类对象</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判断当前时间是否大于锁最大释放时间</span></span><br><span class="line">        <span class="keyword">if</span> time.time() &lt; cls.rdcon.get(cls.lock_key):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;release lock&quot;</span>)</span><br><span class="line">            cls.rdcon.delete(cls.lock_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;分布式锁装饰器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param cls: 分布式锁类对象</span></span><br><span class="line"><span class="string">    :return: 外层函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_deco</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__deco</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;before %s called [%s].&quot;</span> % (func.__name__, cls))</span><br><span class="line">            cls.get_lock(cls)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                cls.release(cls)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> __deco</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco(<span class="params">RedisLock(<span class="params"><span class="string">&quot;demoLock&quot;</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;myfunc() called.&quot;</span>)</span><br><span class="line">    <span class="comment"># 设置20s模拟超过锁释放时间就自动释放锁的操作</span></span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    myfunc()</span><br></pre></td></tr></table></figure>
<h4 id="29-写一段-python-使用-mongo-数据库创建索引的代码"><a class="markdownIt-Anchor" href="#29-写一段-python-使用-mongo-数据库创建索引的代码"></a> 29. 写一段 Python 使用 Mongo 数据库创建索引的代码。</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> ASCENDING, DESCENDING</span><br><span class="line"><span class="comment"># 连接数据库，创建连接对象</span></span><br><span class="line">myclient = pymongo.MongoClient(mongodbUrl)</span><br><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">mydb = myclient[dbName]</span><br><span class="line"><span class="comment"># 创建索引，create_index()创建索引，可以有多个约束条件，值为1则升序，-1是降序</span></span><br><span class="line">mydb.create_index([(<span class="string">&quot;date&quot;</span>, DESCENDING), (<span class="string">&quot;author&quot;</span>, ASCENDING)])</span><br></pre></td></tr></table></figure>
<h2 id="高级特性"><a class="markdownIt-Anchor" href="#高级特性"></a> 高级特性</h2>
<h3 id="1-函数装饰器有什么作用请列举说明"><a class="markdownIt-Anchor" href="#1-函数装饰器有什么作用请列举说明"></a> 1. 函数装饰器有什么作用？请列举说明？</h3>
<p>装饰器主要是在不修改代码前提下进行功能的扩展，满足面向对象的“开闭原则”。</p>
<blockquote>
<p>应用场景：</p>
</blockquote>
<ol>
<li>引入日志</li>
<li>函数执行时间统计</li>
<li>执行函数前预备处理</li>
<li>执行函数后清理功能</li>
<li>权限校验等场景</li>
<li>缓存</li>
<li>事务处理</li>
</ol>
<h3 id="2-python-垃圾回收机制"><a class="markdownIt-Anchor" href="#2-python-垃圾回收机制"></a> 2. Python 垃圾回收机制？</h3>
<p>引用计数为主，标记清除和分代回收为辅：</p>
<h4 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h4>
<ul>
<li>小整数：Python 对小整数的定义是 [-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象。单个字母同样也是如此。</li>
<li>大整数：每一个大整数的创建均在内存中会分配一个内存空间，所以大整数的内存空间是需要被回收的。</li>
</ul>
<h4 id="引用计数"><a class="markdownIt-Anchor" href="#引用计数"></a> 引用计数：</h4>
<p>python里每一个东西都是对象，它们的核心就是一个结构体：<code>PyObject</code><br />
<code>PyObject</code>是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少当引用计数为0时，该对象生命就结束了。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单</td>
<td>维护引用计数消耗资源</td>
</tr>
<tr>
<td>实时性*</td>
<td>循环引用</td>
</tr>
</tbody>
</table>
<ul>
<li>*实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li>
</ul>
<h3 id="3-魔法函数-__call__-怎么使用"><a class="markdownIt-Anchor" href="#3-魔法函数-__call__-怎么使用"></a> 3. 魔法函数 <code>__call__</code> 怎么使用?</h3>
<blockquote>
<p><code>__call__</code>允许一个类的实例像函数一样被调用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, x, y</span>):</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="comment"># 改变实例属性</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建实例</span></span><br><span class="line">    demo_obj = Entity(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 实例可以像函数那样执行，并传入x y值，修改对象的x y</span></span><br><span class="line">    demo_obj(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-如何判断一个对象是函数还是方法"><a class="markdownIt-Anchor" href="#4-如何判断一个对象是函数还是方法"></a> 4. 如何判断一个对象是函数还是方法？</h3>
<ul>
<li>使用<code>isinstance()</code>判断</li>
<li>声明def
<ul>
<li>类外声明def为函数</li>
<li>类中声明def：
<ul>
<li>使用类调用的为函数</li>
<li>使用实例化对象调用的为方法</li>
</ul>
</li>
</ul>
</li>
<li>摘自<a href="https://www.cnblogs.com/mayugang/p/9977914.html">马玉刚的博客</a>
<ol>
<li>从分类的角度</li>
</ol>
<ul>
<li>函数的分类：
<ul>
<li>内置函数</li>
<li>匿名函数</li>
<li>递归函数</li>
<li>自定义函数</li>
</ul>
</li>
<li>方法的分类
<ul>
<li>普通方法：直接用self调用的方法。</li>
<li>私有方法：__函数名，只能在类中被调用的方法。</li>
<li>属性方法：@property，将方法伪装成为属性，让代码看起来更合理。</li>
<li>特殊方法(双下划线方法)：以<code>__init__</code>为例，是用来封装实例化对象的属性，只要是实例化对象就一定会执行<code>__init__</code>方法，如果对象子类中没有则会寻找父类（超类），如果父类（超类）也没有，则直接继承object（python 3.x）类，执行类中的<code>__init__</code>方法。</li>
<li>类方法：通过类名的调用去操作公共模板中的属性和方法。</li>
<li>静态方法：不用传入类空间、对象的方法， 作用是保证代码的一致性，规范性，可以完全独立类外的一个方法，但是为了代码的一致性统一的放到某个模块（py文件）中。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>从作用域的角度</li>
</ol>
<ul>
<li>函数作用域：从函数调用开始至函数执行完成，返回给调用者后，在执行过程中开辟的空间会自动释放，也就是说函数执行完成后，函数体内部通过赋值等方式修改变量的值不会保留，会随着返回给调用者后，开辟的空间会自动释放。</li>
<li>方法作用域：通过实例化的对象进行方法的调用，调用后开辟的空间不会释放，也就是说调用方法中对变量的修改值会一直保留。</li>
</ul>
<ol start="3">
<li>从调用的方式</li>
</ol>
<ul>
<li>函数：通过<code>类.函数名()</code>的方式进行调用</li>
<li>方法：通过<code>实例化对象.方法名()</code>的方式进行调用。</li>
</ul>
</li>
</ul>
<h3 id="5-classmethod-和staticmethod-用法和区别"><a class="markdownIt-Anchor" href="#5-classmethod-和staticmethod-用法和区别"></a> 5. @classmethod 和@staticmethod 用法和区别</h3>
<ul>
<li>@classmethod 是类方法：访问和修改类属性，进行类相关的操作，通过类或示例对象调用，需要传递cls类对象为参数；</li>
<li>@staticmethod 是静态方法：不访问类属性和实例属性，通过类或实例调用，相当于一个普通函数。</li>
</ul>
<h3 id="6-python-中的接口如何实现"><a class="markdownIt-Anchor" href="#6-python-中的接口如何实现"></a> 6. Python 中的接口如何实现？</h3>
<p>摘自终结大笨狗的博客<a href="https://blog.csdn.net/qq_21033779/article/details/79071887">#python中接口实现#</a></p>
<ol>
<li>用抽象类和抽象函数实现接口</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#抽象类加抽象方法就等于面向对象编程中的接口</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">interface</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = ABCMeta <span class="comment">#指定这是一个抽象类</span></span><br><span class="line"><span class="meta">    @abstractmethod  </span><span class="comment">#抽象方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Lee</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Marlon</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RelalizeInterfaceLee</span>(<span class="title class_ inherited__">interface</span>):<span class="comment">#必须实现interface中的所有函数，否则会编译错误</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):    </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;这是接口interface的实现&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Lee</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;实现Lee功能&#x27;</span>        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Marlon</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>   </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RelalizeInterfaceMarlon</span>(<span class="title class_ inherited__">interface</span>): <span class="comment">#必须实现interface中的所有函数，否则会编译错误</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):    </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;这是接口interface的实现&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Lee</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Marlon</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;实现Marlon功能&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用普通类定义接口</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interface</span>(<span class="title class_ inherited__">object</span>): <span class="comment">#假设这就是一个接口，接口名可以随意定义，所有的子类不需要实现在这个类中的函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Lee</span>(<span class="params">self</span>):，</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Marlon</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realaize_interface</span>(<span class="title class_ inherited__">interface</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Lee</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;实现接口中的Lee函数&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realaize_interface2</span>(<span class="title class_ inherited__">interface</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Marlon</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;实现接口中的Marlon函数&quot;</span></span><br><span class="line"></span><br><span class="line">obj=Realaize_interface()</span><br><span class="line">obj.Lee()</span><br><span class="line"></span><br><span class="line">obj=Realaize_interface2()</span><br><span class="line">obj.Marlon()</span><br></pre></td></tr></table></figure>
<h3 id="7-python-中的反射了解么"><a class="markdownIt-Anchor" href="#7-python-中的反射了解么"></a> 7. Python 中的反射了解么?</h3>
<blockquote>
<p>计算机中的反射，是在运行的时候来自我检查，并对内部成员进行操作。就是说这个变量的类型可以动态的改变，在运行的时候确定它的作用。</p>
</blockquote>
<p>反射是指程序可以访问。检测和修改它本身状态或行为的一种能力（自省）。<br />
在Python中，能够通过一个对象，找出其<code>type</code>、<code>class</code>、<code>attribute</code>或<code>method</code>的能力，称为反射或自省。<br />
具有反射能力的函数有<code>type()</code>，<code>isinstance()</code>，<code>callable()</code>，<code>dir()</code>，<code>getattr()</code>，<code>hasattr()</code>，<code>setattr()</code>，<code>delattr()</code>，<code>__import__()</code>等。</p>
<p>反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！</p>
<h3 id="8-metaclass-作用以及应用场景重难点"><a class="markdownIt-Anchor" href="#8-metaclass-作用以及应用场景重难点"></a> 8. metaclass 作用？以及应用场景？[重难点]</h3>
<p><code>metaclass</code> 元类是Python中非常具有魔术性的对象，可以动态的定制或修改继承它的子类。由于太过于灵活，改日另起一篇。<br />
三个重点：<code>__new__</code>,<code>__init__</code>,<code>__call__</code>.</p>
<p>扩展链接:</p>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072#0">廖雪峰-使用元类</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, bases, dic</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, bases, dic)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===&gt;Mymeta.__init__&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.__name__)</span><br><span class="line">        <span class="built_in">print</span>(dic)</span><br><span class="line">        <span class="built_in">print</span>(self.yaml_tag)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===&gt;Mymeta.__new__&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cls.__name__)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===&gt;Mymeta.__call__&#x27;</span>)</span><br><span class="line">        obj = cls.__new__(cls)</span><br><span class="line">        cls.__init__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(metaclass=Mymeta):</span><br><span class="line">    yaml_tag = <span class="string">&#x27;!Foo&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Foo.__init__&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Foo.__new__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">===&gt;Mymeta.__new__</span></span><br><span class="line"><span class="string">Mymeta</span></span><br><span class="line"><span class="string">===&gt;Mymeta.__init__</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;Foo&#x27;, &#x27;yaml_tag&#x27;: &#x27;!Foo&#x27;, &#x27;__init__&#x27;: &lt;function Foo.__init__ at 0x0000000007EF3828&gt;, &#x27;__new__&#x27;: &lt;function Foo.__new__ at 0x0000000007EF3558&gt;&#125;</span></span><br><span class="line"><span class="string">!Foo</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">===&gt;Mymeta.__call__</span></span><br><span class="line"><span class="string">Foo.__new__</span></span><br><span class="line"><span class="string">Foo.__init__</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>正常情况下我们在父类中是不能对子类的属性进行操作，但是元类可以。换种方式理解：元类、装饰器、类装饰器都可以归为元编程。</p>
<h3 id="9-hasattr-getattr-setattr的用法"><a class="markdownIt-Anchor" href="#9-hasattr-getattr-setattr的用法"></a> 9. hasattr() getattr() setattr()的用法</h3>
<p>这三种方法用于为对象属性的存在判断、获取和添加修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    name = <span class="string">&#x27;python&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A()类的方法func()&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(A, <span class="string">&#x27;name&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(A, <span class="string">&#x27;func&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(A, <span class="string">&#x27;age&#x27;</span>))   <span class="comment"># False</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(A, <span class="string">&#x27;name&#x27;</span>))  <span class="comment"># &#x27;python&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(A, <span class="string">&#x27;func&#x27;</span>))  <span class="comment"># &lt;function A.func at 0x000XXX&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(A(),<span class="string">&#x27;func&#x27;</span>)) <span class="comment"># &#x27;A()类的方法func()&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(A,<span class="string">&#x27;age&#x27;</span>))    <span class="comment"># AttributeError</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setattr</span>(A, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;java&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(A, <span class="string">&#x27;name&#x27;</span>))  <span class="comment"># &#x27;java&#x27;</span></span><br><span class="line">    <span class="built_in">setattr</span>(A, <span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(A, <span class="string">&quot;age&quot;</span>))    <span class="comment"># 20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-请列举你知道的-python-的魔法方法及用途"><a class="markdownIt-Anchor" href="#10-请列举你知道的-python-的魔法方法及用途"></a> 10. 请列举你知道的 Python 的魔法方法及用途。</h3>
<blockquote>
<p>魔法方法，即dunder method，是以&quot;__&quot;包起来的方法。</p>
</blockquote>
<ul>
<li><code>__new__</code>：是用来创建类并返回这个类的实例,</li>
<li><code>__init__</code>：将传入的参数来初始化该实例，以及初始化示例属性，与<code>__new__</code>共同构成了“构造函数”</li>
<li><code>__del__</code>：将实例化后的对象销毁，即为析构函数</li>
<li><code>__call__</code>：允许一个类像函数一样被调用</li>
<li><code>__getattr__</code>：访问对象不存在的属性时，调用该方法，用于定义访问行为</li>
<li><code>__setattr__</code>：设置对象属性时调用</li>
<li><code>__delattr__</code>：删除对象属性时调用</li>
<li><code>__enter__</code>和<code>__exit__</code>： 上下文管理器</li>
<li><code>__iter__</code>：返回一个容器迭代器，很多情况下会返回迭代器，尤其是当内置的<code>iter()</code>方法被调用的时候，以及当使用<code>for x in container:</code>方式循环的时候。迭代器是它们本身的对象，它们必须定义返回self的<code>__iter__</code>方法。</li>
<li><code>__next__</code>：返回迭代器的下一个元素</li>
</ul>
<h3 id="11-如何知道一个-python-对象的类型"><a class="markdownIt-Anchor" href="#11-如何知道一个-python-对象的类型"></a> 11. 如何知道一个 Python 对象的类型？</h3>
<p>用<code>type()</code>判断对象类型</p>
<h3 id="12-python-的传参是传值还是传址"><a class="markdownIt-Anchor" href="#12-python-的传参是传值还是传址"></a> 12. Python 的传参是传值还是传址？</h3>
<p>结论先行：Python 对可变对象（字典或列表）传址，对不可变对象（数字、字符或元祖）传值。</p>
<h3 id="13-python-中的元类metaclass使用举例"><a class="markdownIt-Anchor" href="#13-python-中的元类metaclass使用举例"></a> 13. Python 中的元类(metaclass)使用举例</h3>
<p><a href="./#8-metaclass-%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-%E9%87%8D%E9%9A%BE%E7%82%B9"><em>metaclass</em></a>上文有提到</p>
<h3 id="14-简述-any和-all方法"><a class="markdownIt-Anchor" href="#14-简述-any和-all方法"></a> 14. 简述 any()和 all()方法</h3>
<p><code>any()</code>判断 一个可迭代对象 存在不为空的元素，返回True；空列表和空元祖为False；<br />
<code>all()</code>判断 一个可迭代对象 全部的元素不为空，返回True；空列表和空元祖为True。</p>
<h3 id="15-filter-方法求出列表所有奇数并构造新列表a-1-2-3-4-5-6-7-8-9-10"><a class="markdownIt-Anchor" href="#15-filter-方法求出列表所有奇数并构造新列表a-1-2-3-4-5-6-7-8-9-10"></a> 15. filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</h3>
<p>a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br />
list(filter(lambda x: x % 2 == 1, a))</p>
<h3 id="16-什么是猴子补丁"><a class="markdownIt-Anchor" href="#16-什么是猴子补丁"></a> 16. 什么是猴子补丁？</h3>
<p>猴子补丁的含义是指在动态语言中，不去改变源码而对功能进行追加和变更。<br />
举个栗子:</p>
<blockquote>
<p>之前做的一个游戏服务器,很多地方用的import json,后来发现ujson比自带json快了N倍,于是问题来了,难道几十个文件要一个个把import json改成import ujson as json吗?<br />
其实只需要在进程startup的地方monkey patch就行了.是影响整个进程空间的.<br />
同一进程空间中一个module只会被运行一次.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> ujson</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monkey_patch_json</span>():</span><br><span class="line">    json.__name__ = <span class="string">&#x27;ujson&#x27;</span></span><br><span class="line">    json.dumps = ujson.dumps</span><br><span class="line">    json.loads = ujson.loads</span><br><span class="line"></span><br><span class="line">monkey_patch_json()</span><br></pre></td></tr></table></figure>
<h3 id="17-在-python-中是如何管理内存的"><a class="markdownIt-Anchor" href="#17-在-python-中是如何管理内存的"></a> 17. 在 Python 中是如何管理内存的？</h3>
<p><strong>Python内存池</strong>：内存池的概念就是预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br />
<strong>python中的内存管理机制——Pymalloc</strong>：python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new/malloc的行为来申请内存空间。</p>
<p><strong>内存释放</strong>: 参考<a href="./#2-Python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><em>垃圾回收</em></a></p>
<h3 id="18-当退出-python-时是否释放所有内存分配"><a class="markdownIt-Anchor" href="#18-当退出-python-时是否释放所有内存分配"></a> 18. 当退出 Python 时是否释放所有内存分配？</h3>
<p>那些具有对象循环引用或者全局命名空间引用的变量，在 Python 退出是往往不会被释放。另外不会释放 C 库保留的部分内容。</p>
<h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h2>
<p><a href="https://regexper.com">正则表达式可视化</a><br />
<a href="https://regexr.com/">对正则表达式进行解释</a></p>
<h3 id="1-使用正则表达式匹配出中的地址-a张明-98-分用-resub将-98-替换为-100"><a class="markdownIt-Anchor" href="#1-使用正则表达式匹配出中的地址-a张明-98-分用-resub将-98-替换为-100"></a> 1. 使用正则表达式匹配出中的地址 a=“张明 98 分”，用 re.sub，将 98 替换为 100</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">html_str = <span class="string">&#x27;&lt;html&gt;&lt;h1&gt;&lt;div&gt;a=&quot;张明 98 分&quot;&lt;/div&gt;&lt;/html&gt;&#x27;</span></span><br><span class="line">result_str = re.sub(<span class="string">r&#x27;\d&#123;2&#125;&#x27;</span>, <span class="string">&quot;100&quot;</span>, html_str)</span><br><span class="line"><span class="built_in">print</span>(result_str)</span><br></pre></td></tr></table></figure>
<h3 id="2-正则表达式匹配中和匹配区别"><a class="markdownIt-Anchor" href="#2-正则表达式匹配中和匹配区别"></a> 2. 正则表达式匹配中<code>(.*)</code>和<code>(.*?)</code>匹配区别？</h3>
<ul>
<li>贪婪匹配在匹配字符串时总是尝试匹配尽可能多的字符</li>
<li>非贪婪匹配在匹配字符串时总是尝试匹配尽可能少的字符。</li>
<li>Python里数量词默认是贪婪模式的，在&quot;*“,”?“,”+“,”{m,n}&quot;后面加上？，可使贪婪模式变成非贪婪模式。</li>
</ul>
<h3 id="3-写一段匹配邮箱的正则表达式"><a class="markdownIt-Anchor" href="#3-写一段匹配邮箱的正则表达式"></a> 3. 写一段匹配邮箱的正则表达式</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str1 = <span class="string">&#x27;fdg.123@163.cn  hdfh.abc@qq.com  hidfsd@qq.com gfgfa@qq.net  bdfdg@163.com&#x27;</span></span><br><span class="line">reg_str1 = <span class="string">r&#x27;([\w]+(\.[\w]+)*@[\w]+(\.[\w]+)+)&#x27;</span></span><br><span class="line">mod = re.<span class="built_in">compile</span>(reg_str1)</span><br><span class="line"></span><br><span class="line">items = mod.findall(str1)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其他内容"><a class="markdownIt-Anchor" href="#其他内容"></a> 其他内容</h2>
<h3 id="1-解释一下-python-中-pass-语句的作用"><a class="markdownIt-Anchor" href="#1-解释一下-python-中-pass-语句的作用"></a> 1. 解释一下 python 中 pass 语句的作用？</h3>
<p>空语句，是为了保持程序结构的完整性；<br />
pass不做任何事情，一般用做占位语句；<br />
一般在搭建程序框架的时候或在判断语句中使用。</p>
<h3 id="2-简述你对-input函数的理解"><a class="markdownIt-Anchor" href="#2-简述你对-input函数的理解"></a> 2. 简述你对 input()函数的理解</h3>
<ul>
<li>Python3.x: <code>input()</code>函数接受一个标准输入数据，返回为字符串类型</li>
<li>Python2.x: <code>input()</code> 需要输入 python 表达式。比如程序中有语句<code>a = input(&quot;input:&quot;)</code>，当输入 <code>runoob</code>会报错，此时 runoob 解释成一个变量，而<code>&quot;runoob&quot;</code>不会报错。</li>
<li>Python2.x: <code>raw_input()</code> 将所有输入作为字符串看待</li>
</ul>
<h3 id="3-python-中的-is-和"><a class="markdownIt-Anchor" href="#3-python-中的-is-和"></a> 3. python 中的 is 和==</h3>
<p>is 是身份运算符，判断两个对象的内存id是否相等<br />
== 是比较运算符，判断两个对象的值是否相等<br />
进行值比较的时候使用==，判断是否是同一对象的时候使用is</p>
<h3 id="4-python-中的作用域"><a class="markdownIt-Anchor" href="#4-python-中的作用域"></a> 4. Python 中的作用域</h3>
<p>L （Local） 局部作用域<br />
E （Enclosing） 闭包函数外的函数中<br />
G （Global） 全局作用域<br />
B （Built-in） 内建作用域<br />
以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p>
<h3 id="5-三元运算写法和应用场景"><a class="markdownIt-Anchor" href="#5-三元运算写法和应用场景"></a> 5. 三元运算写法和应用场景？</h3>
<p>三元运算符就是在赋值变量的时候，可以直接加判断，然后赋值格式<br />
条件为真时的结果 if 判段的条件 else 条件为假时的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先定义变量：</span></span><br><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一种写法：</span></span><br><span class="line">erroStr = <span class="string">&quot;More&quot;</span> <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> <span class="string">&quot;Less&quot;</span></span><br><span class="line"><span class="built_in">print</span>(erroStr) <span class="comment"># 运行结果为：Less</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种写法：</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="literal">True</span>: <span class="string">&quot;More&quot;</span>, <span class="literal">False</span>: <span class="string">&quot;Less&quot;</span>&#125;[a &gt; b]) <span class="comment"># 运行结果为：Less</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三种写法：</span></span><br><span class="line"><span class="built_in">print</span>((<span class="string">&quot;FalseValue&quot;</span>, <span class="string">&quot;TrueValue&quot;</span>)[a &gt; b]) <span class="comment"># 运行结果为：FalseValue</span></span><br></pre></td></tr></table></figure>
<p>其中我们比较常见的是第一种。<br />
第二三种是挺简洁的，但是写在项目里怕是接手的同事要抓狂了。</p>
<h3 id="6-了解-enumerate-么"><a class="markdownIt-Anchor" href="#6-了解-enumerate-么"></a> 6. 了解 enumerate 么？</h3>
<blockquote>
<p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>
</blockquote>
<p>语法:</p>
<pre><code>enumerate(sequence, [start=0])
</code></pre>
<h3 id="7-列举-5-个-python-中的标准模块"><a class="markdownIt-Anchor" href="#7-列举-5-个-python-中的标准模块"></a> 7. 列举 5 个 Python 中的标准模块</h3>
<p>参见：<a href="./#1-%E5%88%97%E5%87%BA-5-%E4%B8%AA%E5%B8%B8%E7%94%A8-Python-%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9F"><em>常用 Python 标准库</em></a></p>
<h3 id="8-如何在函数中设置一个全局变量"><a class="markdownIt-Anchor" href="#8-如何在函数中设置一个全局变量"></a> 8. 如何在函数中设置一个全局变量</h3>
<p>使用global</p>
<h3 id="9-pathlib-的用法举例"><a class="markdownIt-Anchor" href="#9-pathlib-的用法举例"></a> 9. pathlib 的用法举例</h3>
<p>pathlib 模块提供了一组面向对象的类，这些类可代表各种操作系统上的路径，程序可通过这些类操作路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.查看路径</span></span><br><span class="line"><span class="comment"># 使用cmd()方法输出当前的工作目录</span></span><br><span class="line"><span class="comment"># 使用home()输出用户的主目录</span></span><br><span class="line">now_path = Path.cwd()</span><br><span class="line">home_path = Path.home()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前工作目录&quot;</span>, now_path, <span class="built_in">type</span>(now_path))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;home目录&quot;</span>, home_path, <span class="built_in">type</span>(home_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 路径拼接</span></span><br><span class="line"><span class="comment"># 将字符串转为Pathlib.Path类型</span></span><br><span class="line"><span class="comment"># 使用 &quot;/&quot; 直接拼接路径</span></span><br><span class="line">dir_path = Path(<span class="string">r&quot;D:\code\web&quot;</span>) / <span class="string">&quot;flaskweb&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dir_path, <span class="built_in">type</span>(dir_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.读写文件</span></span><br><span class="line"><span class="comment"># 使用基础的open()函数</span></span><br><span class="line">demo_file = Path.cwd() / <span class="string">&#x27;test.md&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(demo_file, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    file_data = fid.read()</span><br><span class="line"><span class="built_in">print</span>(file_data)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用pathlib的open()方法</span></span><br><span class="line"><span class="string">这样写的好处就是open里面我们不需要再去传入路径了，</span></span><br><span class="line"><span class="string">直接指定文件读写模式即可。实际上这里的open方法，</span></span><br><span class="line"><span class="string">底层也是调用了os.open的方法。使用哪种方式看个人的喜好。</span></span><br><span class="line"><span class="string">也可以不使用with open的形式即可以进行读写</span></span><br><span class="line"><span class="string">.read_text(): 找到对应的路径然后打开文件，读成str格式。等同open操作文件的&quot;r&quot;格式。</span></span><br><span class="line"><span class="string">.read_bytes(): 读取字节流的方式。等同open操作文件的&quot;rb&quot;格式。</span></span><br><span class="line"><span class="string">.write_text(): 文件的写的操作，等同open操作文件的&quot;w&quot;格式。</span></span><br><span class="line"><span class="string">.write_bytes(): 文件的写的操作，等同open操作文件的&quot;wb&quot;格式</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">demo_file = Path.cwd() / <span class="string">&#x27;test.md&#x27;</span></span><br><span class="line"><span class="keyword">with</span> demo_file.<span class="built_in">open</span>(<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">    file_data = fid.read()</span><br><span class="line"><span class="built_in">print</span>(file_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.使用resolve可以通过传入文件名，来返回文件的完整路径</span></span><br><span class="line"><span class="comment"># 需要注意的是&quot;demo.py&quot;文件要和我当前的程序文件在同一级目录。</span></span><br><span class="line">py_path =Path(<span class="string">&quot;demo.py&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(py_path.resolve())</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/weixin_42232219/article/details/91349908">CSDN-Pathlib模块</a><br />
<a href="https://docs.python.org/zh-cn/3/library/shutil.html">Python文档-shutil 高阶文件操作</a></p>
<h3 id="10-python-中的异常处理写一个简单的应用场景"><a class="markdownIt-Anchor" href="#10-python-中的异常处理写一个简单的应用场景"></a> 10. Python 中的异常处理，写一个简单的应用场景</h3>
<p>参见：<a href="./#8-%E5%86%99%E4%B8%80%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81"><em>写一段自定义异常代码</em></a><br />
参见：<a href="./#9-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9D%97%E4%B8%AD-try-except-else-finally-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%84%8F%E4%B9%89"><em>异常模块中 try except else finally 的相关意义</em></a></p>
<h3 id="11-python-中递归的最大次数那如何突破呢"><a class="markdownIt-Anchor" href="#11-python-中递归的最大次数那如何突破呢"></a> 11. Python 中递归的最大次数，那如何突破呢？</h3>
<p>最大次数为1000次<br />
<a href="https://code.activestate.com/recipes/474088/">TAIL CALL OPTIMIZATION DECORATOR</a><br />
<s>一脸懵逼</s></p>
<h3 id="12-什么是面向对象的-mro"><a class="markdownIt-Anchor" href="#12-什么是面向对象的-mro"></a> 12. 什么是面向对象的 mro</h3>
<p>MRO：Method Resolution Order(方法解析顺序)<br />
MRO就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。<br />
MRO 是在Python多继承和钻石继承问题上的核心内容，它规定了如何，什么时候，怎么样去 调用父类的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 输出类的解析继承关系顺序：类名.__mro__</span><br><span class="line">DemoClass.__mro__</span><br></pre></td></tr></table></figure>
<h3 id="13-isinstance-作用以及应用场景"><a class="markdownIt-Anchor" href="#13-isinstance-作用以及应用场景"></a> 13. isinstance 作用以及应用场景？</h3>
<p>isinstance：判断对象是否是一个已知的类型</p>
<p>isinstance(object, classinfo)</p>
<ul>
<li>object – 实例对象。</li>
<li>classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。</li>
</ul>
<p>使用场景举例：</p>
<ul>
<li>判断对象的数据类型，如参数和返回值判断，根据不同的数据类型</li>
<li>判断类的继承关系，isinstance可以用作判断是否继承了某个父类</li>
</ul>
<p>拓展：type和isinstance</p>
<ul>
<li>type只输出当前类名，不管继承关系</li>
<li>isinstance在使用当前类的父类做判断时，输出为True（多重继承适用）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">isinstance</span>(A(), A)    <span class="comment"># returns True</span></span><br><span class="line"><span class="built_in">type</span>(A()) == A        <span class="comment"># returns True</span></span><br><span class="line"><span class="built_in">isinstance</span>(B(), A)    <span class="comment"># returns True</span></span><br><span class="line"><span class="built_in">type</span>(B()) == A        <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure>
<h3 id="14-什么是断言应用场景"><a class="markdownIt-Anchor" href="#14-什么是断言应用场景"></a> 14. 什么是断言？应用场景？</h3>
<p>断言语句是将调试断言插入程序的便捷方式<br />
assert condition：在condition为True时不触发，False触发AssertionError错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; assert 1==1</span><br><span class="line">&gt;&gt;&gt; assert 1==0</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    assert 1==0</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>
<p>如果没有特别的目的，断言应该用于如下情况：</p>
<ul>
<li>防御性的编程</li>
<li>运行时对程序逻辑的检测</li>
<li>合约性检查（比如前置条件，后置条件）</li>
<li>程序中的常量</li>
<li>检查文档</li>
</ul>
<h3 id="15-lambda-表达式格式以及应用场景"><a class="markdownIt-Anchor" href="#15-lambda-表达式格式以及应用场景"></a> 15. lambda 表达式格式以及应用场景？</h3>
<p>lambda表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。</p>
<pre><code>lambda表达式：lambda 参数1，参数2...: 参数表达式
</code></pre>
<p>适用场景：</p>
<ul>
<li>简单功能的函数实现</li>
<li>不需要关注函数命名</li>
<li>复用性不高或只用一次的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出1到100内的奇数 filder和lambda的组合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表的排序：按照绝对值大小排序</span></span><br><span class="line"><span class="comment"># sorted和lambda也是很好的组合，这里的abs是绝对值函数</span></span><br><span class="line">list_demo = [<span class="number">3</span>, <span class="number">5</span>, -<span class="number">4</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(list_demo, key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭包lambda</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_y</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: a*x + b</span><br><span class="line">y1 = get_y(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(y1(<span class="number">1</span>))  <span class="comment"># 结果为4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="16-新式类和旧式类的区别"><a class="markdownIt-Anchor" href="#16-新式类和旧式类的区别"></a> 16. 新式类和旧式类的区别</h3>
<div class="tabs" id="新式类"><ul class="nav-tabs"><li class="tab active"><a href="#新式类-1">新式类</a></li><li class="tab"><a href="#新式类-2">旧式类</a></li></ul><div class="tab-content"><div class="tab-pane active" id="新式类-1"><p>在Python 3.x中取消了经典类，默认都是新式类，并且不必显式的继承object，也就是说：</p>
<ul>
<li>class Person(object):pass</li>
<li>class Person():pass</li>
<li>class Person:pass<br />
三种写法并无区别，推荐第一种</li>
</ul></div><div class="tab-pane" id="新式类-2"><ul>
<li>class Person(object):pass 新式类写法</li>
<li>class Person():pass 经典类写法</li>
<li>class Person:pass 经典类写法</li>
</ul></div></div></div>
<p>新式类和经典类的最大的区别：继承搜索顺寻的变化</p>
<ul>
<li>新式类多继承搜索顺序(广度优先)：先在水平方向查找，然后再向上查找</li>
<li>经典类多继承搜索顺序(深度优先)：先深入继承树左侧查找，然后再返回，开始查找右侧</li>
</ul>
<pre>
<code class="mermaid">
graph TD
A[ 基类 A  ] --&gt; C[ C ]
A --&gt; B[ B ]
B --&gt; D[ D ]
C --&gt; D[ D ]
</code>
</pre>
<h3 id="17-dir是干什么用的"><a class="markdownIt-Anchor" href="#17-dir是干什么用的"></a> 17. dir()是干什么用的？</h3>
<p>dir()函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；<br />
带参数时，返回参数的属性、方法列表。<br />
如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。</p>
<h3 id="18-一个包里有三个模块demo1py-demo2py-demo3py但使用-from-tools-import-导入模块时如何保证只有-demo1-demo3-被导入了"><a class="markdownIt-Anchor" href="#18-一个包里有三个模块demo1py-demo2py-demo3py但使用-from-tools-import-导入模块时如何保证只有-demo1-demo3-被导入了"></a> 18. 一个包里有三个模块，<a href="http://demo1.py">demo1.py</a>, <a href="http://demo2.py">demo2.py</a>, <a href="http://demo3.py">demo3.py</a>，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。</h3>
<p>包(package)，本质来说就是一个文件夹，但是其中有一个 init .py文件。<br />
包是从逻辑上来组织模块的，也就是说它是用来存放模块的，如果想导入其他目录下的模块，那么这个目录必须是一个包才可以导入。<br />
在本题中 tools 包下有 <code>demo1.py</code>, <code>demo2.py</code>, <code>demo3.py</code> 和 <code>__init__.py</code> 四个文件，我们只需要在 init 文件中写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> demo1</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> demo3</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .demo2 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h3 id="19-列举-5-个-python-中的异常类型以及其含义"><a class="markdownIt-Anchor" href="#19-列举-5-个-python-中的异常类型以及其含义"></a> 19. 列举 5 个 Python 中的异常类型以及其含义</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException  # 所有异常的基类</span><br><span class="line"> +-- SystemExit  # 解释器请求退出</span><br><span class="line"> +-- KeyboardInterrupt  # 用户中断执行(通常是输入^C)</span><br><span class="line"> +-- GeneratorExit  # 生成器(generator)发生异常来通知退出</span><br><span class="line"> +-- Exception  # 常规异常的基类</span><br><span class="line">      +-- StopIteration  # 迭代器没有更多的值</span><br><span class="line">      +-- StopAsyncIteration  # 必须通过异步迭代器对象的__anext__()方法引发以停止迭代</span><br><span class="line">      +-- ArithmeticError  # 各种算术错误引发的内置异常的基类</span><br><span class="line">      |    +-- FloatingPointError  # 浮点计算错误</span><br><span class="line">      |    +-- OverflowError  # 数值运算结果太大无法表示</span><br><span class="line">      |    +-- ZeroDivisionError  # 除(或取模)零 (所有数据类型)</span><br><span class="line">      +-- AssertionError  # 当assert语句失败时引发</span><br><span class="line">      +-- AttributeError  # 属性引用或赋值失败</span><br><span class="line">      +-- BufferError  # 无法执行与缓冲区相关的操作时引发</span><br><span class="line">      +-- EOFError  # 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发</span><br><span class="line">      +-- ImportError  # 导入模块/对象失败</span><br><span class="line">      |    +-- ModuleNotFoundError  # 无法找到模块或在在sys.modules中找到None</span><br><span class="line">      +-- LookupError  # 映射或序列上使用的键或索引无效时引发的异常的基类</span><br><span class="line">      |    +-- IndexError  # 序列中没有此索引(index)</span><br><span class="line">      |    +-- KeyError  # 映射中没有这个键</span><br><span class="line">      +-- MemoryError  # 内存溢出错误(对于Python 解释器不是致命的)</span><br><span class="line">      +-- NameError  # 未声明/初始化对象 (没有属性)</span><br><span class="line">      |    +-- UnboundLocalError  # 访问未初始化的本地变量</span><br><span class="line">      +-- OSError  # 操作系统错误，EnvironmentError，IOError，WindowsError，socket.error，select.error和mmap.error已合并到OSError中，构造函数可能返回子类</span><br><span class="line">      |    +-- BlockingIOError  # 操作将阻塞对象(e.g. socket)设置为非阻塞操作</span><br><span class="line">      |    +-- ChildProcessError  # 在子进程上的操作失败</span><br><span class="line">      |    +-- ConnectionError  # 与连接相关的异常的基类</span><br><span class="line">      |    |    +-- BrokenPipeError  # 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入</span><br><span class="line">      |    |    +-- ConnectionAbortedError  # 连接尝试被对等方中止</span><br><span class="line">      |    |    +-- ConnectionRefusedError  # 连接尝试被对等方拒绝</span><br><span class="line">      |    |    +-- ConnectionResetError    # 连接由对等方重置</span><br><span class="line">      |    +-- FileExistsError  # 创建已存在的文件或目录</span><br><span class="line">      |    +-- FileNotFoundError  # 请求不存在的文件或目录</span><br><span class="line">      |    +-- InterruptedError  # 系统调用被输入信号中断</span><br><span class="line">      |    +-- IsADirectoryError  # 在目录上请求文件操作(例如 os.remove())</span><br><span class="line">      |    +-- NotADirectoryError  # 在不是目录的事物上请求目录操作(例如 os.listdir())</span><br><span class="line">      |    +-- PermissionError  # 尝试在没有足够访问权限的情况下运行操作</span><br><span class="line">      |    +-- ProcessLookupError  # 给定进程不存在</span><br><span class="line">      |    +-- TimeoutError  # 系统函数在系统级别超时</span><br><span class="line">      +-- ReferenceError  # weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象</span><br><span class="line">      +-- RuntimeError  # 在检测到不属于任何其他类别的错误时触发</span><br><span class="line">      |    +-- NotImplementedError  # 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现</span><br><span class="line">      |    +-- RecursionError  # 解释器检测到超出最大递归深度</span><br><span class="line">      +-- SyntaxError  # Python 语法错误</span><br><span class="line">      |    +-- IndentationError  # 缩进错误</span><br><span class="line">      |         +-- TabError  # Tab和空格混用</span><br><span class="line">      +-- SystemError  # 解释器发现内部错误</span><br><span class="line">      +-- TypeError  # 操作或函数应用于不适当类型的对象</span><br><span class="line">      +-- ValueError  # 操作或函数接收到具有正确类型但值不合适的参数</span><br><span class="line">      |    +-- UnicodeError  # 发生与Unicode相关的编码或解码错误</span><br><span class="line">      |         +-- UnicodeDecodeError  # Unicode解码错误</span><br><span class="line">      |         +-- UnicodeEncodeError  # Unicode编码错误</span><br><span class="line">      |         +-- UnicodeTranslateError  # Unicode转码错误</span><br><span class="line">      +-- Warning  # 警告的基类</span><br><span class="line">           +-- DeprecationWarning  # 有关已弃用功能的警告的基类</span><br><span class="line">           +-- PendingDeprecationWarning  # 有关不推荐使用功能的警告的基类</span><br><span class="line">           +-- RuntimeWarning  # 有关可疑的运行时行为的警告的基类</span><br><span class="line">           +-- SyntaxWarning  # 关于可疑语法警告的基类</span><br><span class="line">           +-- UserWarning  # 用户代码生成警告的基类</span><br><span class="line">           +-- FutureWarning  # 有关已弃用功能的警告的基类</span><br><span class="line">           +-- ImportWarning  # 关于模块导入时可能出错的警告的基类</span><br><span class="line">           +-- UnicodeWarning  # 与Unicode相关的警告的基类</span><br><span class="line">           +-- BytesWarning  # 与bytes和bytearray相关的警告的基类</span><br><span class="line">           +-- ResourceWarning  # 与资源使用相关的警告的基类。被默认警告过滤器忽略。</span><br></pre></td></tr></table></figure>
<h3 id="20-copy-和-deepcopy-的区别是什么"><a class="markdownIt-Anchor" href="#20-copy-和-deepcopy-的区别是什么"></a> 20. copy 和 deepcopy 的区别是什么？</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">b = a <span class="comment"># 引用 a变b变</span></span><br><span class="line">c = copy.copy(a) <span class="comment"># 浅复制 复制子对象的引用 </span></span><br><span class="line">d = copy.deepopy(a) <span class="comment"># 深复制 复制子对象的副本</span></span><br><span class="line"><span class="comment"># copy模块的信息</span></span><br><span class="line"><span class="built_in">help</span>(copy)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3/library/copy.html">python 文档</a></p>
<blockquote>
<p>两者区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关：</p>
<ul>
<li>一个 <em>浅层复制</em> 会构造一个新的复合对象，然后（在可能的范围内）将原对象中找到的 <strong>引用</strong> 插入其中。</li>
<li>一个 <em>深层复制</em> 会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的 <strong>副本</strong> 插入。</li>
</ul>
<p>深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：</p>
<ul>
<li>递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。</li>
<li>由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。</li>
</ul>
<p>Python的深度复制操作通过以下方式避免了上面俩问题：<br />
a）保留一个字典，这个字典是在当前复制过程中已复制的对象的 “备忘录” (<code>memo</code>) 字典<br />
b）允许用户定义的类重载复制操作或复制的组件集合</p>
<p>该模块不复制模块、类、函数、方法、栈追踪（stack trace）、栈帧（stack frame）、文件、套接字、窗口、数组或任何类似类型的类型。<br />
制作字典的浅层复制可以使用 <code>dict.copy()</code> 方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如， &gt; <code>copied_list = original_list[:]</code> 。</p>
</blockquote>
<h3 id="21-代码中经常遇到的args-kwargs-含义及用法"><a class="markdownIt-Anchor" href="#21-代码中经常遇到的args-kwargs-含义及用法"></a> 21. 代码中经常遇到的*args, **kwargs 含义及用法。</h3>
<blockquote>
<p>args 是 arguments 的缩写，表示位置参数；<br />
kwargs 是 keyword arguments 的缩写，表示关键字参数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo_func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="comment"># arg是一个元祖类型</span></span><br><span class="line">    <span class="built_in">print</span>(args[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># kwargs是一个字典类型</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs.keys())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 直接传参，但关键字类型必须为str</span></span><br><span class="line">    demo_func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 使用*和**进行解包</span></span><br><span class="line">    demo_func(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), **&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="22-python-中会有函数或成员变量包含单下划线前缀和结尾和双下划线前缀结尾区别是什么"><a class="markdownIt-Anchor" href="#22-python-中会有函数或成员变量包含单下划线前缀和结尾和双下划线前缀结尾区别是什么"></a> 22. Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?</h3>
<blockquote>
<p>单下划线<br />
单下划线开头的命名方式被常用于模块中，在一个模块中以单下划线开头的变量和方法会被默认划入模块内部范围。<br />
当使用 <code>from my_module import *</code> 导入时，单下划线开头的变量和方法是不会被导入的。<br />
但使用 <code>import my_module</code> 导入的话，仍然可以用 <code>my_module._var</code> 这样的形式访问属性或方法。单下划线结尾的命名方式也存在，但是不常用，其实也不推荐用。这种命名方式的作用就是为了和 python 的一些内置关键词区分开来，假设我们想给一个变量命名为 class，但是这会跟 python 的关键词 class 冲突，所以我们只好退一步使用单下划线结尾命名，也就是 class_。双下划线双下划线开头和结尾的是一些 python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的<code>__file__</code>、<code>__name__</code> 等。 python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。双下划线开头的命名方式有实际的作用，采用这种命名的变量或方法无法直接通过 “对象名.变量名（方法名）” 这样的方式访问。</p>
</blockquote>
<h3 id="23-w-a-wb-文件写入模式的区别"><a class="markdownIt-Anchor" href="#23-w-a-wb-文件写入模式的区别"></a> 23. w、a+、wb 文件写入模式的区别</h3>
<blockquote>
<p>r : 读取文件，若文件不存在则会报错<br />
w: 写入文件，若文件不存在则会先创建再写入，会覆盖原文件<br />
a : 写入文件，若文件不存在则会先创建再写入，但不会覆盖原文件，而是追加在文件末尾<br />
rb,wb：分别于r,w类似，用于读写二进制文件<br />
r+ : 可读、可写，文件不存在也会报错，写操作时会覆盖<br />
w+ : 可读，可写，文件不存在先创建，会覆盖<br />
a+ ：可读、可写，文件不存在先创建，不会覆盖，追加在末尾</p>
</blockquote>
<h3 id="24-举例-sort-和-sorted-的区别"><a class="markdownIt-Anchor" href="#24-举例-sort-和-sorted-的区别"></a> 24. 举例 sort 和 sorted 的区别</h3>
<p>sorted是一个函数，返回一个新的list<br />
sort是实例方法，直接作用在list本身，没有返回新的list</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">demo_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">result_list = <span class="built_in">sorted</span>(demo_list)</span><br><span class="line"><span class="built_in">print</span>(result_list)</span><br><span class="line">demo_list.sort()</span><br><span class="line"><span class="built_in">print</span>(demo_list)</span><br></pre></td></tr></table></figure>
<h3 id="25-什么是负索引"><a class="markdownIt-Anchor" href="#25-什么是负索引"></a> 25. 什么是负索引？</h3>
<p>负索引是指使用负数做为索引，-1代表数组的最后一位</p>
<h3 id="26-pprint-模块是干什么的"><a class="markdownIt-Anchor" href="#26-pprint-模块是干什么的"></a> 26. pprint 模块是干什么的？</h3>
<p>pprint用于输出一个整齐美观Python数据的结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">demo_list = [<span class="built_in">str</span>(i)*<span class="number">20</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">pp_object = pprint.PrettyPrinter(indent=<span class="number">4</span>) <span class="comment"># indent 是指句首缩进</span></span><br><span class="line">pp_object.pprint(demo_list)  <span class="comment"># 整齐输出</span></span><br><span class="line"><span class="built_in">print</span>(demo_list)             <span class="comment"># 只输出一行</span></span><br></pre></td></tr></table></figure>
<h3 id="27-解释一下-python-中的赋值运算符"><a class="markdownIt-Anchor" href="#27-解释一下-python-中的赋值运算符"></a> 27. 解释一下 Python 中的赋值运算符</h3>
<p>赋值运算符包括：<code>=</code> 加<code>+=</code> 减<code>-=</code> 乘<code>*=</code> 除<code>/=</code> 取模<code>%=</code> 幂<code>**=</code> 取整除<code>//=</code></p>
<h3 id="28-解释一下-python-中的逻辑运算符"><a class="markdownIt-Anchor" href="#28-解释一下-python-中的逻辑运算符"></a> 28. 解释一下 Python 中的逻辑运算符</h3>
<p>逻辑运算符包括：与<code>and</code> 或<code>or</code> 非<code>nor</code></p>
<h3 id="29-讲讲-python-中的位运算符"><a class="markdownIt-Anchor" href="#29-讲讲-python-中的位运算符"></a> 29. 讲讲 Python 中的位运算符</h3>
<p>位运算符包括：按位与<code>&amp;</code> 按位或<code>|</code> 按位异或<code>^</code> 按位取反<code>~</code> 左移动<code>&lt;&lt;</code> 右移动<code>&gt;&gt;</code></p>
<h3 id="30-在-python-中如何使用多进制数字"><a class="markdownIt-Anchor" href="#30-在-python-中如何使用多进制数字"></a> 30. 在 Python 中如何使用多进制数字？</h3>
<p>二进制前缀 <code>0b</code>或<code>0B</code><br />
八进制前缀 <code>0o</code>或<code>0O</code><br />
十六进制前缀 <code>0x</code>或<code>0X</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(<span class="number">0b1010</span>) <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">int</span>(<span class="number">0o10</span>) <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">int</span>(<span class="number">0xf</span>) <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bin</span>(<span class="number">15</span>) <span class="comment"># &#x27;0b1111&#x27;</span></span><br><span class="line"><span class="built_in">oct</span>(<span class="number">15</span>) <span class="comment"># &#x27;0o17&#x27;</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">15</span>) <span class="comment"># &#x27;0xf&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="31-怎样声明多个变量并赋值"><a class="markdownIt-Anchor" href="#31-怎样声明多个变量并赋值"></a> 31. 怎样声明多个变量并赋值？</h3>
<p><code>a, b = 1, 2</code></p>
<h2 id="算法和数据结构"><a class="markdownIt-Anchor" href="#算法和数据结构"></a> 算法和数据结构</h2>
<h3 id="1-已知"><a class="markdownIt-Anchor" href="#1-已知"></a> 1. 已知：</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">BSet = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？</strong></p>
<p><strong>(2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？</strong></p>
<ul>
<li>python的列表内部实现是数组（具体实现要看解析器, CPython的实现 ），因此就有数组的特点。超过容量会增加更多的容量，set, get 是O(1)，但del, insert, in的性能是O(n)。</li>
<li>关于字典需要了解的是hash函数和哈希桶。一个好的hash函数使到哈希桶中的值只有一个，若多个key hash到了同一个哈希桶中，称之为哈希冲突。查找值时，会先定位到哈希桶中，再遍历hash桶。在hash基本没有冲突的情况下get, set, delete, in方面都是O(1)。</li>
<li>集合内部实现是dict的。在in操作上是O(1), 这一点比list要强。</li>
</ul>
<p>所以答案是</p>
<ol>
<li>查找操作set优于list；</li>
<li>插入操作两个相同；</li>
</ol>
<h3 id="2-用-python-实现一个二分查找的函数"><a class="markdownIt-Anchor" href="#2-用-python-实现一个二分查找的函数"></a> 2. 用 Python 实现一个二分查找的函数</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_Search</span>(<span class="params">search_list: <span class="built_in">list</span>, search_num: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    利用二分法找到list数组中的值</span></span><br><span class="line"><span class="string">    :param search_list: 目标list</span></span><br><span class="line"><span class="string">    :param search_num: 待查询值</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 最小的下标</span></span><br><span class="line">    min_index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 最大的下标</span></span><br><span class="line">    max_index = <span class="built_in">len</span>(search_list) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 查找次数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 中间的下标每次向下取整</span></span><br><span class="line">        mid_index = (min_index + max_index) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> search_num &gt; search_list[mid_index]:</span><br><span class="line">            <span class="comment"># 小于需要的猜的数，则将最小下标变为中间的，因为中间的已经猜过，所以要加1</span></span><br><span class="line">            min_index = mid_index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> search_num &lt; search_list[mid_index]:</span><br><span class="line">            <span class="comment"># 大于需要的猜的数，则将最大下标变为中间的，因为中间的已经猜过，所以要减1</span></span><br><span class="line">            max_index = mid_index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;找到数据&quot;</span>, <span class="string">&quot;索引是&#123;&#125;&quot;</span>.<span class="built_in">format</span>(mid_index))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;一共查找&#123;&#125;次&quot;</span>.<span class="built_in">format</span>(count))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 索引值加一</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;search_num&#125;</span> 与 <span class="subst">&#123;search_list[mid_index]&#125;</span> 相比较&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1000</span>)]</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    binary_Search(list1, num)</span><br></pre></td></tr></table></figure>
<h3 id="3-python-单例模式的实现方法"><a class="markdownIt-Anchor" href="#3-python-单例模式的实现方法"></a> 3. python 单例模式的实现方法</h3>
<p>应用单例模式的类只会生成一个实例：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。<br />
下面是使用四种方式实现单例模式：<a href="https://zhuanlan.zhihu.com/p/37534850">原文链接</a></p>
<ul>
<li>使用函数装饰器实现单例  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls()</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">    </span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cls</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls()</span><br><span class="line">cls2 = Cls()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(cls1) == <span class="built_in">id</span>(cls2))</span><br></pre></td></tr></table></figure>
</li>
<li>使用类装饰器实现单例  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cls</span>):</span><br><span class="line">        self._cls = cls</span><br><span class="line">        self._instance = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._cls <span class="keyword">not</span> <span class="keyword">in</span> self._instance:</span><br><span class="line">            self._instance[self._cls] = self._cls()</span><br><span class="line">        <span class="keyword">return</span> self._instance[self._cls]</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cls2</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls2()</span><br><span class="line">cls2 = Cls2()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(cls1) == <span class="built_in">id</span>(cls2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样也可以用下面的方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cls3</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Cls3 = Singleton(Cls3)</span><br><span class="line">cls3 = Cls3()</span><br><span class="line">cls4 = Cls3()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(cls3) == <span class="built_in">id</span>(cls4))</span><br></pre></td></tr></table></figure>
</li>
<li>使用 <strong>new</strong> 关键字实现单例  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kw</span>):</span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = <span class="built_in">object</span>.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(single1) == <span class="built_in">id</span>(single2))</span><br></pre></td></tr></table></figure>
</li>
<li>使用 metaclass 实现单例  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = <span class="built_in">super</span>(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cls4</span>(metaclass=Singleton):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls4()</span><br><span class="line">cls2 = Cls4()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(cls1) == <span class="built_in">id</span>(cls2))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-使用-python-实现一个斐波那契数列"><a class="markdownIt-Anchor" href="#4-使用-python-实现一个斐波那契数列"></a> 4. 使用 Python 实现一个斐波那契数列</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fbnq</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;斐波那契生成器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param num: 生产数量</span></span><br><span class="line"><span class="string">    :return: 斐波那契迭代器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gener = fbnq(<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(gener))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gener:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h3 id="5-找出列表中的重复数字"><a class="markdownIt-Anchor" href="#5-找出列表中的重复数字"></a> 5. 找出列表中的重复数字</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计每个数字个数</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">result = Counter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
<h3 id="6-找出列表中的单个数字"><a class="markdownIt-Anchor" href="#6-找出列表中的单个数字"></a> 6. 找出列表中的单个数字</h3>
<p>同上</p>
<h3 id="7-写一个冒泡排序"><a class="markdownIt-Anchor" href="#7-写一个冒泡排序"></a> 7. 写一个冒泡排序</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">parm_list</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(parm_list)):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(parm_list) -n -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> parm_list[m] &gt; parm_list[m +<span class="number">1</span>]:</span><br><span class="line">                parm_list[m], parm_list[m +<span class="number">1</span>] = parm_list[m +<span class="number">1</span>], parm_list[m]</span><br><span class="line">    <span class="keyword">return</span> parm_list</span><br></pre></td></tr></table></figure>
<h3 id="8-写一个快速排序"><a class="markdownIt-Anchor" href="#8-写一个快速排序"></a> 8. 写一个快速排序</h3>
<p>快排:<br />
每次选取第一个值为基准值，再把列表中比基准值大的组成新列表，小的组成另一个新列表，再次对两个新列表进行操作，直到新列表为空</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">parm_list</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> parm_list:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = parm_list[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 利用递归每次找出大于和小于基准值得两个新列表</span></span><br><span class="line">        lesser = quick_sort([x <span class="keyword">for</span> x <span class="keyword">in</span> parm_list[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; pivot])</span><br><span class="line">        greater = quick_sort([x <span class="keyword">for</span> x <span class="keyword">in</span> parm_list[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= pivot])</span><br><span class="line">        <span class="comment"># 最后将排列好的值相加</span></span><br><span class="line">        <span class="keyword">return</span> lesser + [pivot] + greater</span><br></pre></td></tr></table></figure>
<h3 id="9-写一个拓扑排序"><a class="markdownIt-Anchor" href="#9-写一个拓扑排序"></a> 9. 写一个拓扑排序</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">topology_sort</span>(<span class="params">relation_parm</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单拓扑排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    简单实现拓扑排序算法，不考虑时间复杂度</span></span><br><span class="line"><span class="string">    :param relation_parm: 拓扑关系字典参数</span></span><br><span class="line"><span class="string">    :return: 排序后结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    in_degrees = <span class="built_in">dict</span>((u, <span class="number">0</span>) <span class="keyword">for</span> u <span class="keyword">in</span> relation_parm)            <span class="comment"># 初始化所有顶点入度为0，转为字典类型</span></span><br><span class="line">    vertex_num = <span class="built_in">len</span>(in_degrees)                                <span class="comment"># 字典键值个数</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> relation_parm:                                   <span class="comment"># 遍历关系参数字典，求出每个顶点的入度值</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> relation_parm[key]:                        <span class="comment"># 遍历每个键的值，将关系其他顶点的键值+1到in_degrees字典中</span></span><br><span class="line">            in_degrees[value] += <span class="number">1</span>                              <span class="comment"># 计算每个顶点的入度</span></span><br><span class="line">    zero_list = [u <span class="keyword">for</span> u <span class="keyword">in</span> in_degrees <span class="keyword">if</span> in_degrees[u] == <span class="number">0</span>]   <span class="comment"># 筛选入度为0的顶点</span></span><br><span class="line">    result_list = []                                            <span class="comment"># 创建结果空列表</span></span><br><span class="line">    <span class="keyword">while</span> zero_list:                                            <span class="comment"># 循环判断列表为空</span></span><br><span class="line">        last_zero = zero_list.pop()                             <span class="comment"># 删除最后一个入度为0的对象</span></span><br><span class="line">        result_list.append(last_zero)                           <span class="comment"># 结构列表添加刚删除的对象</span></span><br><span class="line">        <span class="keyword">for</span> zero_value <span class="keyword">in</span> relation_parm[last_zero]:             <span class="comment"># 遍历以入度为0作为键的字典值</span></span><br><span class="line">            in_degrees[zero_value] -= <span class="number">1</span>                         <span class="comment"># 和last_zero有关系的键值-1</span></span><br><span class="line">            <span class="keyword">if</span> in_degrees[zero_value] == <span class="number">0</span>:                     <span class="comment"># 判断-1过后的键值是否为0</span></span><br><span class="line">                zero_list.append(zero_value)                    <span class="comment"># 再次筛选入度为0的顶点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result_list) != vertex_num:                          <span class="comment"># 如果循环结束后结果列表对象个数不等于原始键个数，说明存在环</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;there&#x27;s a circle.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">relation_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;bcd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;be&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;de&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(topology_sort(relation_dict)) <span class="comment"># [&#x27;f&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-python-实现一个二进制计算"><a class="markdownIt-Anchor" href="#11-python-实现一个二进制计算"></a> 11. python 实现一个二进制计算</h3>
<h3 id="12-有一组和-符号要求将排到左边-排到右边写出具体的实现方法"><a class="markdownIt-Anchor" href="#12-有一组和-符号要求将排到左边-排到右边写出具体的实现方法"></a> 12. 有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。</h3>
<h3 id="13-单链表反转"><a class="markdownIt-Anchor" href="#13-单链表反转"></a> 13. 单链表反转</h3>
<h3 id="14-交叉链表求交点"><a class="markdownIt-Anchor" href="#14-交叉链表求交点"></a> 14. 交叉链表求交点</h3>
<h3 id="15-用队列实现栈"><a class="markdownIt-Anchor" href="#15-用队列实现栈"></a> 15. 用队列实现栈</h3>
<h3 id="16-找出数据流的中位数"><a class="markdownIt-Anchor" href="#16-找出数据流的中位数"></a> 16. 找出数据流的中位数</h3>
<h3 id="17-二叉搜索树中第-k-小的元素"><a class="markdownIt-Anchor" href="#17-二叉搜索树中第-k-小的元素"></a> 17. 二叉搜索树中第 K 小的元素</h3>
<h2 id="爬虫相关"><a class="markdownIt-Anchor" href="#爬虫相关"></a> 爬虫相关</h2>
<h3 id="1-在-requests-模块中requestscontent-和-requeststext-什么区别"><a class="markdownIt-Anchor" href="#1-在-requests-模块中requestscontent-和-requeststext-什么区别"></a> 1. 在 requests 模块中，requests.content 和 requests.text 什么区别</h3>
<p><code>.content</code>中间存的是字节码 <code>.text</code>存的是<code>.content</code>编码后的字符串</p>
<h3 id="2-简要写一下-lxml-模块的使用方法框架"><a class="markdownIt-Anchor" href="#2-简要写一下-lxml-模块的使用方法框架"></a> 2. 简要写一下 lxml 模块的使用方法框架</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">htmlEmt = etree.HTML(text)</span><br><span class="line"></span><br><span class="line">result = etree.tostring(htmlEmt)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-说一说-scrapy-的工作流程"><a class="markdownIt-Anchor" href="#3-说一说-scrapy-的工作流程"></a> 3. 说一说 scrapy 的工作流程</h3>
<ol>
<li>首先Spiders（爬虫）将需要发送请求的url(requests)经ScrapyEngine（引擎）交给Scheduler（调度器）。</li>
<li>Scheduler（排序，入队）处理后，经ScrapyEngine，DownloaderMiddlewares(可选，主要有User_Agent, Proxy代理)交给Downloader。</li>
<li>Downloader向互联网发送请求，并接收下载响应（response）。将响应（response）经ScrapyEngine，SpiderMiddlewares(可选)交给Spiders。</li>
<li>Spiders处理response，提取数据并将数据经ScrapyEngine交给ItemPipeline保存（可以是本地，可以是数据库）。</li>
<li>提取url重新经ScrapyEngine交给Scheduler进行下一个循环。直到无Url请求程序停止结束。</li>
</ol>
<h3 id="4-scrapy-的去重原理"><a class="markdownIt-Anchor" href="#4-scrapy-的去重原理"></a> 4. scrapy 的去重原理</h3>
<ol>
<li>Scrapy本身自带有一个中间件;</li>
<li>scrapy源码中可以找到一个dupefilters.py去重器;</li>
<li>需要将dont_filter设置为False开启去重，默认是false去重，改为True,就是没有开启去重；</li>
<li>对于每一个url的请求，调度器都会根据请求得相关信息加密得到一个指纹信息，并且将指纹信息和set()集合中的指纹信息进 行 比对，如果set()集合中已经存在这个数据，就不在将这个Request放入队列中;</li>
<li>如果set()集合中没有存在这个加密后的数据，就将这个Request对象放入队列中，等待被调度。</li>
</ol>
<h3 id="5-scrapy-中间件有几种类你用过哪些中间件"><a class="markdownIt-Anchor" href="#5-scrapy-中间件有几种类你用过哪些中间件"></a> 5. scrapy 中间件有几种类，你用过哪些中间件</h3>
<p><strong>spider中间件</strong>（主职过滤）对Request、Response的主要作用在过滤，可以对特定路径的URL请求丢弃、对特定页面响应过滤、同时对一些不含有指定信息的item过滤，当然pipeline也能实现item的过滤。<br />
<strong>下载中间件</strong>（主职加工）主要作用是加工，如给Request添加代理、添加UA、添加cookie，对Response返回数据编码解码、压缩解压缩、格式化等预处理。</p>
<p>user-agend中间件、代理ip中间件、selenium中间件、cookie中间件</p>
<h3 id="6-你写爬虫的时候都遇到过什么反爬虫措施你是怎么解决的"><a class="markdownIt-Anchor" href="#6-你写爬虫的时候都遇到过什么反爬虫措施你是怎么解决的"></a> 6. 你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？</h3>
<p>反爬策略1：通过UA限制或者其他头信息限制<br />
解决方案：构建用户代理池或其他头信息<br />
反爬策略2：通过访问者IP限制<br />
解决方案：构建IP代理池<br />
反爬策略3：通过验证码限制<br />
解决方案：手工打码、验证码接口自动识别或者通过机器学习自动识别<br />
反爬策略4：通过数据的异步加载限制<br />
解决方案：抓包分析或者使用PhantomJS<br />
反爬策略5：通过Cookie限制<br />
解决方案：进行Cookie处理<br />
反爬策略6：通过JS限制（如请求的数据通过JS随机生成等）解决方案：分析JS解密或者使用PhantomJS</p>
<h3 id="7-为什么会用到代理"><a class="markdownIt-Anchor" href="#7-为什么会用到代理"></a> 7. 为什么会用到代理？</h3>
<p>网站采取了反爬虫措施——限制IP的访问，这时就用到了代理IP，将本机的IP伪装起来，通过代理服务器发送请求。</p>
<h3 id="8-代理失效了怎么处理"><a class="markdownIt-Anchor" href="#8-代理失效了怎么处理"></a> 8. 代理失效了怎么处理？</h3>
<p>换一个？！用代理池？</p>
<h3 id="9-列出你知道-header-的内容以及信息"><a class="markdownIt-Anchor" href="#9-列出你知道-header-的内容以及信息"></a> 9. 列出你知道 header 的内容以及信息</h3>
<p>主要的请求方式<code>GET</code>和<code>POST</code><br />
<code>Host</code>: 请求的Web服务器地址<br />
<code>User-Agent</code>: 客户端浏览器信息<br />
<code>Accept</code>: 客户端能够接收的内容类型</p>
<h3 id="10-说一说打开浏览器访问-百度一下你就知道-获取到结果整个流程"><a class="markdownIt-Anchor" href="#10-说一说打开浏览器访问-百度一下你就知道-获取到结果整个流程"></a> 10. 说一说打开浏览器访问 百度一下，你就知道 获取到结果，整个流程。</h3>
<ol>
<li>浏览器向 DNS 服务器发送 <a href="http://baidu.com">baidu.com</a> 域名解析请求。</li>
<li>DNS 服务器返回解析后的 ip 给客户端浏览器，浏览器想该 ip 发送⻚⾯请求。</li>
<li>DNS 服务器接收到请求 后，查询该⻚⾯，并将⻚⾯发送给客户端浏览器。</li>
<li>客户端浏览器接收到⻚⾯后，解析⻚⾯中的引⽤，并再 次向服务器发送引⽤资源请求。</li>
<li>服务器接收到资源请求后，查找并返回资源给客户端。</li>
<li>客户端浏览器接收 到资源后，渲染，输出⻚⾯展现给⽤户。</li>
</ol>
<h3 id="11-爬取速度过快出现了验证码怎么处理"><a class="markdownIt-Anchor" href="#11-爬取速度过快出现了验证码怎么处理"></a> 11. 爬取速度过快出现了验证码怎么处理</h3>
<p>最好方法就是尽量避免遇到它，采集速度不要太快，短时间内不要过度频繁的访问一个网站，而是要表现得更像一个人，模拟人浏览网页的操作行为。<br />
将许多验证码解算器集成到他的爬虫系统中。如：验证码识别服务供应商 <code>Death by CAPTCHA</code>和<code>Bypass CAPTCHA</code> 都允许用户通过调用API服务来进行自动打码，从而在抓取数据过程中自动解决验证码。这些验证码解决工具可以处理普通的文本验证码，甚至是更高级的验证码</p>
<h3 id="12-scrapy-和-scrapy-redis-有什么区别为什么选择-redis-数据库"><a class="markdownIt-Anchor" href="#12-scrapy-和-scrapy-redis-有什么区别为什么选择-redis-数据库"></a> 12. scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？</h3>
<p>Scrapy 是一个通用的爬虫框架，但是不支持分布式.<br />
Scrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)。</p>
<h3 id="13-分布式爬虫主要解决什么问题"><a class="markdownIt-Anchor" href="#13-分布式爬虫主要解决什么问题"></a> 13. 分布式爬虫主要解决什么问题</h3>
<ol>
<li>ip</li>
<li>带宽</li>
<li>cpu</li>
<li>io</li>
</ol>
<h3 id="14-写爬虫是用多进程好还是多线程好-为什么"><a class="markdownIt-Anchor" href="#14-写爬虫是用多进程好还是多线程好-为什么"></a> 14. 写爬虫是用多进程好？还是多线程好？ 为什么？</h3>
<p>IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。<br />
在实际的数据采集过程中，既考虑网速和响应的问题，也需要考虑自身机器的硬件情况，来设置多进程或多线程.<br />
<code>phantomjs</code> 或者<code>chrome-headless</code> 来抓取的爬虫，应当是多进程的，因为每一个<code>phan/chro</code> 实例就是一个进程了，并发只能是多进程。此外爬虫中还是数据处理业务，如果数据处理业务是一个比较耗时的计算型操作，那么对数据处理部分应当设为多进程，但更多可能会考虑将该部分数据处理操作和爬虫程序解耦，也就是先把数据抓取下来，事后单独运行另外的程序解析数据。</p>
<h3 id="15-解析网页的解析器使用最多的是哪几个"><a class="markdownIt-Anchor" href="#15-解析网页的解析器使用最多的是哪几个"></a> 15. 解析网页的解析器使用最多的是哪几个</h3>
<p><code>lxml</code>, <code>re</code>, <code>beautifulsope</code>.</p>
<h3 id="16-需要登录的网页如何解决同时限制-ipcookiesession其中有一些是动态生成的在不使用动态爬取的情况下"><a class="markdownIt-Anchor" href="#16-需要登录的网页如何解决同时限制-ipcookiesession其中有一些是动态生成的在不使用动态爬取的情况下"></a> 16. 需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？</h3>
<p><em>解决限制 IP 可以使用代理 IP 地址池、服务器；<br />
不适用动态爬取的情况下可以使用反编译 JS 文件获取相应的文件，或者换用其他平台（比如手机端） 看看是否可以获取相应的 json 文件。</em></p>
<h3 id="17-验证码的解决简单的对图像做处理后可以得到的困难的验证码是点击拖动等动态进行的"><a class="markdownIt-Anchor" href="#17-验证码的解决简单的对图像做处理后可以得到的困难的验证码是点击拖动等动态进行的"></a> 17. 验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）</h3>
<p><strong>图形验证码</strong>：干扰、杂色不是特别多的图片可以使用开源库 Tesseract 进行识别，太过复杂的需要借助第三方打码平台。<br />
<strong>点击和拖动滑块验证码</strong>：可以借助 <code>selenium</code>、无图形界面浏览器（<code>chromedirver</code> 或者 <code>phantomjs</code>） 和 <code>pillow</code> 包来模拟人的点击和滑动操作，<code>pillow</code> 可以根据色差识别需要滑动的位置。<br />
<strong>手动打码</strong>（有的验证码确实无解）</p>
<h3 id="18-使用最多的数据库mysqlmongodbredis-等对他的理解"><a class="markdownIt-Anchor" href="#18-使用最多的数据库mysqlmongodbredis-等对他的理解"></a> 18. 使用最多的数据库（mysql，mongodb，redis 等），对他的理解？</h3>
<p><strong>MySQL 数据库</strong>：开源免费的关系型数据库，需要实现创建数据库、数据表和表的字段，表与表之间可以进行关联（一对多、多对多），是持久化存储。<br />
<strong>Mongodb 数据库</strong>：是非关系型数据库，数据库的三元素是，数据库、集合、文档，可以进行持久化存储，也可作为内存数据库，存储数据不需要事先设定格式，数据以键值对的形式存储。<br />
<strong>redis 数据库</strong>：非关系型数据库，使用前可以不用设置格式，以键值对的方式保存，文件格式相对自由，主要用与缓存数据库，也可以进行持久化存储。</p>
<h2 id="网络编程"><a class="markdownIt-Anchor" href="#网络编程"></a> 网络编程</h2>
<h3 id="1-tcp-和-udp-的区别"><a class="markdownIt-Anchor" href="#1-tcp-和-udp-的区别"></a> 1. TCP 和 UDP 的区别？</h3>
<ol>
<li>基于连接与无连接；</li>
<li>对系统资源的要求（TCP较多，UDP少）；</li>
<li>UDP程序结构较简单；</li>
<li>流模式与数据报模式 ；</li>
<li>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接</td>
<td>面向连接</td>
<td>面向非连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>数据量</td>
<td>少量</td>
<td>大量</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody>
</table>
<h3 id="2-简要介绍三次握手和四次挥手"><a class="markdownIt-Anchor" href="#2-简要介绍三次握手和四次挥手"></a> 2. 简要介绍三次握手和四次挥手</h3>
<ol>
<li>第一次握手：客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据</li>
</ol>
<p>由于TCP连接是全双工的，连接的拆除需要发送四个包，因此称为“四次挥手”。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<ol>
<li>第一次挥手：客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li>
<li>第二次挥手：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。</li>
<li>第三次挥手：服务器关闭与客户端的连接，发送一个FIN给客户端。</li>
<li>第四次挥手：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ol>
<h3 id="3-什么是粘包-socket-中造成粘包的原因是什么-哪些情况会发生粘包现象"><a class="markdownIt-Anchor" href="#3-什么是粘包-socket-中造成粘包的原因是什么-哪些情况会发生粘包现象"></a> 3. 什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？</h3>
<ol>
<li>
<p>粘包的概念<br />
粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
</li>
<li>
<p>出现粘包的原因出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。<br />
发送方引起的粘包是由TCP协议本身造成的：，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。<br />
接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Simon
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.simon7.top/20200408/python-%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" title="Python 面试准备">https://blog.simon7.top/20200408/python-面试准备/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/20200408/git%E7%AC%94%E8%AE%B0/" rel="prev" title="Git笔记">
                  <i class="fa fa-angle-left"></i> Git笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/20200402/hexo-%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD-2/" rel="next" title="Hexo-博客备份-2">
                  Hexo-博客备份-2 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-atom"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Simon</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
