<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>音乐API</title>
      <link href="/20200322/%E9%9F%B3%E4%B9%90api/"/>
      <url>/20200322/%E9%9F%B3%E4%B9%90api/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一、-网易"><a href="#一、-网易" class="headerlink" title="一、 网易"></a>一、 网易</h1><h2 id="1-何以诚-网易云音乐API分析-CSDN"><a href="#1-何以诚-网易云音乐API分析-CSDN" class="headerlink" title="1. 何以诚.网易云音乐API分析.CSDN"></a>1. <a href="https://blog.csdn.net/u013022222/article/details/51707352" target="_blank" rel="noopener">何以诚.网易云音乐API分析.CSDN</a></h2><h1 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h1><p>参考资料：</p><ul><li><p>官方</p><ul><li><a href="https://y.qq.com/m/api/open/index.html" target="_blank" rel="noopener">QQ音乐 | 移动WEB接入说明</a></li></ul></li><li><p>简书</p><ul><li><a href="https://www.jianshu.com/p/67e4bd47d981" target="_blank" rel="noopener">QQ音乐api的使用</a></li><li><a href="https://www.jianshu.com/p/ce1180eac37b" target="_blank" rel="noopener">QQ音乐网页接口分析</a></li><li><a href="https://www.jianshu.com/p/e3c8b4b39c11" target="_blank" rel="noopener">qq音乐api接口</a></li></ul></li><li><p>CSDN</p><ul><li><a href="https://blog.csdn.net/qq_41979349/article/details/102458551" target="_blank" rel="noopener">2019最新QQ音乐Api</a></li></ul></li></ul><h1 id="二、-酷狗"><a href="#二、-酷狗" class="headerlink" title="二、 酷狗"></a>二、 酷狗</h1><h1 id="虾米"><a href="#虾米" class="headerlink" title="虾米"></a>虾米</h1><h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h1 id="一听"><a href="#一听" class="headerlink" title="一听"></a>一听</h1><h1 id="咪咕"><a href="#咪咕" class="headerlink" title="咪咕"></a>咪咕</h1><h1 id="荔枝"><a href="#荔枝" class="headerlink" title="荔枝"></a>荔枝</h1><h1 id="蜻蜓"><a href="#蜻蜓" class="headerlink" title="蜻蜓"></a>蜻蜓</h1><h1 id="喜马拉雅"><a href="#喜马拉雅" class="headerlink" title="喜马拉雅"></a>喜马拉雅</h1><h1 id="全民K歌"><a href="#全民K歌" class="headerlink" title="全民K歌"></a>全民K歌</h1><h1 id="5sing原创"><a href="#5sing原创" class="headerlink" title="5sing原创"></a>5sing原创</h1><h1 id="5sing翻唱"><a href="#5sing翻唱" class="headerlink" title="5sing翻唱"></a>5sing翻唱</h1>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-添加音乐播放器</title>
      <link href="/20200303/hexo-%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
      <url>/20200303/hexo-%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在此使用的是<a href="https://aplayer.js.org/#/zh-Hans/?id=%E5%85%A5%E9%97%A8" target="_blank" rel="noopener"> Aplayer.MoePlayer.GitHub </a> ，在Next(Gemini)主题下设置。</p><blockquote><p>搭配<a href="https://github.com/maicong/music" target="_blank" rel="noopener"> 音乐搜索器.maicong.GitHub </a> 使用更佳</p></blockquote><h1 id="一、-安装"><a href="#一、-安装" class="headerlink" title="一、 安装"></a>一、 安装</h1><p>在GitHub下载 <a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">Aplayer</a>，然后将<code>dist</code>文件夹复制到<code>themes/next/source</code>文件夹下。</p><ul><li>注：尝试复制到 <code>source</code>文件夹下失败。</li></ul><a id="more"></a><h1 id="二、-配置"><a href="#二、-配置" class="headerlink" title="二、 配置"></a>二、 配置</h1><p>新建 <code>themes/next/source/dist/music.js</code> 文件，添加内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> APlayer(&#123;</span><br><span class="line">    container: <span class="built_in">document</span>.getElementById(<span class="string">'aplayer'</span>),</span><br><span class="line"></span><br><span class="line">fixed: <span class="literal">true</span>, <span class="comment">// 吸底模式</span></span><br><span class="line">autoplay: <span class="literal">true</span>,<span class="comment">// 自动播放</span></span><br><span class="line">theme: <span class="string">'#b7daff'</span> ,<span class="comment">//主题色</span></span><br><span class="line">loop: <span class="string">'all'</span>, <span class="comment">// 循环播放, 可选值: 'all', 'one', 'none'</span></span><br><span class="line">order: <span class="string">'list'</span>,<span class="comment">// 循环顺序, 可选值: 'list', 'random'</span></span><br><span class="line">volume: <span class="number">0.7</span>,<span class="comment">// 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span></span><br><span class="line">mutex: <span class="literal">true</span>,<span class="comment">// 阻止多个播放器同时播放</span></span><br><span class="line">listFolded: <span class="literal">false</span>,<span class="comment">// 是否列表 默认折叠</span></span><br><span class="line">listMaxHeight: <span class="number">90</span>,<span class="comment">// 列表最大高度</span></span><br><span class="line">lrcType: <span class="number">1</span>,</span><br><span class="line">audio: [</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"清新的小女孩 (For Ma)"</span>, <span class="comment">//名称</span></span><br><span class="line">artist: <span class="string">'July Tun'</span>,<span class="comment">// 艺术家 </span></span><br><span class="line">url: <span class="string">'http://antiserver.kuwo.cn/anti.s?useless=/resource/&amp;format=mp3&amp;rid=MUSIC_72891154&amp;response=res&amp;type=convert_url&amp;'</span>,<span class="comment">//链接 </span></span><br><span class="line">cover: <span class="string">'http://imge.kugou.com/stdmusic/150/20200114/20200114142306429193.jpg'</span>,<span class="comment">//封面</span></span><br><span class="line">lrc: <span class="string">'[00:1.21]清新的小女孩 - ไทย[00:14.88]႐ိုး႐ိုးေလးနဲ႔ လွေနတယ္ မရယ္[00:20.31]清新脱俗的女孩[00:20.31]ဆန္း၂ျပား၂မ၀တ္ပါနဲ႔လားကြယ္[00:28.58]你不需要刻意打扮穿着[00:28.58]ကမ႓ာေက်ာ္တဲ့ မင္းသမီးေတာင္[00:33.54]你的美貌[00:33.54]ေငးေမာေလာက္တယ္ မရဲ႕ အလွေတြရယ္[00:40.37]哪怕国际女星都会仰慕[00:40.37]မိုးျမင့္ထက္က ေငြၾကယ္ကေလးလိုပဲ[00:43.95]你清澈的眼眸[00:43.95]ေတာက္ပလြန္းတဲ့ ဒီမ်က္လံုးေတြနဲ႔[00:47.2]就像银河里的星星[00:47.2]ဖမ္းစားညိႇဳ႕တက္တယ္ ေမ့လို႔မရႏိုင္[00:51.57]你如此迷人，让人难以忘怀[00:51.57]မရဲ႕အၿပံဳးေတြထဲ[00:53.16]你的笑容里[00:53.16]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[00:57.03]有种不同寻常的美[00:57.03]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[01:00.03]一定是你前世修来的[01:00.03]႐ူးခဲ့ရသူ ရင္ထဲလည္း[01:05.38]内心疯狂的想念你[01:05.38]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[01:12.25]每分每秒都在想你[01:12.25]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[01:38.68]你就像校园里的女神一样[01:38.68]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[01:45.07]你是世上最美的女孩[01:45.07]အရမ္းလွတဲ့သူ မ ရယ္[01:49.1]美丽的女孩[01:49.1]ခ်စ္ပါရေစေတာ့ကြယ္[01:55.52]让我爱上你吧[01:55.52]မရဲ႕အခ်စ္နဲ႔ျပည့္စံုၿပီေပါ့ တကယ္[01:63.48]有你的微笑我就心满意足了[01:63.48]ေက်းဇူးျပဳ၍ မမုန္းပါနဲ႔လားကြယ္[01:68.97]只求你不要讨厌我[01:68.97]ဒီကမ႓ာမွာ မတစ္ေယာက္သာ ေတာင္းတမိတယ္[01:75.42]在这世界上，只为你一个人着迷[01:75.42]က်ေနာ့္ရဲ႕ အခ်စ္အိမ္ထဲ[01:82.08]在我的心里[01:82.08]ေမ့လို႔မရတဲ့ အိပ္မက္ထဲမွာပဲ[01:86.63]即使在梦里也忘不了你[01:86.63]စိုးမိုးထားခဲ့ ဒီအၾကည့္ေတြနဲ႔[01:91.75]你看我的样子[01:91.75]႐ူးသြပ္ခဲ့ရတယ္[01:92.52]让我痴迷[01:92.52]မရဲ႕အလွမွာ ႐ုန္းလို႔မထြက္ႏိုင္ခဲ့[01:98.42]沉醉于你的美貌无法自拔[01:98.42]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[02:04.72]有种不同寻常的美[02:04.72]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[02:07.07]一定是你前世修来的[02:07.07]႐ူးခဲ့ရသူ ရင္ထဲလည္း[02:08.95]内心疯狂的想念你[02:08.95]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[02:14.5]每分每秒都在想你[02:14.5]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[02:2.]你就像校园里的女神一样[02:2.]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[02:22.47]你是世上最美的女孩[02:22.47]အရမ္းလွတဲ့သူ မ ရယ္[02:26.42]美丽的女孩[02:26.42]ခ်စ္ပါရေစေတာ့ကြယ္[02:27.35]让我爱上你吧[02:27.35]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[02:53.62]有种不同寻常的美[02:53.62]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[02:59.63]一定是你前世修来的[02:59.63]႐ူးခဲ့ရသူ ရင္ထဲလည္း[02:60.62]内心疯狂的想念你[02:60.62]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[02:66.42]每分每秒都在想你[02:66.42]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[02:69.92]你就像校园里的女神一样[02:69.92]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[02:76.1]你是世上最美的女孩[02:76.1]အရမ္းလွတဲ့သူ မ ရယ္[02:77.75]美丽的女孩[02:77.75]ခ်စ္ပါရေစေတာ့ကြယ္[02:80.02]让我爱上你吧[02:80.02]ထူးျခားလြန္းတဲ့ မရဲ႕အလွေတြလည္း[02:85.43]有种不同寻常的美[02:85.43]ဟိုးေရွးဘ၀ကေတာင္းဆုျဖစ္မယ္[02:88.47]一定是你前世修来的[02:88.47]႐ူးခဲ့ရသူ ရင္ထဲလည္း[03:00.55]内心疯狂的想念你[03:00.55]မရဲ႕အေၾကာင္းေတြ အခ်ိန္တိုင္းပဲ[03:25.13]每分每秒都在想你[03:25.13]ေက်ာင္း၀န္းထဲက အလွနတ္သမီးေတြလည္း[03:40.78]你就像校园里的女神一样[03:40.78]မရဲ႕အလွကုိ လံုး၀မမီွႏိုင္တယ္[03:66.85]你是世上最美的女孩[03:66.85]အရမ္းလွတဲ့သူ မ ရယ္[03:72.58]美丽的女孩[03:72.58]ခ်စ္ပါရေစေတာ့ကြယ္[03:78.85]让我爱上你吧[03:78.85]ေက်းဇူးျပဳ၍ မရက္စက္လိုက္ပါနဲ႔[03:84.72]请不要拒绝我'</span>,</span><br><span class="line"><span class="comment">//theme: '#b7daff', //音频时的主题色</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>更多参见<a href="https://aplayer.js.org/#/zh-Hans/?id=%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">Aplayer 官网</a></li></ul><h1 id="三、-添加到侧边栏"><a href="#三、-添加到侧边栏" class="headerlink" title="三、 添加到侧边栏"></a>三、 添加到侧边栏</h1><p>将外链插入到Hexo根路径的侧边栏文件中： <code>themes/next/layout/_macro/sidebar.swig</code> ，即侧边栏友情链接 <code>theme.links</code> 这一项之后。</p><blockquote><p>后更换到 <code>themes/next/layout/_layout.swig</code>  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.links %&#125;</span><br><span class="line">....省略部分代码</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 音乐 插件 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"aplayer"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/APlayer.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/music.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 音乐 插件 --&gt;</span><br></pre></td></tr></table></figure><h1 id="四、-修改搜索器"><a href="#四、-修改搜索器" class="headerlink" title="四、 修改搜索器"></a>四、 修改搜索器</h1><p>有了<a href="https://github.com/maicong/music" target="_blank" rel="noopener">音乐搜索器</a> 当然要稍稍修改下，使其用起来更便利些。<br>由于是PHP代码，自然不能在静态博客上使用，所以~~<del>（爱怎么搭怎么搭吧）</del></p><details><br><summary>修改 <code>template\index.php</code>文件，找到id为 <code>j-main</code>的form 【此处折叠】 </summary><br><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"j-main"</span> <span class="attr">class</span>=<span class="string">"am-form am-u-md-12 am-u-sm-centered music-main"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"j-back"</span> <span class="attr">class</span>=<span class="string">"am-btn am-btn-success am-btn-lg am-btn-block am-radius am-margin-bottom-lg"</span>&gt;</span>成功 Get &amp;#x221A; 返回继续 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-reply am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-g am-margin-bottom-sm"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐ID', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-list-ol am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-songid"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐地址', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-link am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-link"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-btn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"j-link-btn"</span> <span class="attr">class</span>=<span class="string">"am-btn am-btn-default"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-external-link"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐链接', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-music am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-src"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-btn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"j-src-btn"</span> <span class="attr">class</span>=<span class="string">"am-btn am-btn-default"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">"j-src-btn-icon"</span> <span class="attr">class</span>=<span class="string">"am-icon-external-link"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐歌词', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-file-text-o am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-lrc"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-btn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"j-lrc-btn"</span> <span class="attr">class</span>=<span class="string">"am-btn am-btn-default"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">"j-lrc-btn-icon"</span> <span class="attr">class</span>=<span class="string">"am-icon-external-link"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-g"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐名称', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-tag am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-name"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐作者', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-user am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-author"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐图片', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-tag am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-pic"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-input-group am-input-group-sm am-margin-bottom-sm"</span> <span class="attr">data-am-popover</span>=<span class="string">"&#123;content: '音乐源', trigger: 'hover'&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"am-input-group-label"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"am-icon-user am-icon-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"j-from"</span> <span class="attr">class</span>=<span class="string">"am-form-field"</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-g"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-u-lg-12"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">data-am-widget</span>=<span class="string">"accordion"</span> <span class="attr">class</span>=<span class="string">"am-accordion am-accordion-gapped"</span> <span class="attr">data-am-accordion</span>=<span class="string">'&#123;  &#125;'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">"am-accordion-item am-active"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span> <span class="attr">class</span>=<span class="string">"am-accordion-title"</span>&gt;</span></span><br><span class="line">  Aplayer ：</span><br><span class="line"><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span> <span class="attr">class</span>=<span class="string">"am-accordion-bd am-collapse am-in"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 规避 Collapase 处理有 padding 的折叠内容计算计算有误问题， 加一个容器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am-accordion-content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">rows</span>=<span class="string">"5"</span> <span class="attr">id</span>=<span class="string">"doc-ta-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"j-show"</span> <span class="attr">class</span>=<span class="string">"am-margin-vertical"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"j-player"</span> <span class="attr">class</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br></details><details><br><summary>修改 <code>static\music.js</code>文件，找到定义<code>setValue</code>函数的位置，在代码块中追加 【此处折叠】 </summary><br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#j-pic'</span>).val(data.pic);</span><br><span class="line">$(<span class="string">'#j-from'</span>).val(data.type);</span><br><span class="line">$(<span class="string">'#doc-ta-1'</span>).val(</span><br><span class="line"><span class="string">'name: "'</span>+ data.title +<span class="string">'",\n'</span>+</span><br><span class="line"><span class="string">'artist: "'</span>+ data.author +<span class="string">'",\n'</span>+</span><br><span class="line"><span class="string">'url: "'</span>+ data.url +<span class="string">'",\n'</span>+</span><br><span class="line"><span class="string">'cover: "'</span>+ data.pic +<span class="string">'",\n'</span>+</span><br><span class="line"><span class="string">'lrc: "'</span>+ data.lrc.replace(<span class="regexp">/\n|\r/g</span>,<span class="string">""</span>) +<span class="string">'",\n'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br></details><h1 id="五、-参考"><a href="#五、-参考" class="headerlink" title="五、 参考"></a>五、 参考</h1><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md" target="_blank" rel="noopener">GitHub-aplayer</a><br><a href="https://www.jianshu.com/p/f1005ae09e5a" target="_blank" rel="noopener">简书 - Hexo添加Aplayer播放器</a><br><a href="https://www.jianshu.com/p/822a1a12d471" target="_blank" rel="noopener">简书 - Hexo增加APlayer音乐播放功能</a><br><a href="https://www.jianshu.com/p/26a7fc7cc185" target="_blank" rel="noopener">简书 - Hexo博客中插入音乐/视频/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待办</title>
      <link href="/20190609/%E5%BE%85%E5%8A%9E/"/>
      <url>/20190609/%E5%BE%85%E5%8A%9E/</url>
      
        <content type="html"><![CDATA[<p>hexo博客安装RSS插件<br><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a><br><a href="https://blog.csdn.net/u011303443/article/details/52333695" target="_blank" rel="noopener">https://blog.csdn.net/u011303443/article/details/52333695</a><br><a href="https://www.jianshu.com/p/a79422ab2013" target="_blank" rel="noopener">https://www.jianshu.com/p/a79422ab2013</a></p><p>hexo博客安装Search插件<br><a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">https://github.com/wzpan/hexo-generator-search</a></p><p>图标<br><a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">https://fontawesome.com/icons?from=io</a></p><p>安装 NexT<br><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html#menu-settings</a></p><a id="more"></a><ul><li><a href="http://www.bitbug.net/" target="_blank" rel="noopener">比特虫-在线制作ico图标</a></li><li><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">Hexo的Next主题详细配置</a></li><li><a href="https://zhuanlan.zhihu.com/p/71164003?from_voters_page=true" target="_blank" rel="noopener">Github+Hexo一站式部署个人博客 (原创)</a></li><li><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="https://github.com/liaoyajun/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a></li><li><a href="https://hfanss.com/2018/腾讯云COS-本地图片上传.html" target="_blank" rel="noopener">腾讯云COS图床制作</a></li><li><a href="https://hfanss.com/2018/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo博客常用插件及教程</a></li><li><a href="https://www.mscoder.cn/program/hexo-disable-scrollbar/" target="_blank" rel="noopener">Next主题 禁用代码段.code pre滚动条以及自动换行</a></li><li><a href="https://www.jianshu.com/p/5017abb0d0a2" target="_blank" rel="noopener">Hexo 美化</a> <blockquote><p>/layout/_partials/header/brand.swig<br>/source/css/_custom/custom.styl<br>/source/js/custom.js<br>/layout/_script/commons.swig</p></blockquote></li><li><a href="https://blog.csdn.net/qq_36759224/article/details/86936453" target="_blank" rel="noopener">免费CDN：jsDelivr+Github 使用方法</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo过滤文章</title>
      <link href="/20190609/hexo%E8%BF%87%E6%BB%A4%E6%96%87%E7%AB%A0/"/>
      <url>/20190609/hexo%E8%BF%87%E6%BB%A4%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>转载 <a href="https://github.com/Jamling/hexo-generator-index2/blob/master/README_zh.md" target="_blank" rel="noopener">hexo-generator-index2</a></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>带过滤功能的Hexo首页生成器插件。在官方的首页生成器基础上添加了过滤指定分类/标签的功能。比如，在首页只显示指定分类下面的文章列表。 除此之外，它还在指定的目录下生成指定类型的文章，比如在web目录下生成Web相关的文章。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>$ npm install hexo-generator-index2 --save$ npm unnstall hexo-generator-index --save</code></pre><p><a href="https://github.com/Jamling/hexo-generator-index2" target="_blank" rel="noopener">hexo-generator-index2</a>可以完全替代官方的<a href="https://github.com/hexojs/hexo-generator-index" target="_blank" rel="noopener">hexo-generator-index</a>，所以安装之后，先卸载官方的插件，不然会引起一些冲突。</p><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><pre><code># index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: true # defult is true# 配置index2 generator，可以是数组或对象index2_generator:    per_page: 10    order_by: -date    include:        - category Web # 只包含Web分类下的文章    exclude:        - tag hide # 不包含标签为hide的文章</code></pre><ul><li><strong>per_page</strong>: 每页显示的帖子. (0 = 禁用分页)</li><li><strong>order_by</strong>: 排序 Posts. (默认情况下按日期降序排序)</li><li><strong>layout</strong>: 设置 layout, 默认为 <code>index</code></li><li><strong>path</strong>: 输出路径, 如果路径是 <code>&#39;&#39;</code>, 表示输出到根目录 (<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a> )</li><li><strong>index</strong>: Home index or not, if <code>true</code> and the path is <code>&#39;&#39;</code>, same to offical <a href="https://github.com/hexojs/hexo-generator-index" target="_blank" rel="noopener">hexo-generator-index</a></li><li><strong>include</strong>: 帖子过滤器包括选项</li><li><strong>exclude</strong>: 帖子过滤器排除选项</li></ul><p>除了include和exclude，其它如<em>per_page</em>和<em>order_by</em>都是原有的官方首页生成器选项，不必更改。</p><p>Include/exclude 选项格式为<code>属性 值</code>（注意，属性与值中间有个英文的空格），可选的属性有：</p><ul><li>category: 文章分类</li><li>tag: 文章标签</li><li>path: 文章源路径</li></ul><hr><h1 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h1><ol><li>正如安装时所说，index和index2不能同时存在；</li><li>配置时注意<code>include</code>和<code>exclude</code>两个选项，它们的属性最好保留，这样只需要在需要过滤掉的文章里添加 <code>tag: hide</code></li></ol><hr><p>参考文章：<a href="https://github.com/Jamling/hexo-generator-index2/blob/master/README_zh.md" target="_blank" rel="noopener">过滤插件-Git</a></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django前言</title>
      <link href="/20190609/django%E5%89%8D%E8%A8%80/"/>
      <url>/20190609/django%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><a href="精通Django.pdf"></a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/20190420/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/20190420/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#前言">前言</a></li><li><a href="#第一部分数据结构">第一部分：数据结构</a><ul><li><a href="#一线性表">一、线性表</a></li><li><a href="#二栈和队列">二、栈和队列</a></li><li><a href="#三树和二叉树">三、树和二叉树</a><ul><li><a href="#1-红黑树">1. 红黑树</a></li><li><a href="#2-二叉树">2. 二叉树</a><ul><li><a href="#二分查找法">二分查找法</a></li><li><a href="#二叉树遍历">二叉树遍历</a></li></ul></li><li><a href="#3-二分搜索树">3. 二分搜索树</a><ul><li><a href="#深度优先遍历前序中序后序遍历">深度优先遍历（前序、中序、后序遍历）</a></li><li><a href="#广度优先遍历层序遍历">广度优先遍历（层序遍历）</a></li></ul></li><li><a href="#4-avl树">4. AVL树</a></li><li><a href="#5-b和b">5. B和B+</a></li></ul></li><li><a href="#四字符串和数组">四、字符串和数组</a></li></ul></li><li><a href="#第二部分算法思想">第二部分：算法思想</a><ul><li><a href="#一排序">一、排序</a><ul><li><a href="#1-选择排序selection-sort">1. 选择排序（Selection Sort）</a></li><li><a href="#2-插入排序insertion-sort">2. 插入排序（Insertion Sort）</a></li><li><a href="#3-冒泡排序bubble-sort">3. 冒泡排序（Bubble Sort）</a></li><li><a href="#4-希尔排序shell-sort">4. 希尔排序（Shell Sort）</a></li><li><a href="#5-归并排序merge-sort">5. 归并排序（Merge Sort）</a></li><li><a href="#6-快速排序quick-sort">6. 快速排序（Quick Sort）</a><ul><li><a href="#1-普通快速排序">1. 普通快速排序</a></li><li><a href="#2-双路快速排序">2. 双路快速排序</a></li><li><a href="#3-三路快速排序">3. 三路快速排序</a></li></ul></li><li><a href="#7-堆排序heap-sort">7. 堆排序（Heap Sort）</a><ul><li><a href="#1-堆">1. 堆</a></li><li><a href="#2-上浮和下沉">2. 上浮和下沉</a></li><li><a href="#3插入元素">3.插入元素</a></li><li><a href="#4-删除最大元素">4. 删除最大元素</a></li><li><a href="#5-堆排序">5. 堆排序</a></li><li><a href="#6-堆排序的应用top-k问题">6. 堆排序的应用——Top K问题</a></li></ul></li><li><a href="#8-计数排序和流排序">8. 计数排序和流排序</a></li><li><a href="#9-排序算法总结">9. 排序算法总结</a></li></ul></li><li><a href="#二递归和回溯法">二、递归和回溯法</a><ul><li><a href="#1-例题">1. 例题</a></li><li><a href="#2-排列问题">2. 排列问题</a></li><li><a href="#3-组合问题">3. 组合问题</a></li><li><a href="#4-回溯法的剪枝">4. 回溯法的剪枝</a></li><li><a href="#5-二维平面回溯法">5. 二维平面回溯法</a></li><li><a href="#6-floodfill算法">6. floodfill算法</a></li></ul></li><li><a href="#三动态规划">三、动态规划</a><ul><li><a href="#1-斐波那契数列">1. 斐波那契数列</a><ul><li><a href="#11-递归方式自顶向下">1.1 递归方式（自顶向下）</a></li><li><a href="#12-记忆化搜索自底向上">1.2 记忆化搜索（自底向上）</a></li><li><a href="#13-动态规划">1.3 动态规划</a></li></ul></li><li><a href="#2-背包问题">2. 背包问题</a><ul><li><a href="#1记忆化搜索">（1）记忆化搜索</a></li><li><a href="#2动态规划">（2）动态规划</a></li><li><a href="#3动态规划优化思路1">（3）动态规划优化思路1</a></li><li><a href="#4动态规划优化思路2">（4）动态规划优化思路2</a></li><li><a href="#5背包问题更多变种">（5）背包问题更多变种</a></li></ul></li><li><a href="#3-最长上升子序列">3. 最长上升子序列</a></li><li><a href="#4-最长公共子序列">4. 最长公共子序列</a></li></ul></li><li><a href="#四贪心算法">四、贪心算法</a><ul><li><a href="#1-assign-cookies">1. assign-cookies</a></li></ul></li></ul></li><li><a href="#第三部分面试指南">第三部分：面试指南</a><ul><li><a href="#1-判单链表是否对称">1. 判单链表是否对称</a></li><li><a href="#2-合并两个有序数组成一个有序数组">2. 合并两个有序数组成一个有序数组</a></li><li><a href="#3-求二叉树中值为x的结点的层号">3. 求二叉树中值为x的结点的层号</a></li><li><a href="#阿里面经onenote">阿里面经OneNote</a></li></ul></li><li><a href="#第四部分参考资料">第四部分：参考资料</a></li></ul><!-- /TOC --><p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将系统总结算法面试和经典数据结构相关知识点，在这里分成 【数据结构】 和 【算法】 两部分展开。这里将展示主要的核心知识点，关于代码面试的Leetcode习题请转向代码仓库：<a href="https://github.com/frank-lam/interview_code" target="_blank" rel="noopener">Interview-code</a></p><ul><li><p>阅读书籍</p><ul><li>《算法4》</li><li>《程序员代码面试指南》</li><li>《剑指Offer》</li></ul></li><li><p>学习课程</p><ul><li>刘宇波：玩转数据结构，从入门到进阶</li><li>刘宇波：程序员的内功修炼，学好算法与数据结构</li><li>刘宇波：玩转算法面试 leetcode题库分门别类详细解析</li></ul></li><li><p>在线OJ</p><ul><li><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">Leetcode中国版</a></li><li><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></li></ul></li></ul><h1 id="第一部分：数据结构"><a href="#第一部分：数据结构" class="headerlink" title="第一部分：数据结构"></a>第一部分：数据结构</h1><h2 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h2><ul><li>数组</li><li>链表</li></ul><h2 id="二、栈和队列"><a href="#二、栈和队列" class="headerlink" title="二、栈和队列"></a>二、栈和队列</h2><h2 id="三、树和二叉树"><a href="#三、树和二叉树" class="headerlink" title="三、树和二叉树"></a>三、树和二叉树</h2><h3 id="1-2-3树"><a href="#1-2-3树" class="headerlink" title="1. 2-3树"></a>1. 2-3树</h3><h3 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2. 红黑树"></a>2. 红黑树</h3><p>红黑树的特性: </p><p>（1）每个节点或者是黑色的，或者是红色的</p><p>（2）根节点是黑色的</p><p>（3）每个叶子节点（NIL，最后的空结点）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] </p><p>（4）如果一个节点是红色的，那么他的孩子结点都是黑色的</p><p>（5）从任意一个节点到叶子节点，经过的黑色节点是一样的。[这里也就可以得到插入的节点必然为红色]</p><p>红黑树(一)之 原理和算法详细介绍 - 如果天空不死 - 博客园<br><a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3245399.html</a></p><p>JCFInternals/5-TreeSet and TreeMap.md at 049c84bb65a3114ba4b8355d83c490fb9b26c6af · CarpenterLee/JCFInternals<br><a href="https://github.com/CarpenterLee/JCFInternals/blob/049c84bb65a3114ba4b8355d83c490fb9b26c6af/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/049c84bb65a3114ba4b8355d83c490fb9b26c6af/markdown/5-TreeSet%20and%20TreeMap.md</a></p><h3 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3. 二叉树"></a>3. 二叉树</h3><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h3 id="4-二分搜索树"><a href="#4-二分搜索树" class="headerlink" title="4.. 二分搜索树"></a>4.. 二分搜索树</h3><h4 id="深度优先遍历（前序、中序、后序遍历）"><a href="#深度优先遍历（前序、中序、后序遍历）" class="headerlink" title="深度优先遍历（前序、中序、后序遍历）"></a>深度优先遍历（前序、中序、后序遍历）</h4><h4 id="广度优先遍历（层序遍历）"><a href="#广度优先遍历（层序遍历）" class="headerlink" title="广度优先遍历（层序遍历）"></a>广度优先遍历（层序遍历）</h4><h3 id="5-AVL树"><a href="#5-AVL树" class="headerlink" title="5. AVL树"></a>5. AVL树</h3><h3 id="6-B和B"><a href="#6-B和B" class="headerlink" title="6. B和B+"></a>6. B和B+</h3><h2 id="四、字符串和数组"><a href="#四、字符串和数组" class="headerlink" title="四、字符串和数组"></a>四、字符串和数组</h2><h1 id="第二部分：算法思想"><a href="#第二部分：算法思想" class="headerlink" title="第二部分：算法思想"></a>第二部分：算法思想</h1><h2 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h2><h3 id="1-选择排序（Selection-Sort）"><a href="#1-选择排序（Selection-Sort）" class="headerlink" title="1. 选择排序（Selection Sort）"></a>1. 选择排序（Selection Sort）</h3><p>选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。 </p><p><img data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt=""></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 寻找[i, n)区间里的最小值的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap( arr , i , minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="2-插入排序（Insertion-Sort）"><a href="#2-插入排序（Insertion-Sort）" class="headerlink" title="2. 插入排序（Insertion Sort）"></a>2. 插入排序（Insertion Sort）</h3><p>插入排序从左到右进行，每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左部数组依然有序。</p><p>第 j 元素是通过不断向左比较并交换来实现插入过程：当第 j 元素小于第 j - 1 元素，就将它们的位置交换，然后令 j 指针向左移动一个位置，不断进行以上操作。</p><p><img data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt=""></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">                swap(arr, j, j - <span class="number">1</span>); <span class="comment">// 大量的交换会消耗时间</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版插入排序（减少了数组元素的操作次数）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">better_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="3-冒泡排序（Bubble-Sort）"><a href="#3-冒泡排序（Bubble-Sort）" class="headerlink" title="3. 冒泡排序（Bubble Sort）"></a>3. 冒泡排序（Bubble Sort）</h3><p>通过从左到右不断交换相邻逆序的相邻元素，在一轮的交换之后，可以让未排序的元素上浮到右侧。</p><p>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。</p><p><img data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt=""></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 从最后一位开始确定</span></span><br><span class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swapped = <span class="keyword">true</span>;</span><br><span class="line">                swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!swapped)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>算法描述</strong></p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><p><img data-src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt=""></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = n / <span class="number">2</span>; h &gt; <span class="number">0</span>; h = h / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 内部是一个插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i = i + h) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; <span class="number">0</span>; j = j - h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; arr[j - h])</span><br><span class="line">                    arr[j] = arr[j - h];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">// 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// h-sort the array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span></span><br><span class="line">            <span class="keyword">int</span> e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p><p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h3><p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。</p><p><img data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt=""></p><p><strong>代码实现</strong></p><blockquote><p>1.归并方法</p><p>归并方法将数组中两个已经排序的部分归并成一个。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    __MergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">__MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    __MergeSort(arr, l, mid);</span><br><span class="line">    __MergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = Arrays.copyOfRange(arr, l, r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;   <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &lt; aux[j - l]) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.自底向上归并排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz += sz)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; N; i += sz + sz)</span><br><span class="line">            merge(arr, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h3><p>快速排序可以说是20世纪最伟大的算法之一了。相信都有所耳闻，它的速度也正如它的名字那样，是一个非常快的算法了。当然它也后期经过了不断的改进和优化，才被公认为是一个值得信任的非常优秀的算法。</p><p><img data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt=""></p><p><strong>代码实现</strong></p><h4 id="1-普通快速排序"><a href="#1-普通快速排序" class="headerlink" title="1. 普通快速排序"></a>1. 普通快速排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr,l,r);</span><br><span class="line">    QuickSort(arr,l,p-<span class="number">1</span>);</span><br><span class="line">    QuickSort(arr,p+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组通过p分割成两部分</span></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    swap(arr, l, (<span class="keyword">int</span>) (Math.random() % (r - l + <span class="number">1</span>)) + l);  <span class="comment">// 加入这一行变成随机快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = j +<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,l,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p><p>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><h4 id="2-双路快速排序"><a href="#2-双路快速排序" class="headerlink" title="2. 双路快速排序"></a>2. 双路快速排序</h4><p>若果数组中含有大量重复的元素，则partition很可能把数组划分成两个及其不平衡的两部分，时间复杂度退化成O(n²)。这时候应该把小于v和大于v放在数组两端。</p><p><img data-src="pics/partition2.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双路快速排序的partition</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    <span class="comment">// swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0</span></span><br><span class="line">        <span class="comment">// 思考一下为什么?</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= r &amp;&amp; arr[i] &lt; v)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0</span></span><br><span class="line">        <span class="comment">// 思考一下为什么?</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= l + <span class="number">1</span> &amp;&amp; arr[j] &gt; v)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)</span></span><br><span class="line">        <span class="comment">// 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort2Ways</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">    QuickSort2Ways(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    QuickSort2Ways(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-三路快速排序"><a href="#3-三路快速排序" class="headerlink" title="3. 三路快速排序"></a>3. 三路快速排序</h4><p>数组分成三个部分，大于v 等于v 小于v</p><p>在具有大量重复键值对的情况下使用三路快排</p><p><img data-src="pics/partition3.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort3Ways</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr, l, (<span class="keyword">int</span>)(Math.random()*(r-l+<span class="number">1</span>)) + l );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="keyword">while</span>( i &lt; gt )&#123;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v)&#123;</span><br><span class="line">            swap( arr, i, lt+<span class="number">1</span>);</span><br><span class="line">            i ++;</span><br><span class="line">            lt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( arr[i] &gt; v )&#123;</span><br><span class="line">            swap( arr, i, gt-<span class="number">1</span>);</span><br><span class="line">            gt --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// arr[i] == v</span></span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap( arr, l, lt );</span><br><span class="line"></span><br><span class="line">    QuickSort3Ways(arr, l, lt-<span class="number">1</span>);</span><br><span class="line">    QuickSort3Ways(arr, gt, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h3><h4 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h4><p>堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。</p><p>堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><p><img data-src="pics/heap.png" alt=""></p><h4 id="2-上浮和下沉"><a href="#2-上浮和下沉" class="headerlink" title="2. 上浮和下沉"></a>2. 上浮和下沉</h4><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为<strong>上浮（ShiftUp）</strong>。</p><p><img data-src="pics/shiftup_heap.png" alt=""> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k]))&#123;</span><br><span class="line">        swap(k, k/<span class="number">2</span>);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为<strong>下沉（Shift Down）</strong>。一个节点如果有两个子节点，应当与两个子节点中最大那么节点进行交换。</p><p><img data-src="pics/shiftdown_heap.png" alt=""> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123; <span class="comment">// 当前结点有左孩子</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] )</span><br><span class="line">            j ++;</span><br><span class="line">        <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( data[k] &gt;= data[j] ) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h4><p>将新元素放到数组末尾，然后上浮到合适的位置。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向最大堆中插入一个新的元素 item</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> count + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">    data[count+<span class="number">1</span>] = item;</span><br><span class="line">    count ++;</span><br><span class="line">    shiftUp(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4. 删除最大元素"></a>4. 删除最大元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">    Item ret = data[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    swap( <span class="number">1</span> , count );</span><br><span class="line">    count --;</span><br><span class="line">    shiftDown(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h4><p>由于堆可以很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列。因此很容易使用堆来进行排序。并且堆排序是原地排序，不占用额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对整个arr数组使用HeapSort1排序</span></span><br><span class="line">    <span class="comment">// HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line">    <span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line">    <span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        MaxHeap&lt;Comparable&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;Comparable&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            maxHeap.insert(arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = n-<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只通过shiftDown操作进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，此时我们的堆是从0开始索引的</span></span><br><span class="line">        <span class="comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">        <span class="comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = (n-<span class="number">1</span>-<span class="number">1</span>)/<span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">            shiftDown2(arr, n, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span> ; i-- )&#123; <span class="comment">// 这个的目的是让序列从小到大排序</span></span><br><span class="line">            swap( arr, <span class="number">0</span>, i);</span><br><span class="line">            shiftDown2(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始的shiftDown过程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>].compareTo(arr[j]) &gt; <span class="number">0</span> )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( arr[k].compareTo(arr[j]) &gt;= <span class="number">0</span> )<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( arr, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span></span><br><span class="line">    <span class="comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftDown2</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparable e = arr[k];</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>].compareTo(arr[j]) &gt; <span class="number">0</span> )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( e.compareTo(arr[j]) &gt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            arr[k] = arr[j];</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[k] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 HeapSort</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">10</span>, <span class="number">91</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        HeapSort.sort2(arr);</span><br><span class="line">        PrintHelper.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-堆排序的应用——Top-K问题"><a href="#6-堆排序的应用——Top-K问题" class="headerlink" title="6. 堆排序的应用——Top K问题"></a>6. 堆排序的应用——Top K问题</h4><p>例如，有1亿个浮点数，如何找出其中最大的10000个？（B326）</p><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p><a href="https://www.cnblogs.com/freedom314/p/5847092.html" target="_blank" rel="noopener">https://www.cnblogs.com/freedom314/p/5847092.html</a></p><h3 id="9-排序算法总结"><a href="#9-排序算法总结" class="headerlink" title="9. 排序算法总结"></a>9. 排序算法总结</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">原地排序</th><th style="text-align:center">额外空间</th><th style="text-align:center">稳定排序</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">√</td><td style="text-align:center">O(1)</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">×</td><td style="text-align:center">O(n)</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">√</td><td style="text-align:center">O(logn)</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">√</td><td style="text-align:center">O(1)</td><td style="text-align:center">×</td></tr></tbody></table><p>稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以通过⾃自定义⽐比较函数，让排序算法不不存在稳定性的问题。</span></span><br><span class="line">bool operator&lt;(<span class="keyword">const</span> Student&amp; otherStudent)&#123;</span><br><span class="line">    <span class="keyword">return</span> score != otherStudent.score ?</span><br><span class="line">    score &gt; otherStudent.score :</span><br><span class="line">    name &lt; otherStudent.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="pics/sort_algorithm_analyze.png" alt=""> </p><h2 id="二、递归和回溯法"><a href="#二、递归和回溯法" class="headerlink" title="二、递归和回溯法"></a>二、递归和回溯法</h2><h3 id="1-例题"><a href="#1-例题" class="headerlink" title="1. 例题"></a>1. 例题</h3><h3 id="2-排列问题"><a href="#2-排列问题" class="headerlink" title="2. 排列问题"></a>2. 排列问题</h3><h3 id="3-组合问题"><a href="#3-组合问题" class="headerlink" title="3. 组合问题"></a>3. 组合问题</h3><h3 id="4-回溯法的剪枝"><a href="#4-回溯法的剪枝" class="headerlink" title="4. 回溯法的剪枝"></a>4. 回溯法的剪枝</h3><h3 id="5-二维平面回溯法"><a href="#5-二维平面回溯法" class="headerlink" title="5. 二维平面回溯法"></a>5. 二维平面回溯法</h3><h3 id="6-floodfill算法"><a href="#6-floodfill算法" class="headerlink" title="6. floodfill算法"></a>6. floodfill算法</h3><h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><p>递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。 </p><p>动态规划一般可分为4类：</p><ol><li>线性动规</li><li>区域动规</li><li>树形动规</li><li>背包动规</li></ol><p>以<code>198. House Robber</code>为例，动态规划的<strong>状态定义</strong>和<strong>状态转移方程</strong>如下：</p><p>注意其中对状态的<strong>定义</strong>：</p><ul><li>考虑偷取 [x…n-1] 范围⾥里里的房子 （函数的定义）</li></ul><p>根据对状态的定义，决定状态的<strong>转移</strong>：</p><ul><li><p>f(0) = max{ v(0) + f(2) , v(1) + f(3) , v(2) + f(4) , … ,v(n-3) + f(n-1) , v(n-2),v(n-1) }</p><p>(状态转移方程)</p></li></ul><p><img data-src="pics/dynamic_programming.png" alt=""></p><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h3><h4 id="1-1-递归方式（自顶向下）"><a href="#1-1-递归方式（自顶向下）" class="headerlink" title="1.1 递归方式（自顶向下）"></a>1.1 递归方式（自顶向下）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">fib(<span class="number">42</span>) = <span class="number">267914296</span></span><br><span class="line">time : <span class="number">1949</span> ms</span><br><span class="line"><span class="function">run function <span class="title">fib</span><span class="params">()</span> 866988873 times.</span></span><br></pre></td></tr></table></figure><h4 id="1-2-记忆化搜索（自底向上）"><a href="#1-2-记忆化搜索（自底向上）" class="headerlink" title="1.2 记忆化搜索（自底向上）"></a>1.2 记忆化搜索（自底向上）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> fib(n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] == -<span class="number">1</span>)</span><br><span class="line">        memo[n] = fib(n - <span class="number">1</span>, memo) + fib(n - <span class="number">2</span>, memo);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">fib(<span class="number">1000</span>) = <span class="number">1556111435</span></span><br><span class="line">time : <span class="number">1</span> ms</span><br><span class="line"><span class="function">run function <span class="title">fib</span><span class="params">()</span> 1999 times.</span></span><br></pre></td></tr></table></figure><h4 id="1-3-动态规划"><a href="#1-3-动态规划" class="headerlink" title="1.3 动态规划"></a>1.3 动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i ++)</span><br><span class="line">        memo[i] = memo[i - <span class="number">1</span>] + memo[i - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. 背包问题</h3><p>先得到该问题的局部解然后扩展到全局问题解。</p><p>我们可以假设一个B(k,C) 方法，第k件物品，当前背包所剩下的容量C（初始则C=W）情况下，能够偷的最大价值量。</p><p>B( i , c ) = max{ F( i - 1 , C ) ,  v(i) + F( i - 1, C - w[i] ) };</p><h4 id="（1）记忆化搜索"><a href="#（1）记忆化搜索" class="headerlink" title="（1）记忆化搜索"></a>（1）记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记忆化搜索</span></span><br><span class="line"><span class="comment"> * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积</span></span><br><span class="line"><span class="comment"> * 空间复杂度: O(n * C)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][C + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bestValue(w, v, n - <span class="number">1</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 [0...index]的物品,填充容积为c的背包的最大价值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bestValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> i, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || C &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memo[i][C] != -<span class="number">1</span>) <span class="comment">// 记忆化搜索</span></span><br><span class="line">            <span class="keyword">return</span> memo[i][C];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res = bestValue(w, v, i - <span class="number">1</span>, C);</span><br><span class="line">        <span class="keyword">if</span> (C &gt;= w[i])</span><br><span class="line">            res = max(res, v[i] + bestValue(w, v, i - <span class="number">1</span>, C - w[i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[i][C] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">50</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution01().knapsack(w, v, <span class="number">10</span>));</span><br><span class="line">        System.out.println(<span class="string">"count of bestValue() exec："</span> + count);</span><br><span class="line">        PrintHelper.print2DArray(memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）动态规划"><a href="#（2）动态规划" class="headerlink" title="（2）动态规划"></a>（2）动态规划</h4><p><div align="center"> <img data-src="pics/knapsack-01.png" width=""></div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积</span></span><br><span class="line"><span class="comment"> * 空间复杂度: O(n * C)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][C + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || C == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++)</span><br><span class="line">            memo[<span class="number">0</span>][j] = (j &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123;</span><br><span class="line">                memo[i][j] = memo[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">                    memo[i][j] = max(memo[i][j], v[i] + memo[i - <span class="number">1</span>][j - w[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[n - <span class="number">1</span>][C];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">6</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> C = <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution02().knapsack(w, v, C));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）动态规划优化思路1"><a href="#（3）动态规划优化思路1" class="headerlink" title="（3）动态规划优化思路1"></a>（3）动态规划优化思路1</h4><p>优化思路：第i行元素只依赖于第i-1行元素，理论上，只需要保持两行元素即可</p><p><div align="center"> <img data-src="pics/knapsack-optimized1.png" width=""></div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 动态规划改进: 滚动数组</span></span><br><span class="line"><span class="comment">/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积</span></span><br><span class="line"><span class="comment">/// 空间复杂度: O(C), 实际使用了2*C的额外空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack01</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(w == <span class="keyword">null</span> || v == <span class="keyword">null</span> || w.length != v.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid w or v"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(C &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"C must be greater or equal to zero."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || C == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][C + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= C ; j ++)</span><br><span class="line">            memo[<span class="number">0</span>][j] = (j &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= C ; j ++)&#123;</span><br><span class="line">                memo[i % <span class="number">2</span>][j] = memo[(i-<span class="number">1</span>) % <span class="number">2</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">                    memo[i % <span class="number">2</span>][j] = Math.max(memo[i % <span class="number">2</span>][j], v[i] + memo[(i-<span class="number">1</span>) % <span class="number">2</span>][j - w[i]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[(n-<span class="number">1</span>) % <span class="number">2</span>][C];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）动态规划优化思路2"><a href="#（4）动态规划优化思路2" class="headerlink" title="（4）动态规划优化思路2"></a>（4）动态规划优化思路2</h4><p><div align="center"> <img data-src="pics/knapsack-optimized2.png" width=""></div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 动态规划改进</span></span><br><span class="line"><span class="comment">/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积</span></span><br><span class="line"><span class="comment">/// 空间复杂度: O(C), 只使用了C的额外空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack01</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(w == <span class="keyword">null</span> || v == <span class="keyword">null</span> || w.length != v.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid w or v"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(C &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"C must be greater or equal to zero."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || C == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[C+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= C ; j ++)</span><br><span class="line">            memo[j] = (j &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = C ; j &gt;= w[i] ; j --)</span><br><span class="line">                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[C];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（5）背包问题更多变种"><a href="#（5）背包问题更多变种" class="headerlink" title="（5）背包问题更多变种"></a>（5）背包问题更多变种</h4><ul><li>多重背包问题：每个物品不不⽌止1个，有num(i)个</li><li>完全背包问题：每个物品可以⽆无限使⽤用</li><li>多维费⽤用背包问题：要考虑物品的体积和重量量两个维度？</li><li>物品间加⼊入更更多约束：物品间可以互相排斥；也可以互相依赖</li></ul><h3 id="3-最长上升子序列"><a href="#3-最长上升子序列" class="headerlink" title="3. 最长上升子序列"></a>3. 最长上升子序列</h3><p><strong>Longest Increasing Subsequence (LIS)</strong></p><p><strong>【Leetcode 300】最长上升子序列</strong> </p><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(<em>n2</em>) 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p><p>LIS( i ) 表示以第 i 个数字为结尾的最长上升子序列的长度</p><p>LIS( i ) 表示 [0…i] 的范围内，选择数字nums[i]可以获得的最长上升子序列的长度</p><p>LIS ( i )  =   max<sub>j&lt;i</sub>( 1 + LIS( j ) if nums[i] &gt; nums[j] )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    memo[i] = max(memo[i] , memo[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res = max(memo[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().lengthOfLIS(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里思考一个问题：在上面的代码中只求解出了上升子序列的长度，那么如何求出具体的上升子序列呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; LISindex = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录一下有几个上升子序列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; lengthOfLIS(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    memo[i] = max(memo[i], memo[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = max(memo[i], res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[i] == res)</span><br><span class="line">                LISindex.add(i); <span class="comment">// 遍历一下最长子序列最后一位是谁，统计一共有多少个子序列</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lastIndex : LISindex) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> nowMemoCount = memo[lastIndex];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lastIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nowMemoCount - memo[i] == <span class="number">1</span> || nowMemoCount - memo[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    nowMemoCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resList.add(reverseList(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">reverseList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            newList.add(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution2().lengthOfLIS(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最长公共子序列"><a href="#4-最长公共子序列" class="headerlink" title="4. 最长公共子序列"></a>4. 最长公共子序列</h3><p><strong>Longest Common Sequence (LCS)</strong>：给出两个字符串S1和S2，求这两个字符串的最长公共子序列的长度</p><p>LCS( m , n ) S1[0…m] 和 S2[0…n] 的最长公共子序列的长度</p><p><strong>S1[m] == S2[n] :</strong>  </p><p>LCS(m,n) = 1 + LCS(m-1,n-1) </p><p><strong>S1[m] != S2[n] :</strong>   </p><p>LCS(m,n) = max( LCS(m-1,n) , LCS(m,n-1) )</p><p><div align="center"> <img data-src="pics/LCS.png" width=""></div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长公共子序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LCS</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bestLength(s1, s2, s1.length() - <span class="number">1</span>, s2.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bestLength</span><span class="params">(String s1, String s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lcs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(m) == s2.charAt(n)) &#123;</span><br><span class="line">            lcs = <span class="number">1</span> + bestLength(s1, s2, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lcs = max(bestLength(s1, s2, m - <span class="number">1</span>, n), bestLength(s1, s2, m, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution3().LCS(<span class="string">"ABCDEE"</span>, <span class="string">"ABDCEE"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html" target="_blank" rel="noopener">动态规划解决01背包问题 - Christal_R - 博客园</a></li><li><a href="http://new-play.tudou.com/v/XMTQ3MzI0NzI2OA==.html?spm=a2h0k.8191414.0.0&amp;from=s1.8-1-1.2&amp;f=28521433" target="_blank" rel="noopener">【经典算法】01背包问题_土豆视频</a></li></ul><h2 id="四、贪心算法"><a href="#四、贪心算法" class="headerlink" title="四、贪心算法"></a>四、贪心算法</h2><h3 id="1-assign-cookies"><a href="#1-assign-cookies" class="headerlink" title="1. assign-cookies"></a>1. assign-cookies</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>注意：</strong></p><p>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = s.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &gt;= g[i])&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    s[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res =  <span class="keyword">new</span> Solution().findContentChildren(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>&#125;);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三部分：面试指南"><a href="#第三部分：面试指南" class="headerlink" title="第三部分：面试指南"></a>第三部分：面试指南</h1><h2 id="1-判单链表是否对称"><a href="#1-判单链表是否对称" class="headerlink" title="1. 判单链表是否对称"></a>1. 判单链表是否对称</h2><blockquote><p>网易有道面经</p></blockquote><p><strong>原题</strong>：设单链表中存放着 n 个字符，设计算法并判断字符是否中心对称，如 “xyzzyx” 是中心对称的。</p><p><strong>思路1</strong>：可先将字符串中的全部字符进栈，然后再将栈中的字符逐个与链表中的字符进行比较，如全部相等，则为中心对称。</p><p><strong>思路2</strong>：将单链表的前一半元素依次入栈，遍历到单链表的后一半元素的第一个元素时，便从栈中弹出一个元素，对它们俩开始比较。</p><ul><li>若相等，则将链表中的下一个元素与栈中再次弹出的元素进行比较，直至单链表到末尾，而且如果此时栈也为空栈，则可得出此单链表是中心对称的结论；</li><li>若不相等，则单链表不是中心对称。</li></ul><h2 id="2-合并两个有序数组成一个有序数组"><a href="#2-合并两个有序数组成一个有序数组" class="headerlink" title="2. 合并两个有序数组成一个有序数组"></a>2. 合并两个有序数组成一个有序数组</h2><blockquote><p>金山云面经</p></blockquote><p>有两种实现思路：</p><ol><li><p>定义一个新数组，长度为两个数组长度之和，将两个数组都 copy 到新数组，然后排序。</p></li><li><p>给两个数组分别定义一个下标，最大长度是数组长度减一，按位循环比较两个数组，较小元素的放入新数组，下标加一（注意，较大元素对应的下标不加一），直到某一个下标超过数组长度时退出循环，此时较短数组已经全部放入新数组，较长数组还有部分剩余，最后将剩下的部分元素放入新数组，大功告成。</p></li></ol><h2 id="3-求二叉树中值为x的结点的层号"><a href="#3-求二叉树中值为x的结点的层号" class="headerlink" title="3. 求二叉树中值为x的结点的层号"></a>3. 求二叉树中值为x的结点的层号</h2><blockquote><p>金山云面经</p></blockquote><p>思路：利用访问二叉树的路径过程求解（PS：这里不是说遍历过程，是访问过程，无论前中后序遍历，访问过程都是要经过通一结点三次），利用level变量记录访问过程中的层号，递归返回要减一；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">char</span> ElementType;</span><br><span class="line">typedef struct TNode *Position;</span><br><span class="line">typedef Position BinTree;</span><br><span class="line">struct TNode&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">CreatBinTree</span><span class="params">()</span></span>; <span class="comment">/* 实现细节忽略 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_in_x</span><span class="params">(BinTree BT,<span class="keyword">char</span> x,<span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    BinTree BT = CreatBinTree();</span><br><span class="line">    level_in_x(BT,<span class="string">'H'</span>,level);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态建树</span></span><br><span class="line"><span class="function">BinTree <span class="title">CreatBinTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree pa = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pb = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pc = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pd = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pe = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pf = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pg = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree ph = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">    BinTree pi = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line"></span><br><span class="line">    pa-&gt;Data = <span class="string">'A'</span>;</span><br><span class="line">    pb-&gt;Data = <span class="string">'B'</span>;</span><br><span class="line">    pc-&gt;Data = <span class="string">'C'</span>;</span><br><span class="line">    pd-&gt;Data = <span class="string">'D'</span>;</span><br><span class="line">    pe-&gt;Data = <span class="string">'E'</span>;</span><br><span class="line">    pf-&gt;Data = <span class="string">'F'</span>;</span><br><span class="line">    pg-&gt;Data = <span class="string">'G'</span>;</span><br><span class="line">    ph-&gt;Data = <span class="string">'H'</span>;</span><br><span class="line">    pi-&gt;Data = <span class="string">'I'</span>;</span><br><span class="line"></span><br><span class="line">    pa-&gt;Left = pb; pa-&gt;Right = pc;</span><br><span class="line">    pb-&gt;Left = pd; pb-&gt;Right = pf;</span><br><span class="line">    pc-&gt;Left = pg; pc-&gt;Right = pi;</span><br><span class="line">    pd-&gt;Left = NULL; pd-&gt;Right = NULL;</span><br><span class="line">    pe-&gt;Left = NULL; pe-&gt;Right = NULL;</span><br><span class="line">    pf-&gt;Left = pe; pf-&gt;Right = NULL;</span><br><span class="line">    pg-&gt;Left = NULL; pg-&gt;Right = ph;</span><br><span class="line">    ph-&gt;Left = NULL; ph-&gt;Right = NULL;</span><br><span class="line">    pi-&gt;Left = NULL; pi-&gt;Right = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_in_x</span><span class="params">(BinTree BT,<span class="keyword">char</span> x,<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BT == NULL)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(BT-&gt;Data == x)&#123;</span><br><span class="line">        printf(<span class="string">"x in %d"</span>,level);</span><br><span class="line">    &#125;</span><br><span class="line">    level++;</span><br><span class="line">    level_in_x(BT-&gt;Left,x,level);</span><br><span class="line">    level_in_x(BT-&gt;Right,x,level);</span><br><span class="line">    level--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阿里面经OneNote"><a href="#阿里面经OneNote" class="headerlink" title="阿里面经OneNote"></a>阿里面经OneNote</h2><ol><li>如何判断一个单链表是否有环？  </li><li>快速排序，过程，复杂度？什么情况下适用，什么情况下不适用？ </li><li>什么是二叉平衡树，如何插入节点，删除节点 </li><li>二分搜索的过程 </li><li>归并排序的过程？时间复杂度？空间复杂度？ </li><li>给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少 </li><li>给你一个数组，如何里面找到和为K的两个数 </li><li>100000个数找出最小或最大的10个？ </li><li>一堆数字里面继续去重，要怎么处理？阅读 RFC2616 文档，即 HTTP/1.1 规范，输入某个网址，利用 Java 的 Socket 发送 HTTP请求，特别要求能够解码 chunked 编码，观察文档中的伪代码实现，自己用Java代码实现，将解析后的整个html文档输出到控制台上，不要求关注太多细节。(就是不允许用httpclient的jar包，自行实现这个jar包类似的功能) </li></ol><h1 id="第四部分：参考资料"><a href="#第四部分：参考资料" class="headerlink" title="第四部分：参考资料"></a>第四部分：参考资料</h1><ul><li><a href="http://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">数据结构与算法系列 目录 - 如果天空不死 - 博客园</a></li><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E7%AE%97%E6%B3%95.md#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Interview-Notebook/算法.md at master · CyC2018/Interview-Notebook</a></li><li><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法</a></li><li><a href="https://visualgo.net/en" target="_blank" rel="noopener">VisuAlgo - visualising data structures and algorithms through animation</a> </li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualization</a></li><li><a href="https://www.cnblogs.com/chenhuan001/p/5866916.html" target="_blank" rel="noopener">海量数据处理：十道面试题与十个海量数据处理方法总结 - chenhuan001 - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 扉页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-search配置</title>
      <link href="/20190324/hexo-search%E9%85%8D%E7%BD%AE/"/>
      <url>/20190324/hexo-search%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">官方文档</a></p><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><hr><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>修改在根目录下的_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml </span><br><span class="line">  field: all </span><br><span class="line">  content: true</span><br></pre></td></tr></table></figure></p><a id="more"></a><ul><li>path - 文件的路径。默认是 search.xml。如果文件扩展名为 .json,则输出格式为JSON。</li><li>field - 要搜索的搜索范围：</li><li>post (Default) -  仅涵盖您博客的所有帖子。</li><li>page - 仅涵盖您博客的所有页面。</li><li>all - 将涵盖您博客的所有帖子和页面。</li><li>content - 是否包含每篇文章的全部内容。如果false，生成的结果仅覆盖没有主体的标题和其他元信息。默认是true。</li></ul><hr><h1 id="排除索引"><a href="#排除索引" class="headerlink" title="排除索引"></a>排除索引</h1><p>在文章顶部配置里加入 indexing: false </p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转载]排序算法</title>
      <link href="/20190324/%E8%BD%AC%E8%BD%BD-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/20190324/%E8%BD%AC%E8%BD%BD-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-常见的排序算法："><a href="#1-常见的排序算法：" class="headerlink" title="1. 常见的排序算法："></a>1. 常见的排序算法：</h2><p><a href="#1、冒泡排序">冒泡排序</a>、<a href="#2、快速排序">快速排序</a>、<a href="#3、简单插入排序">简单插入排序</a>、<a href="#4、希尔排序">希尔排序</a>、<a href="#5、简单选择排序">简单选择排序</a>、<a href="#6、堆排序">堆排序</a>、<a href="#7、二路归并排序">二路归并排序</a>、<a href="#8、多路归并排序">多路归并排序</a>、<a href="#8、计数排序">计数排序</a>、<a href="#9、桶排序">桶排序</a>、<a href="#10、基数排序">基数排序</a>等<br><a id="more"></a><br><img data-src="排序算法概览.png" alt="常见的排序算法"></p><h2 id="2-算法复杂度："><a href="#2-算法复杂度：" class="headerlink" title="2. 算法复杂度："></a>2. 算法复杂度：</h2><p><img data-src="算法复杂度.png" alt="算法复杂度"></p><h2 id="3-相关概念："><a href="#3-相关概念：" class="headerlink" title="3. 相关概念："></a>3. 相关概念：</h2><ul><li>稳定：两个相等的数，排序后顺序不变</li><li>不稳定：两个相等的数，排序后顺序可能会变</li><li>时间复杂度：对排序数据的总的操作次数</li><li>空间复杂度：指计算机内执行时所需存储空间的度量</li></ul><h1 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h1><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><h3 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。<h3 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><img data-src="1.2演示.gif" alt=""><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<h3 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h3><img data-src="2.2演示.gif" alt=""><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != <span class="string">'number'</span> ? 0 : left,</span><br><span class="line">        right = typeof right != <span class="string">'number'</span> ? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    <span class="keyword">for</span> (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    <span class="built_in">return</span> index-1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。<h3 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h3><img data-src="3.2演示.gif" alt=""><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h3><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><hr><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><p>1959年Shell发明，第一个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><h3 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 修改于 2019-03-06</span><br><span class="line"><span class="keyword">function</span> shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;</span><br><span class="line">        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br><span class="line">        <span class="keyword">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            var j = i;</span><br><span class="line">            var current = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。<h3 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h3><img data-src="5.2演示.gif" alt=""><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><hr><h2 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h3 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h3><img data-src="6.2演示.gif" alt=""><h3 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h3 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。<h3 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h3><img data-src="7.2演示.gif" alt=""><h3 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mergeSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; 2) &#123;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="built_in">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-4-算法分析"><a href="#7-4-算法分析" class="headerlink" title="7.4 算法分析"></a>7.4 算法分析</h3><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><hr><h2 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<h3 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h3><img data-src="8.2演示.gif" alt=""><h3 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><hr><h2 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 <h3 id="9-2-动图演示"><a href="#9-2-动图演示" class="headerlink" title="9.2 动图演示"></a>9.2 动图演示</h3><img data-src="9.2演示.gif" alt=""><h3 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === 0) &#123;</span><br><span class="line">      <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    <span class="keyword">for</span> (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        <span class="keyword">for</span> (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><hr><h2 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）； <h3 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h3><img data-src="10.2演示.gif" alt=""><h3 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line"><span class="keyword">function</span> radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        <span class="keyword">for</span>(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        <span class="keyword">for</span>(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=null) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].<span class="built_in">shift</span>()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h3><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SS加速</title>
      <link href="/20190324/ss%E5%8A%A0%E9%80%9F/"/>
      <url>/20190324/ss%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="ss加速"><a href="#ss加速" class="headerlink" title="ss加速"></a>ss加速</h1><h2 id="bbr-加速下载"><a href="#bbr-加速下载" class="headerlink" title="bbr 加速下载"></a>bbr 加速下载</h2><p>参考文章：<a href="https://teddysun.com/489.html" target="_blank" rel="noopener">秋水逸冰 - 一键安装最新内核并开启 BBR 脚本</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h2 id="锐速ServerSpeeder"><a href="#锐速ServerSpeeder" class="headerlink" title="锐速ServerSpeeder"></a>锐速ServerSpeeder</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh</span><br><span class="line">$ bash serverspeeder.sh</span><br></pre></td></tr></table></figure><hr><p><strong>PS:</strong> <a href="https://www.moerats.com/archives/387/" target="_blank" rel="noopener">BBR+BBR魔改+Lotsever(锐速)一键脚本 for Centos/Debian/Ubuntu</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> VPN架设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django初步</title>
      <link href="/20190224/django%E5%88%9D%E6%AD%A5/"/>
      <url>/20190224/django%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文中程序在Window上运行。</p><blockquote><p><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a> 是一个高级Python Web框架，鼓励快速开发和干净，实用的设计。由经验丰富的开发人员构建，它解决了Web开发的大部分麻烦，因此您可以专注于编写应用程序而无需重新造轮子。它是免费的而且开源的框架。</p></blockquote><a id="more"></a><h1 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h1><p>如果使用 Windows，建议尝试使用<a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">Visual Studio</a> 做 Django 开发</p><h2 id="1-1-安装-Python-环境"><a href="#1-1-安装-Python-环境" class="headerlink" title="1.1 安装 Python 环境"></a>1.1 安装 Python 环境</h2><p>把 <code>Python3</code> 作为第一选择，具体安装请移步<a href="https://www.runoob.com/python3/python3-install.html" target="_blank" rel="noopener">菜鸟教程</a>,再此不做赘述。</p><h2 id="1-2-安装虚拟环境（可选）"><a href="#1-2-安装虚拟环境（可选）" class="headerlink" title="1.2 安装虚拟环境（可选）"></a>1.2 安装虚拟环境（可选）</h2><p>编写新软件程序时，可能（经常）要修改其他软件所需的依赖或环境变量。为了避免这一步可能引起的问题，安装虚拟环境是必要的。虚拟环境把软件所需的全部依赖和环境变量包装到一个文件夹中，与电脑中的其他软件隔离开。<br>安装 <code>virtualenv</code></p><pre><code>pip install virtualenv</code></pre><p>安装好 <code>virtualenv</code> 之后，输入下述命令，为你的项目创建一个虚拟环境-env_mysite(同下)：</p><pre><code>virtualenv env_mysite</code></pre><p>等<code>virtualenv</code> 设置好新的虚拟环境之后，会看到一个名为 <code>\env_mysite</code> 的文件夹（或者为虚拟环境起的其他名称）。打开那个文件夹，会看到下述结构：</p><ul><li>\Include</li><li>\Lib</li><li>\Scripts</li><li>\src</li></ul><p>若想使用这个新建的 <code>Python 虚拟环境</code>，要将其激活。回到命令提示符，输入下述命令：</p><pre><code>env_mysite\scripts\activate</code></pre><p>这个命令会运行虚拟环境中 \scripts 文件夹里的 activate 脚本。你会发现，现在命令提示符变了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(env_mysite) C:\Users\Admin&gt;</span><br></pre></td></tr></table></figure></p><p>命令提示符开头的 (env_mysite) 是告诉你，你正在那个虚拟环境中。</p><blockquote><ul><li>查看当前环境中所有软件包： <code>pip list</code> </li><li>停用当前虚拟环境： <code>env_mysite\scripts\deactivate</code> </li><li>统计所有软件包： <code>pip freeze &gt; freeze.txt</code><br>安装所有必需的包： <code>pip install -r freeze.txt</code> </li></ul></blockquote><h2 id="1-3-安装Django"><a href="#1-3-安装Django" class="headerlink" title="1.3 安装Django"></a>1.3 安装Django</h2><p>安装最新稳定版</p><pre><code>pip install django</code></pre><p>输入 <code>pip install django==2.2.2</code> 会安装 <code>Django 2.2.2</code> （明确了版本号）。<br>在虚拟环境的命令提示符中输入 python，然后按回车键，启动Python 交互式解释器。如果成功安装，应该能导入 django 模块：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令提示符</span></span><br><span class="line">(env_mysite) C:\Users\Admin&gt; python</span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 交互式解释器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> django</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>django.get_version()</span><br><span class="line"><span class="string">'2.2.2'</span></span><br></pre></td></tr></table></figure></p><h1 id="2-建立项目"><a href="#2-建立项目" class="headerlink" title="2. 建立项目"></a>2. 建立项目</h1><h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1 创建"></a>2.1 创建</h2><h2 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h2><h2 id="2-3-运行"><a href="#2-3-运行" class="headerlink" title="2.3 运行"></a>2.3 运行</h2><h1 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3. 设计模式"></a>3. 设计模式</h1><h2 id="3-1-视图"><a href="#3-1-视图" class="headerlink" title="3.1 视图"></a>3.1 视图</h2><h2 id="3-2-URL"><a href="#3-2-URL" class="headerlink" title="3.2 URL"></a>3.2 URL</h2><h2 id="3-3-模板"><a href="#3-3-模板" class="headerlink" title="3.3 模板"></a>3.3 模板</h2><h1 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4. 数据库"></a>4. 数据库</h1><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><h1 id="5-创建应用"><a href="#5-创建应用" class="headerlink" title="5. 创建应用"></a>5. 创建应用</h1><h2 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h2><hr><p>参考文档：<br>&emsp;&emsp;<a href="https://docs.djangoproject.com/zh-hans/2.1/" target="_blank" rel="noopener">Django 文档</a><br>&emsp;&emsp;<a href="https://docs.djangoproject.com/zh-hans/2.1/intro/" target="_blank" rel="noopener">Django 教程</a><br>&emsp;&emsp;<a href="https://www.cnblogs.com/zhangxinqi/p/8969006.html" target="_blank" rel="noopener">python3之Django基础篇</a><br>&emsp;&emsp;<a href="http://www.runoob.com/django/django-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a><br>&emsp;&emsp;<img data-src="精通Django.pdf" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Github-绑定域名</title>
      <link href="/20180730/hexo-github-%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
      <url>/20180730/hexo-github-%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取GitHub-Pages的IP"><a href="#1-获取GitHub-Pages的IP" class="headerlink" title="1. 获取GitHub Pages的IP"></a>1. <del>获取GitHub Pages的IP</del></h2><p><del>Ping出Github Pages的IP</del> <code>(解析时没有用到IP地址)</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping YOURNAME.github.io</span><br></pre></td></tr></table></figure></p><h2 id="2-配置域名"><a href="#2-配置域名" class="headerlink" title="2. 配置域名"></a>2. 配置域名</h2><p>在目录 YOURNAME\source 下创建一个名为CNAME的文件，文件的内容是你的二级域名<br> <code>例如：blog.xxxx.com</code> 。</p><h2 id="3-域名解析"><a href="#3-域名解析" class="headerlink" title="3. 域名解析"></a>3. 域名解析</h2><p>拿二级域名<code>blog.xxxx.com</code>举例，记录类型置为CNAME，主机记录置为 <code>blog.xxxx.com</code> 中的 <code>blog</code> ，记录值置为 <code>YOURNAME.githob.io</code></p><p>修改的时候只要修改两个记录类型为A，主机记录分别为@和www的行就可以了</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Github-备份</title>
      <link href="/20180722/hexo-github-%E5%A4%87%E4%BB%BD/"/>
      <url>/20180722/hexo-github-%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>咱用Hexo+GitHub搭建Blog后想要进行备份，方法之一就是通过创建分支把源码放到GitHub上。</p><h1 id="一、-咱要备份哪些文件捏？"><a href="#一、-咱要备份哪些文件捏？" class="headerlink" title="一、 咱要备份哪些文件捏？"></a>一、 咱要备份哪些文件捏？</h1><h2 id="1、-文章"><a href="#1、-文章" class="headerlink" title="1、 文章"></a>1、 文章</h2><p>./source 文件夹，这个就不用说了，这里面包含了你写的文章的 markdown 源码，这个是最重要的。</p><h2 id="2、-配置文件"><a href="#2、-配置文件" class="headerlink" title="2、 配置文件"></a>2、 配置文件</h2><p>根目录下的几个配置文件，主要是 _config.yml、 package.json、 .gitignore。<br><a id="more"></a></p><h2 id="3、-主题文件夹"><a href="#3、-主题文件夹" class="headerlink" title="3、 主题文件夹"></a>3、 主题文件夹</h2><p>./themes/themes_name 这里的 themes_name 指的是你的主题名称， 如果咱对主题进行了一些个性化的配置， 那么这个主题也最好全部备份。</p><h2 id="4、-模版"><a href="#4、-模版" class="headerlink" title="4、 模版"></a>4、 模版</h2><p>./scaffolds 文件夹， 这个文件夹里是创建文    章时的模板， 如果没修改过这个文件夹中的东西， 可以不用备份。</p><h2 id="5、-密钥"><a href="#5、-密钥" class="headerlink" title="5、 密钥"></a>5、 密钥</h2><p>.ssh， 咱认为没必要备份，直接放到GitHub不安全，大不了重新生成嘛。</p><h1 id="二、-备份到哪？"><a href="#二、-备份到哪？" class="headerlink" title="二、 备份到哪？"></a>二、 备份到哪？</h1><p>创建GitHub Pages 时咱创建了两个分支：master 与 hexo</p><ul><li>master 分支用来存放生成的静态网页</li><li>hexo 分支用来存放网站的原始文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line">$ git commit -m <span class="string">'...'</span></span><br><span class="line">$ git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 另附：</span></span><br><span class="line">$ git branch -a <span class="comment"># 查看远程分支</span></span><br><span class="line">$ git branch <span class="comment"># 查看本地分支</span></span><br><span class="line">$ git checkout master <span class="comment"># 切换分支</span></span><br></pre></td></tr></table></figure><h1 id="三、-那么怎么去备份捏？"><a href="#三、-那么怎么去备份捏？" class="headerlink" title="三、 那么怎么去备份捏？"></a>三、 那么怎么去备份捏？</h1><p>创建GitHub Pages 时创建两个分支：master 与 hexo<br>设置hexo 为默认分支，修改_config.yml中的deploy参数， 分支应为master；<br>依次执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add . </span><br><span class="line">$ git commit -m “…”</span><br><span class="line">$ git push –<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure></p><p>提交原始文件到Hexo</p><h1 id="四、-修改日常！"><a href="#四、-修改日常！" class="headerlink" title="四、 修改日常！"></a>四、 修改日常！</h1><p>依次执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'...'</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>指令将改动推送到GitHub（此时当前分支应为hexo）；<br>然后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><p>会发布网站到master分支上。另外，两个过程顺序调转一般不会有问题。</p><h1 id="五、-那么怎么恢复编辑文件捏？"><a href="#五、-那么怎么恢复编辑文件捏？" class="headerlink" title="五、 那么怎么恢复编辑文件捏？"></a>五、 那么怎么恢复编辑文件捏？</h1><pre><code>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b hexo git@github.com:YOURNAME/YOURNAME.github.io.git</span><br><span class="line"><span class="comment"># 在本地新拷贝的YOURNAME.github.io文件夹下通过Git bash依次执行下列指令：</span></span><br><span class="line">$ npm install hexo</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git</span><br><span class="line">（记得，不需要hexo init这条指令）。</span><br></pre></td></tr></table></figure><h1 id="六、-参考文档："><a href="#六、-参考文档：" class="headerlink" title="六、 参考文档："></a>六、 参考文档：</h1><pre><code>(GitHub Pages + Hexo搭建博客)[http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more][使用hexo，如果换了电脑怎么更新博客？(知乎)](https://www.zhihu.com/question/21193762)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器管理面板</title>
      <link href="/20180623/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/"/>
      <url>/20180623/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="免费-Linux-服务器管理面板"><a href="#免费-Linux-服务器管理面板" class="headerlink" title="免费 Linux 服务器管理面板"></a>免费 Linux 服务器管理面板</h1><hr><h2 id="1-宝塔面板"><a href="#1-宝塔面板" class="headerlink" title="1.宝塔面板"></a>1.<a href="https://www.bt.cn/" target="_blank" rel="noopener">宝塔面板</a></h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1).下载"></a>1).下载</h3><ul><li>Linux版<a href="http://download.bt.cn/install/install.sh" target="_blank" rel="noopener">下载</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>Window版<a href="http://download.bt.cn/win/update/net/BtSoft-Win.zip" target="_blank" rel="noopener">下载</a>：<br><a href="http://download.bt.cn/win/update/net/BtSoft-Win.zip" target="_blank" rel="noopener">http://download.bt.cn/win/update/net/BtSoft-Win.zip</a></li></ul><h3 id="2-卸载"><a href="#2-卸载" class="headerlink" title="2).卸载"></a>2).卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f /etc/init.d/bt &amp;&amp; rm -rf /www/server/panel</span><br></pre></td></tr></table></figure><hr><h2 id="2-AMH面板"><a href="#2-AMH面板" class="headerlink" title="2.AMH面板"></a>2.<a href="http://amh.sh/install.htm" target="_blank" rel="noopener">AMH面板</a></h2><p>国内、半开源、有收费版本、中文</p><h3 id="1-下载-1"><a href="#1-下载-1" class="headerlink" title="1).下载"></a>1).下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://amh.sh/amh.sh &amp;&amp; bash amh.sh 2&gt;&amp;1 | tee amh.log</span><br></pre></td></tr></table></figure><h3 id="2-卸载-1"><a href="#2-卸载-1" class="headerlink" title="2).卸载"></a>2).卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">killall php-fpm</span><br><span class="line">amh nginx stop</span><br><span class="line">amh mysql stop</span><br><span class="line"></span><br><span class="line">rm /root/amh -rf;</span><br><span class="line">rm /home/usrdata /home/wwwroot -rf;</span><br><span class="line">rm /usr/<span class="built_in">local</span>/amh* -rf;</span><br><span class="line">rm /usr/<span class="built_in">local</span>/libiconv* -rf;</span><br><span class="line">rm /usr/<span class="built_in">local</span>/nginx* -rf;</span><br><span class="line">rm /usr/<span class="built_in">local</span>/mysql* -rf;</span><br><span class="line">rm /usr/<span class="built_in">local</span>/php* -rf;</span><br><span class="line">rm /etc/init.d/amh-start /etc/amh-iptables /bin/amh -f;</span><br></pre></td></tr></table></figure><hr><h2 id="3-WDCP面板"><a href="#3-WDCP面板" class="headerlink" title="3.WDCP面板"></a>3.<a href="https://www.wdlinux.cn/lanmp/install.html" target="_blank" rel="noopener">WDCP面板</a></h2><p>国内、闭源、免费、中文</p><h3 id="1-下载-2"><a href="#1-下载-2" class="headerlink" title="1).下载"></a>1).下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://dl.wdlinux.cn:5180/lanmp_laster.tar.gz</span><br><span class="line">$ tar zxvf lanmp_laster.tar.gz</span><br><span class="line">$ sh install.sh    (或sh in.sh) (默认会安装wdcp,如果只要web环境,而不想安装wdcp,这里改为 sh lanmp.sh即可)</span><br></pre></td></tr></table></figure><h3 id="2-卸载-2"><a href="#2-卸载-2" class="headerlink" title="2).卸载"></a>2).卸载</h3><p>(注意备份数据,否则后果自负)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh install.sh uninstall    (或sh in.sh uninstall)</span><br></pre></td></tr></table></figure><hr><h2 id="4-VestaCP面板"><a href="#4-VestaCP面板" class="headerlink" title="4.VestaCP面板"></a>4.<a href="http://www.vestacp.com/install/" target="_blank" rel="noopener">VestaCP面板</a></h2><h3 id="1-下载-3"><a href="#1-下载-3" class="headerlink" title="1).下载"></a>1).下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -O http://vestacp.com/pub/vst-install.sh &amp;&amp; bash vst-install.sh</span><br></pre></td></tr></table></figure><h3 id="2-卸载-3"><a href="#2-卸载-3" class="headerlink" title="2).卸载"></a>2).卸载</h3><p>a.停止VESTA服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service vesta stop</span><br></pre></td></tr></table></figure><p>b.卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CentOS:</span><br><span class="line">$ yum remove vesta*</span><br><span class="line">$ rm -f /etc/yum.repos.d/vesta.repo</span><br><span class="line"></span><br><span class="line">Debian/Ubuntu:</span><br><span class="line">$ apt-get remove vesta*</span><br><span class="line">$ rm -f /etc/apt/sources.list.d/vesta.list</span><br></pre></td></tr></table></figure><p>c. 删除数据目录和计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/vesta</span><br></pre></td></tr></table></figure><hr><h2 id="5-AppNode面板"><a href="#5-AppNode面板" class="headerlink" title="5.AppNode面板"></a>5.<a href="https://www.appnode.com/install" target="_blank" rel="noopener">AppNode面板</a></h2><h3 id="1-下载-4"><a href="#1-下载-4" class="headerlink" title="1).下载"></a>1).下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ INSTALL_AGENT=1 INSTALL_APPS=sitemgr INIT_SWAPFILE=1 INSTALL_PKGS=<span class="string">'nginx-stable,php56,mysql56'</span> bash -c <span class="string">"<span class="variable">$(curl -sS http://dl.appnode.com/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="2-卸载-4"><a href="#2-卸载-4" class="headerlink" title="2).卸载"></a>2).卸载</h3><p>a.卸载受控端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appnode agent remove</span><br></pre></td></tr></table></figure><p>b.卸载控制中心</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appnode ccenter remove</span><br></pre></td></tr></table></figure><p>c.清除残留数据和配置<br>如果要彻底清除卸载后的残留数据和配置文件，删除三个目录即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /opt/appnode/&#123;ccenter,agent,ui&#125;/</span><br></pre></td></tr></table></figure><pre><code>注意：由面板安装的环境软件，不会被自动卸载</code></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器管理 </tag>
            
            <tag> Web 网站架设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN的简单架设</title>
      <link href="/20180623/vpn%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%B6%E8%AE%BE/"/>
      <url>/20180623/vpn%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%B6%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>提要：<br>      系统：CentOS 6.9</p></blockquote><h1 id="下载shadowsocks服务端"><a href="#下载shadowsocks服务端" class="headerlink" title="下载shadowsocks服务端"></a>下载shadowsocks服务端</h1><p>参考文章：<a href="https://teddysun.com/486.html" target="_blank" rel="noopener">秋水逸冰 - Shadowsocks 一键安装脚本（四合一）</a></p><p>使用root用户登录，运行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh &amp;&amp; chmod +x shadowsocks-all.sh &amp;&amp; ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure></p><a id="more"></a><hr><h1 id="安装Win-ss客户端"><a href="#安装Win-ss客户端" class="headerlink" title="安装Win ss客户端"></a>安装Win ss客户端</h1><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">常规版 Shadowsocks</a> </p><p><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases" target="_blank" rel="noopener">ShadowsocksR 版</a> </p><hr><h2 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h2><p>若已安装多个版本，则卸载时也需多次运行</p><p>使用root用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>Shadowsocks-Python 版：<br>/etc/init.d/shadowsocks-python start | stop | restart | status</p><p>ShadowsocksR 版：<br>/etc/init.d/shadowsocks-r start | stop | restart | status</p><p>Shadowsocks-Go 版：<br>/etc/init.d/shadowsocks-go start | stop | restart | status</p><p>Shadowsocks-libev 版：<br>/etc/init.d/shadowsocks-libev start | stop | restart | status</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Shadowsocks-Python 版：<br>/etc/shadowsocks-python/config.json</p><p>ShadowsocksR 版：<br>/etc/shadowsocks-r/config.json</p><p>Shadowsocks-Go 版：<br>/etc/shadowsocks-go/config.json</p><p>Shadowsocks-libev 版：<br>/etc/shadowsocks-libev/config.json</p><hr><h1 id="安装多用户版55R"><a href="#安装多用户版55R" class="headerlink" title="安装多用户版55R"></a>安装多用户版55R</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#CentOS系统</span><br><span class="line">yum install unzip ca-certificates -y </span><br><span class="line"></span><br><span class="line">#Debian和Ubuntu系统</span><br><span class="line">apt-get install unzip ca-certificates -y</span><br></pre></td></tr></table></figure><p>安装脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.moerats.com/usr/down/55r.zip &amp;&amp; unzip 55r.zip &amp;&amp; cd 55R* &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure></p><p>卸载脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 55R* &amp;&amp; bash uninstall.sh</span><br></pre></td></tr></table></figure></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="SSR脚本"><a href="#SSR脚本" class="headerlink" title="SSR脚本"></a><a href="wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh">SSR脚本</a></h2><p><strong>PS:</strong> <a href="https://do.freess.today/" target="_blank" rel="noopener">Free SS</a></p><ul><li>19/03/24：更新：另作SS加速</li><li>19/05/24：更新：SSR又一脚本</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> VPN架设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器安防之登陆次数限制</title>
      <link href="/20180517/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E9%98%B2%E4%B9%8B%E7%99%BB%E9%99%86%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/"/>
      <url>/20180517/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E9%98%B2%E4%B9%8B%E7%99%BB%E9%99%86%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继上次爆破防御后，依然有陌生IP骚扰，百无聊赖，续作此篇；</p><hr><h1 id="1-始终允许IP"><a href="#1-始终允许IP" class="headerlink" title="1. 始终允许IP"></a>1. 始终允许IP</h1><p>假设IP：192.168.18.1 是经常登录的IP，填入 /etc/hosts.allow ，当然 :allow 是可以省略的。当hosts.allow和host.deny相冲突时, 以hosts.allow设置为准</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"sshd:192.168.18.1:allow"</span> &gt;&gt; /etc/hosts.allow</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="2-写脚本"><a href="#2-写脚本" class="headerlink" title="2. 写脚本"></a>2. 写脚本</h1><p>在路径 ‘/usr/local/bin/‘ 下，创建文件 ‘secure_ssh.sh’ ，<br>错误次数大于个位数，即错误次数大于等于10就将IP列入黑名单(判断见行7)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /usr/<span class="built_in">local</span>/bin/secure_ssh.sh</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/secure|awk <span class="string">'/Failed/&#123;print $(NF-3)&#125;'</span>|sort|uniq -c|awk <span class="string">'&#123;print $2"="$1;&#125;'</span> &gt; /usr/<span class="built_in">local</span>/bin/black.list</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `cat  /usr/<span class="built_in">local</span>/bin/black.list`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  IP=`<span class="built_in">echo</span> <span class="variable">$i</span> |awk -F= <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">  NUM=`<span class="built_in">echo</span> <span class="variable">$i</span> |awk -F= <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$&#123;#NUM&#125;</span> -gt 1 ]; <span class="keyword">then</span></span><br><span class="line">    grep <span class="variable">$IP</span> /etc/hosts.deny &gt; /dev/null</span><br><span class="line">    <span class="keyword">if</span> [ $? -gt 0 ];<span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"sshd:<span class="variable">$IP</span>:deny"</span> &gt;&gt; /etc/hosts.deny</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="3-列入计划"><a href="#3-列入计划" class="headerlink" title="3. 列入计划"></a>3. 列入计划</h1><p>将脚本文件每一分钟执行一次 (<em> /1 </em> <em> </em> * )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  /1 * * * *  sh /usr/<span class="built_in">local</span>/bin/secure_ssh.sh</span><br><span class="line">或</span><br><span class="line">  * * * * *  sh /usr/<span class="built_in">local</span>/bin/secure_ssh.sh</span><br></pre></td></tr></table></figure><h1 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h1><h2 id="1-查看记录列表"><a href="#1-查看记录列表" class="headerlink" title="1).查看记录列表"></a>1).查看记录列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/<span class="built_in">local</span>/bin/black.list</span><br></pre></td></tr></table></figure><h2 id="2-清空记录列表"><a href="#2-清空记录列表" class="headerlink" title="2).清空记录列表"></a>2).清空记录列表</h2><p>black.list文件是根据secure日志文件通过上面脚本文件生成的，且每分钟会覆盖一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;&quot; &gt; /var/log/secure </span><br><span class="line">$ echo &quot;&quot; &gt; /usr/local/bin/black.list</span><br></pre></td></tr></table></figure><h2 id="3-修改hosts-deny文件"><a href="#3-修改hosts-deny文件" class="headerlink" title="3).修改hosts.deny文件"></a>3).修改hosts.deny文件</h2><p>手动添加或删除IP记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/hosts.deny</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器安防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器安防之VPS爆破防御（简）</title>
      <link href="/20180505/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E9%98%B2%E4%B9%8Bvps%E7%88%86%E7%A0%B4%E9%98%B2%E5%BE%A1%EF%BC%88%E7%AE%80%EF%BC%89/"/>
      <url>/20180505/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E9%98%B2%E4%B9%8Bvps%E7%88%86%E7%A0%B4%E9%98%B2%E5%BE%A1%EF%BC%88%E7%AE%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-检查"><a href="#一、-检查" class="headerlink" title="一、 检查"></a>一、 检查</h1><h2 id="1-查看登录失败的IP"><a href="#1-查看登录失败的IP" class="headerlink" title="1. 查看登录失败的IP"></a>1. 查看登录失败的IP</h2><p>显示错误次数 如果错误次数太大 你的服务器十有八九曾被暴力破解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">"Failed password for root"</span> /var/<span class="built_in">log</span>/secure | awk <span class="string">'&#123;print $11&#125;'</span> | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure><a id="more"></a><p><img data-src="Failed login.png" alt="Failed login"></p><h2 id="2-列出用户所有的登录时间和登录终端的地址"><a href="#2-列出用户所有的登录时间和登录终端的地址" class="headerlink" title="2. 列出用户所有的登录时间和登录终端的地址"></a>2. 列出用户所有的登录时间和登录终端的地址</h2><p>为了验证是否被入侵，可以先查看现在谁在登录服务器，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last | more</span><br></pre></td></tr></table></figure><p>显示系统中所有用户最近一次登录信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lastlog</span><br></pre></td></tr></table></figure><h1 id="二、-处理"><a href="#二、-处理" class="headerlink" title="二、 处理"></a>二、 处理</h1><h2 id="1-加入到黑名单"><a href="#1-加入到黑名单" class="headerlink" title="1. 加入到黑名单"></a>1. 加入到黑名单</h2><p>把对方IP加入到黑名单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/hosts.deny</span><br><span class="line">$ /etc/hosts.deny</span><br></pre></td></tr></table></figure><h2 id="2-禁止所有IP访问SSH功能"><a href="#2-禁止所有IP访问SSH功能" class="headerlink" title="2. 禁止所有IP访问SSH功能"></a>2. 禁止所有IP访问SSH功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"sshd:all:deny"</span> &gt;&gt; /etc/hosts.deny</span><br></pre></td></tr></table></figure><h2 id="3-更改端口号"><a href="#3-更改端口号" class="headerlink" title="3. 更改端口号"></a>3. 更改端口号</h2><p>编辑sshd配置，修改默认的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>按【i】，进入编辑模式，找到并注释如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Port 22</span></span><br></pre></td></tr></table></figure><p>按【Esc】退出编辑模式，【Shift】+【：】进入命令模式，”:wq”保存并退出</p><h2 id="4-禁止root-ssh登录"><a href="#4-禁止root-ssh登录" class="headerlink" title="4. 禁止root ssh登录"></a>4. 禁止root ssh登录</h2><p>修改sshd_conf文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>注释一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PermitRootLogin no</span></span><br></pre></td></tr></table></figure><h1 id="三、-重启ssh"><a href="#三、-重启ssh" class="headerlink" title="三、 重启ssh"></a>三、 重启ssh</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br><span class="line">或</span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><!--      或尝试    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart </span><br><span class="line">/etc/init.d/sshd reload</span><br><span class="line">/etc/init.d/sshd restart</span><br></pre></td></tr></table></figure><p>–&gt;</p>-->]]></content>
      
      
      
        <tags>
            
            <tag> 服务器安防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github</title>
      <link href="/20180401/hexo-github/"/>
      <url>/20180401/hexo-github/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-准备环境"><a href="#一、-准备环境" class="headerlink" title="一、 准备环境"></a>一、 准备环境</h1><h2 id="1-Github账户"><a href="#1-Github账户" class="headerlink" title="1. Github账户"></a>1. Github账户</h2><p>注册并新建项目，项目必须要遵守格式：YOUR_NAME.github.io</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a></h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>还可以前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝 Git for Windows 镜像</a></li><li><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">更多参见</a></li></ul><a id="more"></a><h3 id="配置好Git环境"><a href="#配置好Git环境" class="headerlink" title="配置好Git环境"></a>配置好Git环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your_name"</span></span><br><span class="line">git config --global user.email <span class="string">"your_email"</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure><details><br><summary>CRLF问题(折叠)</summary><br><blockquote><br>    首先问题出在不同操作系统所使用的换行符是不一样的，下面罗列一下三大主流操作系统的换行符：<br>    Uinx/Linux采用换行符LF表示下一行（LF：LineFeed，中文意思是换行）；<br>    Dos和Windows采用回车+换行CRLF表示下一行（CRLF：CarriageReturn LineFeed，中文意思是回车换行）；<br>    Mac OS采用回车CR表示下一行（CR：CarriageReturn，中文意思是回车）。<br>    为true时，Git会将你add的所有文件视为文本问价你，将结尾的CRLF转换为LF，而checkout时会再将文件的LF格式转为CRLF格式。<br>    为false时，line endings不做任何改变，文本文件保持其原来的样子。<br>    为input时，add时Git会把CRLF转换为LF，而check时仍旧为LF，所以Windows操作系统不建议设置此值。<br></blockquote><br></details><h3 id="创建ssh密钥，将公钥上传"><a href="#创建ssh密钥，将公钥上传" class="headerlink" title="创建ssh密钥，将公钥上传"></a>创建ssh密钥，将公钥上传</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email"</span>// 创建密钥对</span><br><span class="line">ssh -T git@github.com  //测试添加ssh是否成功</span><br></pre></td></tr></table></figure><ul><li>更多参见<a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">Github</a></li></ul><h2 id="3-安装Node-js"><a href="#3-安装Node-js" class="headerlink" title="3. 安装Node.js"></a>3. 安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a></h2><ul><li>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装程序</a>。</li><li>对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="noopener">淘宝 Node.js 镜像</a> 下载。<br>-更多参见<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js" target="_blank" rel="noopener">Hexo</a></li></ul><h2 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4. 安装Hexo"></a>4. 安装<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></h2><p>使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v //检查hexo是否安装成功</span><br></pre></td></tr></table></figure><ul><li>更多参见<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo" target="_blank" rel="noopener">Hexo</a></li></ul><h1 id="二、-本地博客-fighting"><a href="#二、-本地博客-fighting" class="headerlink" title="二、 本地博客 - fighting"></a>二、 本地博客 - fighting</h1><h2 id="1-初始化博客"><a href="#1-初始化博客" class="headerlink" title="1. 初始化博客"></a>1. 初始化博客</h2><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br><span class="line"><span class="built_in">cd</span> [folder]</span><br><span class="line">npm install// 安装所需要的组件</span><br><span class="line">hexo g// 生成静态文件--public文件夹下</span><br></pre></td></tr></table></figure><ul><li>更多参见<a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">Hexo</a></li></ul><h2 id="2-开启本地服务"><a href="#2-开启本地服务" class="headerlink" title="2. 开启本地服务"></a>2. 开启本地服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>可以改变端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 端口号</span><br></pre></td></tr></table></figure><h1 id="三、-推送到GitHub"><a href="#三、-推送到GitHub" class="headerlink" title="三、 推送到GitHub"></a>三、 推送到GitHub</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h2><p>打开<code>_config.yml</code>文件，修改repo值（在末尾）</p><blockquote><p>注：所有配置项目的分号后都需要一个空格</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: git@github.com:YOUR_NAME/YOUR_NAME.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2 id="2-生成及部署文章"><a href="#2-生成及部署文章" class="headerlink" title="2. 生成及部署文章"></a>2. 生成及部署文章</h2><p>生成以及部署文章之前，需要安装一个扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>在_posts目录下新建一篇博文，编辑器编好文章，那么就可以生成以及部署了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">"博文名"</span>// _posts目录下新建一篇博文</span><br><span class="line">hexo d -g// 生成以及部署</span><br></pre></td></tr></table></figure><h2 id="3-其他命令："><a href="#3-其他命令：" class="headerlink" title="3. 其他命令："></a>3. 其他命令：</h2><ul><li>更多参见<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo</a></li></ul><h1 id="四、-备份"><a href="#四、-备份" class="headerlink" title="四、 备份"></a>四、 备份</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>版本是2.x.x使用这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-git-backup@0.0.91 --save</span><br></pre></td></tr></table></figure><p>版本是3.x.x 或3+则使用这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>如果使用–save进行安装，则必须在更新时先将其删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-git-backup</span><br><span class="line">npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改<code>_config.yml</code>文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backup:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repository:</span><br><span class="line">       github: git@github.com:xxx/xxx.git,branchName</span><br><span class="line">       gitcafe: git@github.com:xxx/xxx.git,branchName</span><br></pre></td></tr></table></figure></p><h2 id="备份到Github"><a href="#备份到Github" class="headerlink" title="备份到Github"></a>备份到Github</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo b</span><br></pre></td></tr></table></figure><ul><li>更多参见<a href="https://www.npmjs.com/package/hexo-git-backup" target="_blank" rel="noopener">npmjs</a>或<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">GitHub</a></li></ul><h1 id="五、-迁移方法"><a href="#五、-迁移方法" class="headerlink" title="五、 迁移方法"></a>五、 迁移方法</h1><h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p>安装hexo-migrator-rss 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-migrator-rss --save</span><br></pre></td></tr></table></figure><p>执行 (<source> 文件路径或网址)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate rss &lt;<span class="built_in">source</span>&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 更多参见[Hexo](https://hexo.io/zh-cn/docs/migration)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[^_^]:</span><br><span class="line">    b</span><br><span class="line">[comment]: &lt;地方&gt; (This is a comment, it will not be included)</span><br><span class="line">[comment]: &lt;&gt; (<span class="keyword">in</span>  the output file unless you use it <span class="keyword">in</span>)</span><br><span class="line">[comment]: &lt;&gt; (a reference style link.)</span><br><span class="line">[//]: &lt;&gt; (This is also a comment.)</span><br><span class="line">[//]: <span class="comment"># (This may be the most platform independent comment)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 六、 其他</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 部署至FTP服务器</span></span><br><span class="line"></span><br><span class="line">- 安装插件</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">npm install hexo-deployer-ftpsync –save</span><br></pre></td></tr></table></figure><ul><li>修改配置</li><li>修改<code>_config.yml</code>文件:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: ftpsync <span class="comment">#上传方式，固定ftpsync</span></span><br><span class="line">  host: hfanss.ftp-gz01.com <span class="comment">#ftp地址</span></span><br><span class="line">  user: ****<span class="comment">#帐号</span></span><br><span class="line">  pass: ****<span class="comment">#密码</span></span><br><span class="line">  remote: /webroot/ <span class="comment">#上传至哪个目录</span></span><br><span class="line">  port: 8010<span class="comment">#端口</span></span><br></pre></td></tr></table></figure><h2 id="2-部署至腾讯云COS"><a href="#2-部署至腾讯云COS" class="headerlink" title="2. 部署至腾讯云COS"></a>2. 部署至腾讯云COS</h2><ul><li>安装插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-cos --save</span><br></pre></td></tr></table></figure><ul><li>修改配置</li><li>修改<code>_config.yml</code>文件:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: cos<span class="comment">#上传方式，固定cos</span></span><br><span class="line">  appId: 12529*****  <span class="comment">#cos的appId</span></span><br><span class="line">  secretId: AKI******<span class="comment">#cos的secretId</span></span><br><span class="line">  secretKey: **********<span class="comment">#cos的secretKey</span></span><br><span class="line">  bucket: *********<span class="comment">#cos的bucket</span></span><br><span class="line">  region: ap-shanghai<span class="comment">#cos的region</span></span><br></pre></td></tr></table></figure><h2 id="3-使用淘宝镜像CNPM安装插件"><a href="#3-使用淘宝镜像CNPM安装插件" class="headerlink" title="3. 使用淘宝镜像CNPM安装插件"></a>3. 使用淘宝镜像CNPM安装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">e.g. cnpm install hexo-deployer-ftpsync –save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
